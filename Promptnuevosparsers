# PROMPT PARA CURSOR - IMPLEMENTACIÃ“N PARSERS DE RECONOCIMIENTO

---

## ğŸ“‹ CONTEXTO

Necesito implementar 21 parsers nuevos para la fase de reconocimiento del mÃ³dulo de reporterÃ­a.

**Estado actual:**
- âœ… 5 parsers ya funcionando (Subfinder, Amass, Nmap, Nuclei, Nikto)
- âœ… Sistema de parsers con BaseParser y ParserManager
- âŒ Faltan 21 parsers de reconocimiento

**Objetivo:**
Implementar los 21 parsers faltantes siguiendo la guÃ­a tÃ©cnica completa.

---

## ğŸ“š DOCUMENTACIÃ“N DE REFERENCIA

**Lee primero**: `GUIA_PARSERS_RECONNAISSANCE.md`

Este documento contiene:
- CÃ³digo completo de los 21 parsers
- Estructura de directorios
- Tests unitarios
- Fixtures de ejemplo
- Registro en ParserManager

---

## ğŸ¯ INSTRUCCIONES DE IMPLEMENTACIÃ“N

### **IMPORTANTE: IMPLEMENTAR POR FASES**

NO implementes todo de una vez. Vamos fase por fase para validar que cada grupo funciona correctamente.

---

## ğŸš€ FASE 1: SUBDOMAIN PARSERS (4 parsers)

### **Prioridad: CRÃTICA**
### **Tiempo estimado: 1 hora**

**Tareas:**

1. âœ… **Crear estructura de directorios**:
```
services/reporting/parsers/reconnaissance/
â”œâ”€â”€ __init__.py
â””â”€â”€ subdomain/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ assetfinder_parser.py
    â”œâ”€â”€ sublist3r_parser.py
    â”œâ”€â”€ findomain_parser.py
    â””â”€â”€ crtsh_parser.py
```

2. âœ… **Implementar los 4 parsers**:
   - Copia EXACTAMENTE el cÃ³digo de la secciÃ³n "PARSERS DE SUBDOMINIOS" de la guÃ­a
   - AssetfinderParser (lÃ­neas 89-153)
   - Sublist3rParser (lÃ­neas 159-215)
   - FindomainParser (lÃ­neas 221-268)
   - CrtshParser (lÃ­neas 274-321)

3. âœ… **Registrar en ParserManager**:
   - Abre `services/reporting/parsers/parser_manager.py`
   - Agrega imports:
   ```python
   from .reconnaissance.subdomain.assetfinder_parser import AssetfinderParser
   from .reconnaissance.subdomain.sublist3r_parser import Sublist3rParser
   from .reconnaissance.subdomain.findomain_parser import FindomainParser
   from .reconnaissance.subdomain.crtsh_parser import CrtshParser
   ```
   - En `_register_parsers()`, agrega:
   ```python
   # Subdomain parsers
   self.parsers.extend([
       AssetfinderParser(),
       Sublist3rParser(),
       FindomainParser(),
       CrtshParser(),
   ])
   ```

4. âœ… **Crear tests**:
   - Crea `tests/unit/test_subdomain_parsers.py`
   - Copia la clase `TestSubdomainParsers` de la guÃ­a (lÃ­neas 1950-1978)

5. âœ… **Crear fixtures**:
   - Crea `tests/fixtures/reconnaissance/`
   - Crea archivos:
     - `assetfinder_sample.txt`
     - `sublist3r_sample.txt`
     - `findomain_sample.txt`
     - `crtsh_sample.txt`
   - Contenido ejemplo (3-5 subdominios por archivo):
   ```txt
   api.example.com
   www.example.com
   mail.example.com
   ```

6. âœ… **Ejecutar tests**:
```bash
pytest tests/unit/test_subdomain_parsers.py -v
```

**ESPERA MI VALIDACIÃ“N antes de continuar con FASE 2.**

---

## ğŸ” FASE 2: DNS PARSERS (4 parsers)

### **Prioridad: ALTA**
### **Tiempo estimado: 1.5 horas**

**DespuÃ©s de que yo valide FASE 1, continÃºa con:**

1. âœ… **Crear estructura**:
```
services/reporting/parsers/reconnaissance/
â””â”€â”€ dns/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ dnsrecon_parser.py
    â”œâ”€â”€ fierce_parser.py
    â”œâ”€â”€ dnsenum_parser.py
    â””â”€â”€ traceroute_parser.py
```

2. âœ… **Implementar los 4 parsers**:
   - DNSReconParser (lÃ­neas 327-459) - JSON complejo
   - FierceParser (lÃ­neas 465-599) - TXT con regex
   - DNSEnumParser (lÃ­neas 605-736) - TXT con secciones
   - TracerouteParser (lÃ­neas 742-894) - TXT con saltos

3. âœ… **Registrar en ParserManager**

4. âœ… **Crear tests**: `test_dns_parsers.py`

5. âœ… **Crear fixtures**:
   - `dnsrecon_sample.json` (formato JSON de la guÃ­a lÃ­nea 339)
   - `fierce_sample.txt` (formato TXT de la guÃ­a lÃ­nea 477)
   - `dnsenum_sample.txt`
   - `traceroute_sample.txt`

6. âœ… **Ejecutar tests**:
```bash
pytest tests/unit/test_dns_parsers.py -v
```

**ESPERA MI VALIDACIÃ“N antes de continuar con FASE 3.**

---

## ğŸ” FASE 3: OSINT PARSERS (5 parsers)

### **Prioridad: ALTA**
### **Tiempo estimado: 2 horas**

**DespuÃ©s de validar FASE 2:**

1. âœ… **Crear estructura**:
```
services/reporting/parsers/reconnaissance/
â””â”€â”€ osint/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ shodan_parser.py
    â”œâ”€â”€ censys_parser.py
    â”œâ”€â”€ theharvester_parser.py
    â”œâ”€â”€ hunterio_parser.py
    â””â”€â”€ wayback_parser.py
```

2. âœ… **Implementar los 5 parsers**:
   - ShodanParser (lÃ­neas 900-1058) - JSON con vulnerabilidades
   - CensysParser (lÃ­neas 1064-1171) - JSON con certificados
   - TheHarvesterParser (lÃ­neas 1177-1316) - JSON con emails/hosts
   - HunterioParser (lÃ­neas 1322-1466) - JSON con confidence
   - WaybackParser (lÃ­neas 1472-1579) - TXT con timestamps

3. âœ… **Registrar en ParserManager**

4. âœ… **Crear tests**: `test_osint_parsers.py`

5. âœ… **Crear fixtures** (JSON y TXT segÃºn formato de la guÃ­a)

6. âœ… **Ejecutar tests**:
```bash
pytest tests/unit/test_osint_parsers.py -v
```

**ESPERA MI VALIDACIÃ“N antes de continuar con FASE 4.**

---

## ğŸŒ FASE 4: WEB PARSERS (2 parsers)

### **Prioridad: MEDIA**
### **Tiempo estimado: 45 minutos**

**DespuÃ©s de validar FASE 3:**

1. âœ… **Crear estructura**:
```
services/reporting/parsers/reconnaissance/
â””â”€â”€ web/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ whatweb_parser.py
    â””â”€â”€ webcrawler_parser.py
```

2. âœ… **Implementar los 2 parsers**:
   - WhatWebParser (lÃ­neas 1585-1724) - JSON con plugins
   - WebCrawlerParser (lÃ­neas 1730-1883) - TXT con clasificaciÃ³n

3. âœ… **Registrar en ParserManager**

4. âœ… **Crear tests**: `test_web_parsers.py`

5. âœ… **Crear fixtures**

6. âœ… **Ejecutar tests**

**ESPERA MI VALIDACIÃ“N antes de continuar con FASE 5.**

---

## ğŸ” FASE 5: OTHER PARSERS (3 parsers)

### **Prioridad: ALTA (SecretsParser es crÃ­tico)**
### **Tiempo estimado: 1 hora**

**DespuÃ©s de validar FASE 4:**

1. âœ… **Crear estructura**:
```
services/reporting/parsers/reconnaissance/
â””â”€â”€ other/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ whois_parser.py
    â”œâ”€â”€ googledorks_parser.py
    â””â”€â”€ secrets_parser.py
```

2. âœ… **Implementar los 3 parsers**:
   - WhoisParser (lÃ­neas 1889-2012)
   - GoogleDorksParser (lÃ­neas 2018-2154) - ClasificaciÃ³n crÃ­tica
   - SecretsParser (lÃ­neas 2160-2299) - CRÃTICO: API keys, passwords

3. âœ… **Registrar en ParserManager**

4. âœ… **Crear tests**: `test_other_parsers.py`

5. âœ… **Crear fixtures**

6. âœ… **Ejecutar tests**

**ESPERA MI VALIDACIÃ“N final.**

---

## âœ… VALIDACIÃ“N FINAL

DespuÃ©s de completar las 5 fases:

1. âœ… **Ejecutar TODOS los tests**:
```bash
pytest tests/unit/test_*_parsers.py -v
```

2. âœ… **Verificar ParserManager**:
```python
from services.reporting.parsers.parser_manager import ParserManager

pm = ParserManager()
print(f"Total parsers: {len(pm.parsers)}")
# Debe mostrar: 26 (5 existentes + 21 nuevos)
```

3. âœ… **Test end-to-end**:
   - Generar un reporte desde el frontend
   - Verificar logs: `tail -f logs/flask.log | grep "Parsed"`
   - Debe mostrar mensajes como:
     - "Assetfinder: Parsed X subdomains"
     - "DNSRecon: Parsed X DNS records"
     - "Shodan: Parsed X service discoveries"
     - etc.

4. âœ… **Verificar reporte generado**:
   - Abrir PDF
   - Verificar que incluye findings de las nuevas herramientas
   - Verificar categorÃ­as: reconnaissance, dns_enumeration, osint, etc.

---

## âš ï¸ CONSIDERACIONES IMPORTANTES

### **Manejo de Errores**
- TODOS los parsers deben tener try/except
- Nunca dejar que un parser falle todo el sistema
- Loguear errores con `logger.error()`

### **ValidaciÃ³n de Archivos**
- MÃ©todo `can_parse()` debe ser preciso
- Verificar extensiÃ³n (.txt, .json)
- Verificar palabra clave en nombre de archivo

### **Formato de Findings**
- SIEMPRE usar `ParsedFinding` de `base_parser`
- Campos obligatorios: title, severity, description, category
- Campo `raw_data` SIEMPRE debe incluir: `{'tool': 'nombre_herramienta'}`

### **Severidades**
- `critical`: Secrets expuestos, backups .sql
- `high`: Vulnerabilidades conocidas (Shodan), configuraciones sensibles
- `medium`: URLs sensibles, logs expuestos
- `low`: Emails con alta confidence, paths admin
- `info`: Subdominios, DNS records, fingerprinting

### **CategorÃ­as**
- `reconnaissance`: Subdominios, WHOIS, IPs
- `dns_enumeration`: DNS records, name servers
- `osint`: Shodan, Censys, emails, historical data
- `web_reconnaissance`: Fingerprinting, crawling
- `web_vulnerability`: URLs sensibles
- `information_disclosure`: Google Dorks
- `secrets_exposure`: API keys, passwords, tokens

---

## ğŸ§ª ESTRUCTURA DE TESTS

Cada archivo de tests debe seguir este patrÃ³n:

```python
import pytest
from pathlib import Path
from services.reporting.parsers.reconnaissance.CATEGORIA import parser_module

FIXTURES_DIR = Path(__file__).parent.parent / 'fixtures' / 'reconnaissance'

class TestNombreParsers:
    """Tests para parsers de CATEGORIA."""
    
    def test_nombre_parser(self):
        """Test NombreParser."""
        parser = parser_module.NombreParser()
        fixture_file = FIXTURES_DIR / 'nombre_sample.txt'
        
        findings = parser.parse(fixture_file)
        
        assert len(findings) > 0
        assert all(f.category == 'expected_category' for f in findings)
        assert all('tool' in f.raw_data for f in findings)
```

---

## ğŸ“¦ ESTRUCTURA DE FIXTURES

Cada fixture debe ser MÃNIMO pero VÃLIDO:

**JSON fixtures**:
```json
{
  "campo_requerido": "valor",
  "lista": ["item1", "item2"]
}
```

**TXT fixtures**:
```txt
linea1.example.com
linea2.example.com
linea3.example.com
```

**NO NECESITAS archivos gigantes**, con 3-5 lÃ­neas/objetos es suficiente.

---

## ğŸš¨ PROBLEMAS COMUNES Y SOLUCIONES

### **Problema 1: ImportError en tests**
```bash
# SoluciÃ³n: Agregar __init__.py en todos los directorios
touch services/reporting/parsers/reconnaissance/__init__.py
touch services/reporting/parsers/reconnaissance/subdomain/__init__.py
# etc.
```

### **Problema 2: Fixtures no encontrados**
```bash
# SoluciÃ³n: Verificar que exista el directorio
mkdir -p tests/fixtures/reconnaissance
```

### **Problema 3: Parser no se registra**
```python
# SoluciÃ³n: Verificar imports en parser_manager.py
# Deben estar TODOS los nuevos parsers importados
```

### **Problema 4: JSON invÃ¡lido en fixtures**
```bash
# SoluciÃ³n: Validar JSON antes de guardar
python -m json.tool fixture.json
```

---

## ğŸ“Š MÃ‰TRICAS DE Ã‰XITO

Al finalizar, debes tener:

- âœ… **21 parsers nuevos** implementados
- âœ… **26 parsers totales** registrados en ParserManager
- âœ… **Todos los tests passing** (0 failures)
- âœ… **Logs sin errores** al generar reportes
- âœ… **Reportes incluyen findings** de las nuevas herramientas
- âœ… **Cobertura de cÃ³digo** >85% en nuevos parsers

---

## ğŸ¯ WORKFLOW RECOMENDADO

### **Por cada FASE:**

1. **Implementar cÃ³digo** (copiar de la guÃ­a)
2. **Registrar en ParserManager**
3. **Crear tests**
4. **Crear fixtures mÃ­nimos**
5. **Ejecutar tests**: `pytest tests/unit/test_FASE_parsers.py -v`
6. **Si tests fallan**: Revisar cÃ³digo, fixtures, imports
7. **Si tests pasan**: Avisar para validaciÃ³n manual
8. **Esperar confirmaciÃ³n** antes de siguiente fase

### **NO HAGAS:**
- âŒ Implementar todas las fases de una
- âŒ Saltar tests
- âŒ Inventar cÃ³digo (usa el de la guÃ­a)
- âŒ Avanzar sin validaciÃ³n

### **SÃ HACE:**
- âœ… Una fase a la vez
- âœ… Tests despuÃ©s de cada fase
- âœ… Copiar cÃ³digo exacto de la guÃ­a
- âœ… Esperar validaciÃ³n entre fases

---

## ğŸ“ COMANDO INICIAL PARA CURSOR

```
Hola Cursor,

Lee completo el archivo GUIA_PARSERS_RECONNAISSANCE.md.

Luego implementa la FASE 1 (Subdomain Parsers) siguiendo estas instrucciones:

1. Crea estructura: services/reporting/parsers/reconnaissance/subdomain/
2. Implementa los 4 parsers copiando el cÃ³digo de la guÃ­a
3. Registra en ParserManager
4. Crea tests y fixtures
5. Ejecuta tests

DespuÃ©s de completar FASE 1, avÃ­same para que yo valide antes de continuar con FASE 2.

NO implementes FASE 2, 3, 4 o 5 hasta que yo te confirme.

Empieza creando la estructura de directorios del subdomain/.
```

---

## ğŸ BONUS: VERIFICACIÃ“N RÃPIDA

DespuÃ©s de cada fase, ejecuta este script para verificar:

```python
# verify_phase.py
from services.reporting.parsers.parser_manager import ParserManager

pm = ParserManager()

# Contar parsers por categorÃ­a
recon_parsers = [p for p in pm.parsers if 'reconnaissance' in str(type(p).__module__)]

print(f"Total parsers: {len(pm.parsers)}")
print(f"Reconnaissance parsers: {len(recon_parsers)}")
print("\nReconnaissance parsers list:")
for p in recon_parsers:
    print(f"  - {type(p).__name__}")
```

**Output esperado despuÃ©s de FASE 1:**
```
Total parsers: 9 (5 existentes + 4 nuevos)
Reconnaissance parsers: 4
  - AssetfinderParser
  - Sublist3rParser
  - FindomainParser
  - CrtshParser
```

---

## âœ… CHECKLIST FINAL

### **DespuÃ©s de completar las 5 fases:**

- [ ] 21 parsers implementados
- [ ] ParserManager tiene 26 parsers totales
- [ ] Todos los tests passing
- [ ] Fixtures creados (mÃ­nimo 3-5 lÃ­neas/archivo)
- [ ] Logs sin errores
- [ ] Reporte generado incluye nuevos findings
- [ ] VerificaciÃ³n manual exitosa

---

## ğŸ†˜ SI ALGO FALLA

1. **Revisa logs**: `tail -f logs/flask.log`
2. **Ejecuta tests con verbose**: `pytest -vv`
3. **Verifica imports**: Todos los `__init__.py` creados
4. **Compara con guÃ­a**: El cÃ³digo debe ser idÃ©ntico
5. **PregÃºntame**: Con el error completo y stack trace

---

## ğŸš€ RESULTADO ESPERADO

Al finalizar las 5 fases:

**Antes:**
- 5 parsers
- Reportes con 50-100 findings

**DespuÃ©s:**
- 26 parsers
- Reportes con 200-500 findings
- Cobertura completa de reconocimiento

**Beneficio:** Reportes 3-5x mÃ¡s completos ğŸ¯

---

**VersiÃ³n**: 1.0  
**Fecha**: 10 Diciembre 2025  
**Autor**: Claude AI

---

## ğŸ“ CONTACTO

Si tenÃ©s dudas en alguna fase, avisame con:
- NÃºmero de fase
- QuÃ© estÃ¡s intentando hacer
- Error completo (si hay)

Â¡Ã‰xito con la implementaciÃ³n! ğŸ’ª