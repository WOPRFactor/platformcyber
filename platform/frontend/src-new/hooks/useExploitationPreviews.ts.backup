/**
 * Hook para manejar previews de comandos de Exploitation
 * 
 * Centraliza toda la lógica de preview para evitar duplicación
 * y mantener el código organizado.
 */

import { useState, useRef } from 'react'
import { toast } from 'sonner'
import { commandPreviewAPI, CommandPreview } from '../lib/api/command-preview'
import { useWorkspace } from '../contexts/WorkspaceContext'

interface UseExploitationPreviewsReturn {
  showPreview: boolean
  previewData: CommandPreview | null
  previewToolName: string
  previewExecuteFn: (() => Promise<void>) | null
  setShowPreview: (show: boolean) => void
  setPreviewData: (data: CommandPreview | null) => void
  setPreviewToolName: (name: string) => void
  setPreviewExecuteFn: (fn: (() => Promise<void>) | null) => void
  // Handlers de preview
  handleJohnWithPreview: (params: {
    hashFile: string
    wordlist?: string
    format?: string
    rules: boolean
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleHashcatWithPreview: (params: {
    hashFile: string
    mode: number
    wordlist: string
    rulesFile?: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleKerbruteWithPreview: (params: {
    domain: string
    mode: string
    usersFile?: string
    passwordsFile?: string
    password?: string
    dcIp?: string
    originalPassword?: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleCrackMapExecWithPreview: (params: {
    targets: string
    protocol: string
    username?: string
    password?: string
    hash?: string
    domain?: string
    command?: string
    shares: boolean
    passPol: boolean
    originalPassword?: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleResponderWithPreview: (params: {
    interface: string
    lm: boolean
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleImpacketPsexecWithPreview: (params: {
    target: string
    username: string
    password: string
    domain?: string
    hash?: string
    command?: string
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleImpacketWmiexecWithPreview: (params: {
    target: string
    username: string
    password: string
    domain?: string
    hash?: string
    command?: string
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleImpacketSmbexecWithPreview: (params: {
    target: string
    username: string
    password: string
    domain?: string
    hash?: string
    command?: string
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleImpacketSecretsdumpWithPreview: (params: {
    target: string
    username: string
    password: string
    domain?: string
    hash?: string
    justDc: boolean
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleImpacketGetUserSPNsWithPreview: (params: {
    target: string
    username: string
    password: string
    domain: string
    hash?: string
    request: boolean
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleImpacketGetNPUsersWithPreview: (params: {
    target: string
    domain: string
    usersFile?: string
    noPass: boolean
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleEvilWinRMWithPreview: (params: {
    target: string
    username: string
    password: string
    hash?: string
    ssl: boolean
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleMsfvenomWithPreview: (params: {
    payloadType: string
    lhost: string
    lport: number
    format: string
    encoder?: string
    iterations: number
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleMetasploitHandlerWithPreview: (params: {
    payload: string
    lhost: string
    lport: number
    exitOnSession: boolean
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
  handleHydraWithPreview: (params: {
    target: string
    service: string
    username?: string
    userfile?: string
    password?: string
    passfile?: string
    port?: number
    threads: number
    originalPassword?: string
    onExecute: (params: any) => Promise<void>
  }) => Promise<void>
}

export const useExploitationPreviews = (): UseExploitationPreviewsReturn => {
  const { currentWorkspace } = useWorkspace()
  const [showPreview, setShowPreview] = useState(false)
  const [previewData, setPreviewData] = useState<CommandPreview | null>(null)
  const [previewToolName, setPreviewToolName] = useState('')
  const previewExecuteFnRef = useRef<(() => Promise<void>) | null>(null)
  
  // Mantener compatibilidad con la interfaz usando getter/setter
  const previewExecuteFn = previewExecuteFnRef.current
  const setPreviewExecuteFn = (fn: (() => Promise<void>) | null) => {
    previewExecuteFnRef.current = fn
  }

  // Helper genérico para manejar errores de preview
  const handlePreviewError = (error: any, toolName: string, fallbackFn: () => void) => {
    console.error(`Error obteniendo preview de ${toolName}:`, error)
    toast.error('Error al obtener preview del comando')
    // NO ejecutar el comando automáticamente - el usuario debe confirmar desde el preview
  }

  // Handlers de preview - cada uno sigue el mismo patrón
  const handleJohnWithPreview = async (params: {
    hashFile: string
    wordlist?: string
    format?: string
    rules: boolean
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.hashFile.trim() || !currentWorkspace?.id) {
      toast.error('Archivo de hashes y workspace son requeridos')
      return
    }

    try {
      const preview = await commandPreviewAPI.previewJohn({
        hash_file: params.hashFile,
        workspace_id: currentWorkspace.id,
        wordlist: params.wordlist,
        format: params.format,
        rules: params.rules
      })

      setPreviewData(preview)
      setPreviewToolName('John the Ripper')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          hash_file: preview.parameters.hash_file,
          workspace_id: currentWorkspace.id,
          wordlist: preview.parameters.wordlist,
          format: preview.parameters.format,
          rules: preview.parameters.rules
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'John', () => {
        params.onExecute({
          hash_file: params.hashFile,
          workspace_id: currentWorkspace!.id,
          wordlist: params.wordlist,
          format: params.format,
          rules: params.rules
        })
      })
    }
  }

  const handleHashcatWithPreview = async (params: {
    hashFile: string
    mode: number
    wordlist: string
    rulesFile?: string
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.hashFile.trim() || !params.wordlist.trim() || !currentWorkspace?.id) {
      toast.error('Archivo de hashes, wordlist y workspace son requeridos')
      return
    }

    try {
      const preview = await commandPreviewAPI.previewHashcat({
        hash_file: params.hashFile,
        workspace_id: currentWorkspace.id,
        mode: params.mode,
        wordlist: params.wordlist,
        rules_file: params.rulesFile
      })

      setPreviewData(preview)
      setPreviewToolName('Hashcat')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          hash_file: preview.parameters.hash_file,
          workspace_id: currentWorkspace.id,
          mode: preview.parameters.mode,
          wordlist: preview.parameters.wordlist,
          rules_file: preview.parameters.rules_file
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Hashcat', () => {
        params.onExecute({
          hash_file: params.hashFile,
          workspace_id: currentWorkspace!.id,
          mode: params.mode,
          wordlist: params.wordlist,
          rules_file: params.rulesFile
        })
      })
    }
  }

  const handleKerbruteWithPreview = async (params: {
    domain: string
    mode: string
    usersFile?: string
    passwordsFile?: string
    password?: string
    dcIp?: string
    originalPassword?: string
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.domain.trim() || !currentWorkspace?.id) {
      toast.error('Dominio y workspace son requeridos')
      return
    }

    try {
      const preview = await commandPreviewAPI.previewKerbrute({
        domain: params.domain,
        workspace_id: currentWorkspace.id,
        mode: params.mode,
        users_file: params.usersFile,
        passwords_file: params.passwordsFile,
        password: params.password,
        dc_ip: params.dcIp
      })

      setPreviewData(preview)
      setPreviewToolName(`Kerbrute ${params.mode}`)
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          domain: preview.parameters.domain,
          workspace_id: currentWorkspace.id,
          mode: preview.parameters.mode,
          users_file: preview.parameters.users_file,
          passwords_file: preview.parameters.passwords_file,
          password: preview.parameters.password === '***' ? params.originalPassword : preview.parameters.password,
          dc_ip: preview.parameters.dc_ip
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Kerbrute', () => {
        params.onExecute({
          domain: params.domain,
          workspace_id: currentWorkspace!.id,
          mode: params.mode,
          users_file: params.usersFile,
          passwords_file: params.passwordsFile,
          password: params.password,
          dc_ip: params.dcIp
        })
      })
    }
  }

  const handleCrackMapExecWithPreview = async (params: {
    targets: string
    protocol: string
    username?: string
    password?: string
    hash?: string
    domain?: string
    command?: string
    shares: boolean
    passPol: boolean
    originalPassword?: string
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.targets.trim() || !currentWorkspace?.id) {
      toast.error('Targets y workspace son requeridos')
      return
    }

    try {
      const preview = await commandPreviewAPI.previewCrackMapExec({
        targets: params.targets,
        protocol: params.protocol,
        workspace_id: currentWorkspace.id,
        username: params.username,
        password: params.password,
        hash: params.hash,
        domain: params.domain,
        command: params.command,
        shares: params.shares,
        pass_pol: params.passPol
      })

      setPreviewData(preview)
      setPreviewToolName(`CrackMapExec ${params.protocol}`)
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          targets: preview.parameters.targets,
          protocol: preview.parameters.protocol,
          workspace_id: currentWorkspace.id,
          username: preview.parameters.username,
          password: preview.parameters.password === '***' ? params.originalPassword : preview.parameters.password,
          hash: preview.parameters.hash,
          domain: preview.parameters.domain,
          command: preview.parameters.command,
          shares: preview.parameters.shares,
          pass_pol: preview.parameters.pass_pol
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'CrackMapExec', () => {
        params.onExecute({
          targets: params.targets,
          protocol: params.protocol,
          workspace_id: currentWorkspace!.id,
          username: params.username,
          password: params.password,
          hash: params.hash,
          domain: params.domain,
          command: params.command,
          shares: params.shares,
          pass_pol: params.passPol
        })
      })
    }
  }

  const handleResponderWithPreview = async (params: {
    interface: string
    lm: boolean
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.interface.trim() || !currentWorkspace?.id) {
      toast.error('Interface y workspace son requeridos')
      return
    }

    try {
      const preview = await commandPreviewAPI.previewResponder({
        interface: params.interface,
        workspace_id: currentWorkspace.id,
        lm: params.lm
      })

      setPreviewData(preview)
      setPreviewToolName('Responder')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          interface: preview.parameters.interface,
          workspace_id: currentWorkspace.id,
          lm: preview.parameters.lm
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Responder', () => {
        params.onExecute({
          interface: params.interface,
          workspace_id: currentWorkspace!.id,
          lm: params.lm
        })
      })
    }
  }

  // Helper genérico para handlers de Impacket (patrón similar)
  const createImpacketHandler = (toolName: string, previewFn: any) => async (params: {
    target: string
    username: string
    password: string
    domain?: string
    hash?: string
    command?: string
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.target.trim() || !params.username.trim() || !params.password.trim() || !currentWorkspace?.id) {
      toast.error('Target, username, password y workspace son requeridos')
      return
    }
    try {
      const preview = await previewFn({
        target: params.target,
        username: params.username,
        password: params.password,
        workspace_id: currentWorkspace.id,
        domain: params.domain,
        hash: params.hash,
        command: params.command
      })
      setPreviewData(preview)
      setPreviewToolName(toolName)
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          target: preview.parameters.target,
          username: preview.parameters.username,
          password: params.originalPassword,
          workspace_id: currentWorkspace.id,
          domain: preview.parameters.domain,
          hash: preview.parameters.hash,
          command: preview.parameters.command
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, toolName, () => {
        params.onExecute({
          target: params.target,
          username: params.username,
          password: params.password,
          workspace_id: currentWorkspace!.id,
          domain: params.domain,
          hash: params.hash,
          command: params.command
        })
      })
    }
  }

  const handleImpacketPsexecWithPreview = createImpacketHandler('Impacket psexec', commandPreviewAPI.previewImpacketPsexec)
  const handleImpacketWmiexecWithPreview = createImpacketHandler('Impacket wmiexec', commandPreviewAPI.previewImpacketWmiexec)
  const handleImpacketSmbexecWithPreview = createImpacketHandler('Impacket smbexec', commandPreviewAPI.previewImpacketSmbexec)

  const handleImpacketSecretsdumpWithPreview = async (params: {
    target: string
    username: string
    password: string
    domain?: string
    hash?: string
    justDc: boolean
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.target.trim() || !params.username.trim() || !params.password.trim() || !currentWorkspace?.id) {
      toast.error('Target, username, password y workspace son requeridos')
      return
    }
    try {
      const preview = await commandPreviewAPI.previewImpacketSecretsdump({
        target: params.target,
        username: params.username,
        password: params.password,
        workspace_id: currentWorkspace.id,
        domain: params.domain,
        hash: params.hash,
        just_dc: params.justDc
      })
      setPreviewData(preview)
      setPreviewToolName('Impacket secretsdump')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          target: preview.parameters.target,
          username: preview.parameters.username,
          password: params.originalPassword,
          workspace_id: currentWorkspace.id,
          domain: preview.parameters.domain,
          hash: preview.parameters.hash,
          just_dc: preview.parameters.just_dc
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Impacket secretsdump', () => {
        params.onExecute({
          target: params.target,
          username: params.username,
          password: params.password,
          workspace_id: currentWorkspace!.id,
          domain: params.domain,
          hash: params.hash,
          just_dc: params.justDc
        })
      })
    }
  }

  const handleImpacketGetUserSPNsWithPreview = async (params: {
    target: string
    username: string
    password: string
    domain: string
    hash?: string
    request: boolean
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.target.trim() || !params.username.trim() || !params.password.trim() || !params.domain.trim() || !currentWorkspace?.id) {
      toast.error('Target, username, password, domain y workspace son requeridos')
      return
    }
    try {
      const preview = await commandPreviewAPI.previewImpacketGetUserSPNs({
        target: params.target,
        username: params.username,
        password: params.password,
        domain: params.domain,
        workspace_id: currentWorkspace.id,
        hash: params.hash,
        request: params.request
      })
      setPreviewData(preview)
      setPreviewToolName('Impacket GetUserSPNs')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          target: preview.parameters.target,
          username: preview.parameters.username,
          password: params.originalPassword,
          domain: preview.parameters.domain,
          workspace_id: currentWorkspace.id,
          hash: preview.parameters.hash,
          request: preview.parameters.request
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Impacket GetUserSPNs', () => {
        params.onExecute({
          target: params.target,
          username: params.username,
          password: params.password,
          domain: params.domain,
          workspace_id: currentWorkspace!.id,
          hash: params.hash,
          request: params.request
        })
      })
    }
  }

  const handleImpacketGetNPUsersWithPreview = async (params: {
    target: string
    domain: string
    usersFile?: string
    noPass: boolean
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.target.trim() || !params.domain.trim() || !currentWorkspace?.id) {
      toast.error('Target, domain y workspace son requeridos')
      return
    }
    try {
      const preview = await commandPreviewAPI.previewImpacketGetNPUsers({
        target: params.target,
        domain: params.domain,
        workspace_id: currentWorkspace.id,
        users_file: params.usersFile,
        no_pass: params.noPass
      })
      setPreviewData(preview)
      setPreviewToolName('Impacket GetNPUsers')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          target: preview.parameters.target,
          domain: preview.parameters.domain,
          workspace_id: currentWorkspace.id,
          users_file: preview.parameters.users_file,
          no_pass: preview.parameters.no_pass
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Impacket GetNPUsers', () => {
        params.onExecute({
          target: params.target,
          domain: params.domain,
          workspace_id: currentWorkspace!.id,
          users_file: params.usersFile,
          no_pass: params.noPass
        })
      })
    }
  }

  const handleEvilWinRMWithPreview = async (params: {
    target: string
    username: string
    password: string
    hash?: string
    ssl: boolean
    originalPassword: string
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.target.trim() || !params.username.trim() || !params.password.trim() || !currentWorkspace?.id) {
      toast.error('Target, username, password y workspace son requeridos')
      return
    }
    try {
      const preview = await commandPreviewAPI.previewEvilWinRM({
        target: params.target,
        username: params.username,
        password: params.password,
        workspace_id: currentWorkspace.id,
        hash: params.hash,
        ssl: params.ssl
      })
      setPreviewData(preview)
      setPreviewToolName('Evil-WinRM')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          target: preview.parameters.target,
          username: preview.parameters.username,
          password: params.originalPassword,
          workspace_id: currentWorkspace.id,
          hash: preview.parameters.hash,
          ssl: preview.parameters.ssl
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Evil-WinRM', () => {
        params.onExecute({
          target: params.target,
          username: params.username,
          password: params.password,
          workspace_id: currentWorkspace!.id,
          hash: params.hash,
          ssl: params.ssl
        })
      })
    }
  }

  const handleMsfvenomWithPreview = async (params: {
    payloadType: string
    lhost: string
    lport: number
    format: string
    encoder?: string
    iterations: number
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.lhost.trim() || !params.lport || !currentWorkspace?.id) {
      toast.error('LHOST, LPORT y workspace son requeridos')
      return
    }
    try {
      const preview = await commandPreviewAPI.previewMsfvenom({
        payload_type: params.payloadType,
        lhost: params.lhost,
        lport: params.lport,
        workspace_id: currentWorkspace.id,
        format: params.format,
        encoder: params.encoder,
        iterations: params.iterations
      })
      setPreviewData(preview)
      setPreviewToolName('msfvenom')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          payload_type: preview.parameters.payload_type,
          lhost: preview.parameters.lhost,
          lport: preview.parameters.lport,
          workspace_id: currentWorkspace.id,
          format: preview.parameters.format,
          encoder: preview.parameters.encoder,
          iterations: preview.parameters.iterations
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'msfvenom', () => {
        params.onExecute({
          payload_type: params.payloadType,
          lhost: params.lhost,
          lport: params.lport,
          workspace_id: currentWorkspace!.id,
          format: params.format,
          encoder: params.encoder,
          iterations: params.iterations
        })
      })
    }
  }

  const handleMetasploitHandlerWithPreview = async (params: {
    payload: string
    lhost: string
    lport: number
    exitOnSession: boolean
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.lhost.trim() || !params.lport || !currentWorkspace?.id) {
      toast.error('LHOST, LPORT y workspace son requeridos')
      return
    }
    try {
      const preview = await commandPreviewAPI.previewMetasploitHandler({
        payload: params.payload,
        lhost: params.lhost,
        lport: params.lport,
        workspace_id: currentWorkspace.id,
        exit_on_session: params.exitOnSession
      })
      setPreviewData(preview)
      setPreviewToolName('Metasploit Handler')
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          payload: preview.parameters.payload,
          lhost: preview.parameters.lhost,
          lport: preview.parameters.lport,
          workspace_id: currentWorkspace.id,
          exit_on_session: preview.parameters.exit_on_session
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Metasploit Handler', () => {
        params.onExecute({
          payload: params.payload,
          lhost: params.lhost,
          lport: params.lport,
          workspace_id: currentWorkspace!.id,
          exit_on_session: params.exitOnSession
        })
      })
    }
  }

  const handleHydraWithPreview = async (params: {
    target: string
    service: string
    username?: string
    userfile?: string
    password?: string
    passfile?: string
    port?: number
    threads: number
    originalPassword?: string
    onExecute: (params: any) => Promise<void>
  }) => {
    if (!params.target.trim() || !currentWorkspace?.id) {
      toast.error('Target y workspace son requeridos')
      return
    }
    try {
      const preview = await commandPreviewAPI.previewHydra({
        target: params.target,
        service: params.service,
        workspace_id: currentWorkspace.id,
        username: params.username,
        userfile: params.userfile,
        password: params.password,
        passfile: params.passfile,
        port: params.port,
        threads: params.threads
      })
      setPreviewData(preview)
      setPreviewToolName(`Hydra ${params.service}`)
      previewExecuteFnRef.current = async () => {
        await params.onExecute({
          target: preview.parameters.target,
          service: preview.parameters.service,
          workspace_id: currentWorkspace.id,
          username: preview.parameters.username,
          userfile: preview.parameters.userfile,
          password: preview.parameters.password === '***' ? params.originalPassword : preview.parameters.password,
          passfile: preview.parameters.passfile,
          port: preview.parameters.port,
          threads: preview.parameters.threads
        })
      };
      setShowPreview(true)
    } catch (error: any) {
      handlePreviewError(error, 'Hydra', () => {
        params.onExecute({
          target: params.target,
          service: params.service,
          workspace_id: currentWorkspace!.id,
          username: params.username,
          userfile: params.userfile,
          password: params.password,
          passfile: params.passfile,
          port: params.port,
          threads: params.threads
        })
      })
    }
  }

  return {
    showPreview,
    previewData,
    previewToolName,
    previewExecuteFn,
    setShowPreview,
    setPreviewData,
    setPreviewToolName,
    setPreviewExecuteFn,
    handleJohnWithPreview,
    handleHashcatWithPreview,
    handleKerbruteWithPreview,
    handleCrackMapExecWithPreview,
    handleResponderWithPreview,
    handleImpacketPsexecWithPreview,
    handleImpacketWmiexecWithPreview,
    handleImpacketSmbexecWithPreview,
    handleImpacketSecretsdumpWithPreview,
    handleImpacketGetUserSPNsWithPreview,
    handleImpacketGetNPUsersWithPreview,
    handleEvilWinRMWithPreview,
    handleMsfvenomWithPreview,
    handleMetasploitHandlerWithPreview,
    handleHydraWithPreview
  }
}
