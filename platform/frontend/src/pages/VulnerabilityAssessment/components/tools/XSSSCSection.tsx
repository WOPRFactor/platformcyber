import React, { useState, useEffect } from 'react'
import { Bug, Loader2 } from 'lucide-react'
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { vulnerabilityAPI } from '../../../../lib/api/vulnerability'
import { useConsole } from '../../../../contexts/ConsoleContext'
import { toast } from 'sonner'
import { useCommandPreview } from '../../hooks/useCommandPreview'

interface XSSSCSectionProps {
  target: string
  workspaceId: number
  commandPreview: ReturnType<typeof useCommandPreview>
}

export const XSSSCSection: React.FC<XSSSCSectionProps> = ({ target, workspaceId, commandPreview }) => {
  const { startTask, addLog, updateTaskProgress, failTask } = useConsole()
  const queryClient = useQueryClient()
  const { openPreview } = commandPreview
  
  // Estados para XSS Scanner
  const [xssScanMode, setXssScanMode] = useState<'auto' | 'single' | 'compare'>('auto')
  const [xssEngine, setXssEngine] = useState<'auto' | 'xsstrike' | 'xsser' | 'zap' | 'nuclei'>('xsstrike')
  const [xssSelectedEngines, setXssSelectedEngines] = useState<string[]>(['xsstrike', 'xsser'])
  const [xssAvailableTools, setXssAvailableTools] = useState<{ xsstrike: boolean; xsser: boolean; zap: boolean; nuclei: boolean }>({
    xsstrike: true,
    xsser: true,
    zap: false,
    nuclei: true
  })
  
  // Opciones XSS
  const [xssOptions, setXssOptions] = useState({
    crawl: false,
    fuzzing: false,
    skip_dom: false,
    timeout: 300,
    timeout_per_tool: 300,
    global_timeout: 900,
    custom_headers: {} as Record<string, string>,
    custom_cookies: '',
    threads: 5,
    auto_mode: true,
    severity: ['low', 'medium', 'high', 'critical'] as string[]
  })

  // Query para verificar herramientas disponibles
  const { data: availableTools, error: availableToolsError } = useQuery({
    queryKey: ['xss-available-tools'],
    queryFn: vulnerabilityAPI.getXSSAvailableTools,
    staleTime: 30000,
    retry: 1,
    onError: (error) => {
      console.error('Error obteniendo herramientas disponibles:', error)
      setXssAvailableTools({
        xsstrike: true,
        xsser: true,
        zap: false,
        nuclei: true
      })
    }
  })

  useEffect(() => {
    if (availableTools) {
      console.log('✅ Herramientas disponibles recibidas:', availableTools)
      setXssAvailableTools(availableTools)
    } else if (availableToolsError) {
      console.warn('⚠️ Error obteniendo herramientas, usando valores por defecto:', availableToolsError)
      setXssAvailableTools({
        xsstrike: true,
        xsser: true,
        zap: false,
        nuclei: true
      })
    }
  }, [availableTools, availableToolsError])

  const xssMutation = useMutation({
    mutationFn: ({ 
      url, 
      workspaceId, 
      engine, 
      scanMode, 
      engines, 
      options 
    }: { 
      url: string
      workspaceId: number
      engine: string
      scanMode: string
      engines?: string[]
      options?: Record<string, any>
    }) => {
      if (!workspaceId) {
        throw new Error('Workspace no seleccionado')
      }
      return vulnerabilityAPI.startXSSScan(url, workspaceId, engine, scanMode, engines, options)
    },
    onMutate: (variables) => {
      const modeText = variables.scanMode === 'auto' ? 'AUTO' : variables.scanMode === 'compare' ? 'COMPARE' : variables.engine.toUpperCase()
      const taskId = startTask('Vulnerability Assessment', `XSS ${modeText} scan en ${variables.url}`)
      addLog('info', 'vulnerability', `Iniciando escaneo XSS (${modeText}) para ${variables.url}`, taskId, `xss-${modeText} ${variables.url}`)
      updateTaskProgress(taskId, 10, 'Iniciando escaneo XSS...')
      return { taskId }
    },
    onSuccess: (data, variables, context) => {
      const modeText = variables.scanMode === 'auto' ? 'AUTO' : variables.scanMode === 'compare' ? 'COMPARE' : variables.engine.toUpperCase()
      toast.success(`Escaneo XSS ${modeText} iniciado`)
      queryClient.invalidateQueries({ queryKey: ['vuln-sessions'] })
      if (context?.taskId) {
        updateTaskProgress(context.taskId, 25, 'Escaneo XSS enviado al backend')
        addLog('info', 'vulnerability', `Sesión iniciada: ${data.scan_id || 'desconocida'}`, context.taskId)
      }
    },
    onError: (error: any, variables, context) => {
      toast.error(`Error al iniciar escaneo XSS: ${error.message}`)
      if (context?.taskId) {
        failTask(context.taskId, error.message)
      }
    }
  })

  const handleXSSWithPreview = async () => {
    if (!target.trim() || !workspaceId) {
      toast.error('Target y workspace son requeridos')
      return
    }

    try {
      const url = target.startsWith('http') ? target : `https://${target}`
      
      const preview = await vulnerabilityAPI.previewXSSCommand(
        url,
        workspaceId,
        xssEngine,
        xssScanMode,
        xssScanMode === 'compare' ? xssSelectedEngines : undefined,
        xssOptions
      )

      openPreview(preview, 'XSS Vulnerability Scanner', async () => {
        await xssMutation.mutateAsync({
          url,
          workspaceId: workspaceId,
          engine: xssEngine,
          scanMode: xssScanMode,
          engines: xssScanMode === 'compare' ? xssSelectedEngines : undefined,
          options: xssOptions
        })
      })
    } catch (error: any) {
      console.error('Error obteniendo preview:', error)
      toast.error('Error al obtener preview del comando')
    }
  }

  return (
    <div className="mt-4">
      <div className="bg-gray-100 border border-gray-300 rounded-xl p-6">
        <div className="mb-4">
          <h3 className="text-lg font-bold text-gray-900 flex items-center gap-2">
            <Bug className="w-5 h-5" />
            XSSSC - Vulnerability Scanning
          </h3>
          <p className="text-gray-500">
            Escaneo multi-herramienta de vulnerabilidades Cross-Site Scripting (XSS)
          </p>
        </div>

        {/* Selector de Modo */}
        <div className="mb-6">
          <label className="text-sm font-semibold text-gray-600 mb-2 block">Modo de Escaneo</label>
          <div className="flex gap-4">
            <label className="flex items-center gap-2 cursor-pointer">
              <input
                type="radio"
                name="xss-mode"
                value="auto"
                checked={xssScanMode === 'auto'}
                onChange={(e) => {
                  setXssScanMode('auto')
                  setXssEngine('auto')
                }}
                className="text-gray-800"
              />
              <span className="text-gray-600">AUTO (Recommended)</span>
              <span className="text-xs text-gray-500">XSStrike → XSSer fallback</span>
            </label>
            <label className="flex items-center gap-2 cursor-pointer">
              <input
                type="radio"
                name="xss-mode"
                value="single"
                checked={xssScanMode === 'single'}
                onChange={(e) => {
                  setXssScanMode('single')
                  if (xssEngine === 'auto') {
                    setXssEngine('xsstrike')
                  }
                }}
                className="text-gray-800"
              />
              <span className="text-gray-600">SINGLE</span>
            </label>
            <label className="flex items-center gap-2 cursor-pointer">
              <input
                type="radio"
                name="xss-mode"
                value="compare"
                checked={xssScanMode === 'compare'}
                onChange={(e) => setXssScanMode('compare')}
                className="text-gray-800"
              />
              <span className="text-gray-600">COMPARE</span>
            </label>
          </div>
        </div>

        {/* Selector de Engine (solo para modo SINGLE) */}
        {xssScanMode === 'single' && (
          <div className="mb-6">
            <label className="text-sm font-semibold text-gray-600 mb-2 block">Herramienta</label>
            <select
              value={xssEngine === 'auto' ? 'xsstrike' : xssEngine}
              onChange={(e) => {
                const newEngine = e.target.value as 'xsstrike' | 'xsser' | 'zap' | 'nuclei'
                setXssEngine(newEngine)
              }}
              className="w-full bg-gray-50 border border-gray-200 rounded px-3 py-2 text-gray-600"
            >
              <option value="xsstrike" disabled={!xssAvailableTools.xsstrike}>
                XSStrike ⭐ (Recommended)
              </option>
              <option value="xsser" disabled={!xssAvailableTools.xsser}>
                XSSer (Fast & Reliable)
              </option>
              <option value="nuclei" disabled={!xssAvailableTools.nuclei}>
                Nuclei (Template-Based)
              </option>
              <option value="zap" disabled={!xssAvailableTools.zap}>
                OWASP ZAP (Professional Audit) {!xssAvailableTools.zap && '⚠️ Daemon required'}
              </option>
            </select>
            {xssEngine !== 'auto' && xssEngine && !xssAvailableTools[xssEngine as keyof typeof xssAvailableTools] && (
              <p className="text-xs text-yellow-400 mt-1">
                ⚠️ Esta herramienta no está disponible. Verificando disponibilidad...
              </p>
            )}
          </div>
        )}

        {/* Selector de Engines (solo para modo COMPARE) */}
        {xssScanMode === 'compare' && (
          <div className="mb-6">
            <label className="text-sm font-semibold text-gray-600 mb-2 block">Herramientas a Comparar</label>
            <div className="space-y-2">
              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={xssSelectedEngines.includes('xsstrike')}
                  onChange={(e) => {
                    if (e.target.checked) {
                      setXssSelectedEngines([...xssSelectedEngines, 'xsstrike'])
                    } else {
                      setXssSelectedEngines(xssSelectedEngines.filter(e => e !== 'xsstrike'))
                    }
                  }}
                  disabled={!xssAvailableTools.xsstrike}
                  className="text-gray-800"
                />
                <span className={!xssAvailableTools.xsstrike ? 'text-gray-500' : 'text-gray-600'}>
                  XSStrike ⭐ (Recommended)
                </span>
              </label>
              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={xssSelectedEngines.includes('xsser')}
                  onChange={(e) => {
                    if (e.target.checked) {
                      setXssSelectedEngines([...xssSelectedEngines, 'xsser'])
                    } else {
                      setXssSelectedEngines(xssSelectedEngines.filter(e => e !== 'xsser'))
                    }
                  }}
                  disabled={!xssAvailableTools.xsser}
                  className="text-gray-800"
                />
                <span className={!xssAvailableTools.xsser ? 'text-gray-500' : 'text-gray-600'}>
                  XSSer (Fast & Reliable)
                </span>
              </label>
              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={xssSelectedEngines.includes('nuclei')}
                  onChange={(e) => {
                    if (e.target.checked) {
                      setXssSelectedEngines([...xssSelectedEngines, 'nuclei'])
                    } else {
                      setXssSelectedEngines(xssSelectedEngines.filter(e => e !== 'nuclei'))
                    }
                  }}
                  disabled={!xssAvailableTools.nuclei}
                  className="text-gray-800"
                />
                <span className={!xssAvailableTools.nuclei ? 'text-gray-500' : 'text-gray-600'}>
                  Nuclei (Template-Based)
                </span>
              </label>
              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={xssSelectedEngines.includes('zap')}
                  onChange={(e) => {
                    if (e.target.checked) {
                      setXssSelectedEngines([...xssSelectedEngines, 'zap'])
                    } else {
                      setXssSelectedEngines(xssSelectedEngines.filter(e => e !== 'zap'))
                    }
                  }}
                  disabled={!xssAvailableTools.zap}
                  className="text-gray-800"
                />
                <span className={!xssAvailableTools.zap ? 'text-gray-500' : 'text-gray-600'}>
                  OWASP ZAP (Professional Audit) {!xssAvailableTools.zap && '⚠️ Daemon required'}
                </span>
              </label>
            </div>
            {xssSelectedEngines.length === 0 && (
              <p className="text-xs text-yellow-400 mt-2">
                ⚠️ Selecciona al menos una herramienta
              </p>
            )}
          </div>
        )}

        {/* Opciones Avanzadas */}
        <div className="mb-6 bg-gray-100 rounded-xl p-4 border border-gray-200">
          <h4 className="text-md font-semibold text-pink-400 mb-3">Opciones Avanzadas</h4>
          <div className="space-y-3">
            <div className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={xssOptions.crawl}
                onChange={(e) => setXssOptions({...xssOptions, crawl: e.target.checked})}
                className="text-gray-800"
              />
              <label className="text-sm text-gray-600">Enable Crawling (XSStrike)</label>
            </div>
            <div className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={xssOptions.fuzzing}
                onChange={(e) => setXssOptions({...xssOptions, fuzzing: e.target.checked})}
                className="text-gray-800"
              />
              <label className="text-sm text-gray-600">Enable Fuzzing (XSStrike)</label>
            </div>
            <div className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={xssOptions.skip_dom}
                onChange={(e) => setXssOptions({...xssOptions, skip_dom: e.target.checked})}
                className="text-gray-800"
              />
              <label className="text-sm text-gray-600">Skip DOM XSS (XSStrike)</label>
            </div>
            <div>
              <label className="text-sm text-gray-600">Timeout por Herramienta (segundos)</label>
              <input
                type="number"
                value={xssOptions.timeout_per_tool}
                onChange={(e) => setXssOptions({...xssOptions, timeout_per_tool: parseInt(e.target.value) || 300})}
                className="w-full bg-gray-50 border border-gray-200 rounded px-3 py-2 text-gray-600 mt-1"
                min="60"
                max="3600"
              />
            </div>
            {xssScanMode === 'compare' && (
              <div>
                <label className="text-sm text-gray-600">Timeout Global (segundos)</label>
                <input
                  type="number"
                  value={xssOptions.global_timeout}
                  onChange={(e) => setXssOptions({...xssOptions, global_timeout: parseInt(e.target.value) || 900})}
                  className="w-full bg-gray-50 border border-gray-200 rounded px-3 py-2 text-gray-600 mt-1"
                  min="300"
                  max="3600"
                />
              </div>
            )}
            <div>
              <label className="text-sm text-gray-600">Custom Headers (JSON, opcional)</label>
              <textarea
                value={JSON.stringify(xssOptions.custom_headers, null, 2)}
                onChange={(e) => {
                  try {
                    const headers = JSON.parse(e.target.value)
                    setXssOptions({...xssOptions, custom_headers: headers})
                  } catch {
                    // Ignore invalid JSON
                  }
                }}
                placeholder='{"Cookie": "session=xxx", "Authorization": "Bearer token"}'
                className="w-full bg-gray-50 border border-gray-200 rounded px-3 py-2 text-gray-600 mt-1 font-mono text-xs"
                rows={3}
              />
            </div>
            <div>
              <label className="text-sm text-gray-600">Custom Cookies (opcional)</label>
              <input
                type="text"
                value={xssOptions.custom_cookies}
                onChange={(e) => setXssOptions({...xssOptions, custom_cookies: e.target.value})}
                placeholder="session=xxx; token=yyy"
                className="w-full bg-gray-50 border border-gray-200 rounded px-3 py-2 text-gray-600 mt-1"
              />
            </div>
          </div>
        </div>

        {/* Información de herramientas */}
        <div className="mb-6 bg-gray-100 rounded-xl p-4 border border-gray-200">
          <h4 className="text-md font-semibold text-blue-400 mb-2">Información de Herramientas</h4>
          <div className="space-y-2 text-xs text-gray-500">
            <p><strong className="text-gray-900">XSStrike:</strong> Advanced XSS detection with intelligent fuzzing and WAF bypass. Velocidad: Media | Precisión: Muy Alta</p>
            <p><strong className="text-gray-900">XSSer:</strong> Fast and reliable XSS scanner. Velocidad: Rápida | Precisión: Alta</p>
            <p><strong className="text-gray-900">Nuclei:</strong> Template-based detection. Velocidad: Media | Precisión: Alta</p>
            <p><strong className="text-gray-900">ZAP:</strong> Comprehensive security scanner. Velocidad: Lenta | Precisión: Muy Alta (Requires daemon)</p>
          </div>
        </div>

        {/* Advertencia */}
        <div className="border border-yellow-500 bg-yellow-50 p-4 rounded-xl mb-4">
          <p className="text-yellow-800 text-sm">
            La URL debe incluir parámetros vulnerables. Ejemplo: https://example.com/page?param=value
          </p>
        </div>

        {/* Botón de ejecución */}
        <button
          onClick={handleXSSWithPreview}
          disabled={xssMutation.isPending || !target.trim() || (xssScanMode === 'compare' && xssSelectedEngines.length === 0)}
          className="w-full bg-pink-600 hover:bg-pink-700 disabled:bg-pink-800 disabled:cursor-not-allowed text-white px-4 py-2 rounded-xl flex items-center justify-center"
        >
          {xssMutation.isPending ? (
            <>
              <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              Ejecutando Escaneo XSS...
            </>
          ) : (
            <>
              <Bug className="w-4 h-4 mr-2" />
              Iniciar Escaneo XSS
            </>
          )}
        </button>
      </div>
    </div>
  )
}

