"""
System API Endpoints
====================

Endpoints para información del sistema y health checks.
"""

from flask import Blueprint, jsonify, request
from flask_jwt_extended import jwt_required
from datetime import datetime, timedelta, timezone
import logging
import os
import signal

from repositories import ScanRepository
from utils.workspace_logger import log_to_workspace
from models import Scan

logger = logging.getLogger(__name__)

# Importar psutil para métricas de red
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False
    logger.warning("psutil no disponible. Endpoints de red no funcionarán correctamente.")

system_bp = Blueprint('system', __name__)


@system_bp.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({
        'status': 'healthy',
        'version': '3.0.0',
        'environment': 'development',
        'timestamp': datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')
    }), 200


@system_bp.route('/info', methods=['GET'])
def system_info():
    """Información del sistema."""
    return jsonify({
        'name': 'Pentesting Platform',
        'version': '3.0.0',
        'api_version': 'v1',
        'environment': 'development',
        'features': [
            'reconnaissance',
            'scanning',
            'vulnerability_assessment',
            'exploitation',
            'post_exploitation',
            'active_directory',
            'cloud_pentesting',
            'api_testing',
            'reporting'
        ]
    }), 200


@system_bp.route('/metrics', methods=['GET', 'OPTIONS'], strict_slashes=False)
@system_bp.route('/metrics/', methods=['GET', 'OPTIONS'], strict_slashes=False)
def get_metrics():
    """
    Obtiene métricas del sistema en formato JSON.
    
    Endpoint REST para consumo del frontend y sistema de monitoreo.
    Para métricas Prometheus, usar /metrics directamente.
    
    Returns:
        Métricas del sistema: CPU, RAM, Disk en porcentajes y GB
    """
    # Manejar OPTIONS para CORS
    if request.method == 'OPTIONS':
        return jsonify({'message': 'OK'}), 200
    
    # Para GET, requerir autenticación
    from flask_jwt_extended import verify_jwt_in_request
    verify_jwt_in_request()
    
    try:
        scan_repo = ScanRepository()
        
        # Métricas de scans
        all_scans = Scan.query.all()
        running_scans = scan_repo.get_running_scans()
        completed_scans = [s for s in all_scans if s.status == 'completed']
        failed_scans = [s for s in all_scans if s.status == 'failed']
        pending_scans = [s for s in all_scans if s.status in ['pending', 'queued']]
        
        # Estadísticas de scans por tipo
        scans_by_type = {}
        scans_by_status = {
            'running': len(running_scans),
            'completed': len(completed_scans),
            'failed': len(failed_scans),
            'pending': len(pending_scans),
            'cancelled': len([s for s in all_scans if s.status == 'cancelled'])
        }
        
        for scan in all_scans:
            scan_type = scan.scan_type
            scans_by_type[scan_type] = scans_by_type.get(scan_type, 0) + 1
        
        # Métricas de sistema (si psutil está disponible)
        system_metrics = {}
        try:
            import psutil
            import platform
            
            # CPU
            cpu_percent = psutil.cpu_percent(interval=0.1)
            cpu_count = psutil.cpu_count()
            
            # Memoria
            memory = psutil.virtual_memory()
            memory_total_mb = memory.total / (1024 * 1024)
            memory_used_mb = memory.used / (1024 * 1024)
            memory_available_mb = memory.available / (1024 * 1024)
            memory_percent = memory.percent
            
            # Disco
            disk = psutil.disk_usage('/')
            disk_total_gb = disk.total / (1024 * 1024 * 1024)
            disk_used_gb = disk.used / (1024 * 1024 * 1024)
            disk_free_gb = disk.free / (1024 * 1024 * 1024)
            disk_percent = disk.percent
            
            system_metrics = {
                'cpu': {
                    'percent': round(cpu_percent, 2),
                    'count': cpu_count
                },
                'memory': {
                    'total_mb': round(memory_total_mb, 2),
                    'used_mb': round(memory_used_mb, 2),
                    'available_mb': round(memory_available_mb, 2),
                    'percent': round(memory_percent, 2)
                },
                'disk': {
                    'total_gb': round(disk_total_gb, 2),
                    'used_gb': round(disk_used_gb, 2),
                    'free_gb': round(disk_free_gb, 2),
                    'percent': round(disk_percent, 2)
                },
                'platform': platform.system(),
                'python_version': platform.python_version()
            }
        except ImportError:
            import platform
            logger.warning("psutil no disponible, métricas de sistema no incluidas")
            system_metrics = {
                'error': 'psutil no disponible',
                'platform': platform.system(),
                'python_version': platform.python_version()
            }
        except Exception as e:
            logger.error(f"Error obteniendo métricas de sistema: {e}")
            system_metrics = {'error': str(e)}
        
        # Calcular tiempo promedio de scans completados
        avg_duration = None
        if completed_scans:
            durations = []
            for scan in completed_scans:
                if scan.started_at and scan.completed_at:
                    duration = (scan.completed_at - scan.started_at).total_seconds()
                    durations.append(duration)
            if durations:
                avg_duration = sum(durations) / len(durations)
        
        return jsonify({
            'timestamp': datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z'),
            'scans': {
                'total': len(all_scans),
                'active': len(running_scans),
                'by_status': scans_by_status,
                'by_type': scans_by_type,
                'avg_duration_seconds': round(avg_duration, 2) if avg_duration else None
            },
            'system': system_metrics,
            'uptime_seconds': None  # TODO: Implementar si es necesario
        }), 200
        
    except Exception as e:
        logger.error(f"Error obteniendo métricas: {e}", exc_info=True)
        return jsonify({'error': 'Internal server error', 'message': str(e)}), 500


@system_bp.route('/running-scans', methods=['GET', 'OPTIONS'])
def get_running_scans():
    """
    Obtiene todos los scans en estado 'running'.
    
    Returns:
        Lista de scans con información detallada
    """
    # Flask-CORS maneja OPTIONS automáticamente
    if request.method == 'OPTIONS':
        return jsonify({'message': 'OK'}), 200
    
    # Para GET, requerir autenticación
    from flask_jwt_extended import verify_jwt_in_request
    verify_jwt_in_request()
    
    try:
        scan_repo = ScanRepository()
        running_scans = scan_repo.get_running_scans()
        
        scans_data = []
        for scan in running_scans:
            # Calcular tiempo transcurrido
            elapsed_time = None
            if scan.started_at:
                try:
                    # Asegurar que started_at sea timezone-aware
                    if scan.started_at.tzinfo is None:
                        # Si no tiene timezone, asumir UTC
                        from datetime import timezone as tz
                        started_at_aware = scan.started_at.replace(tzinfo=tz.utc)
                    else:
                        started_at_aware = scan.started_at
                    
                    elapsed = datetime.now(timezone.utc) - started_at_aware
                    elapsed_time = {
                        'hours': elapsed.total_seconds() / 3600,
                        'minutes': elapsed.total_seconds() / 60,
                        'seconds': elapsed.total_seconds()
                    }
                except Exception as e:
                    logger.warning(f"Error calculando elapsed_time para scan {scan.id}: {e}")
                    elapsed_time = None
            
            scans_data.append({
                'id': scan.id,
                'scan_type': scan.scan_type,
                'target': scan.target,
                'workspace_id': scan.workspace_id,
                'user_id': scan.user_id,
                'started_at': scan.started_at.isoformat() if scan.started_at else None,
                'progress': scan.progress,
                'options': scan.options,
                'elapsed_time': elapsed_time,
                'tool': scan.options.get('tool') if scan.options else None
            })
        
        return jsonify({
            'scans': scans_data,
            'total': len(scans_data)
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting running scans: {e}", exc_info=True)
        return jsonify({'error': 'Internal server error'}), 500


@system_bp.route('/scans/<int:scan_id>/cancel', methods=['POST'])
@jwt_required()
def cancel_scan(scan_id: int):
    """
    Cancela un scan en ejecución o pendiente.
    
    Args:
        scan_id: ID del scan a cancelar
    
    Returns:
        Confirmación de cancelación
    """
    try:
        scan_repo = ScanRepository()
        scan = scan_repo.find_by_id(scan_id)
        
        if not scan:
            return jsonify({'error': 'Scan not found'}), 404
        
        # Estados que pueden ser cancelados
        cancellable_states = ['running', 'pending', 'queued']
        
        # Si el scan ya está completado o falló, informar pero no cancelar
        if scan.status in ['completed', 'failed', 'cancelled']:
            return jsonify({
                'error': f'Scan cannot be cancelled (current status: {scan.status})',
                'scan_id': scan_id,
                'current_status': scan.status
            }), 400
        
        # Si no está en un estado cancelable, informar
        if scan.status not in cancellable_states:
            logger.warning(f"Attempted to cancel scan {scan_id} with unexpected status: {scan.status}")
            # Aún así, intentar cancelar si el usuario lo solicita
            # (puede ser útil para limpiar estados inconsistentes)
        
        # Intentar terminar proceso si hay PID guardado y el scan está corriendo
        process_terminated = False
        pid = scan.options.get('pid') if scan.options else None
        
        # Si no hay PID pero hay información del comando, intentar buscar el proceso
        if not pid and scan.status == 'running' and scan.options:
            tool = scan.options.get('tool', '')
            target = scan.target
            
            # Buscar proceso por comando
            try:
                import subprocess
                if 'dnsenum' in tool.lower():
                    # Buscar procesos de dnsenum con el target
                    result = subprocess.run(
                        ['pgrep', '-f', f'dnsenum.*{target}'],
                        capture_output=True,
                        text=True
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        pids = result.stdout.strip().split('\n')
                        if pids:
                            pid = int(pids[0])  # Tomar el primer PID encontrado
                            logger.info(f"Found process PID {pid} for scan {scan_id} by command search")
                            # Guardar el PID encontrado
                            scan_repo.update_options(scan, {'pid': pid})
                elif 'amass' in tool.lower():
                    result = subprocess.run(
                        ['pgrep', '-f', f'amass.*{target}'],
                        capture_output=True,
                        text=True
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        pids = result.stdout.strip().split('\n')
                        if pids:
                            pid = int(pids[0])
                            logger.info(f"Found process PID {pid} for scan {scan_id} by command search")
                            scan_repo.update_options(scan, {'pid': pid})
            except Exception as e:
                logger.warning(f"Error searching for process by command: {e}")
        
        if pid and scan.status == 'running':
            try:
                # Verificar que el proceso existe
                os.kill(pid, 0)  # No termina, solo verifica existencia
                
                # Terminar el proceso principal
                try:
                    os.kill(pid, signal.SIGTERM)
                    logger.info(f"Sent SIGTERM to process {pid} for scan {scan_id}")
                    
                    # Esperar un momento para que termine gracefully
                    import time
                    time.sleep(2)
                    
                    # Verificar si el proceso aún existe
                    try:
                        os.kill(pid, 0)
                        # Si aún existe, forzar terminación
                        logger.warning(f"Process {pid} still running, sending SIGKILL")
                        os.kill(pid, signal.SIGKILL)
                    except ProcessLookupError:
                        # Proceso terminó correctamente
                        pass
                    
                    # Intentar terminar procesos hijos (para herramientas como dnsenum que crean procesos hijos)
                    try:
                        import psutil
                        parent = psutil.Process(pid)
                        children = parent.children(recursive=True)
                        for child in children:
                            try:
                                child.terminate()
                                logger.info(f"Terminated child process {child.pid} of scan {scan_id}")
                            except psutil.NoSuchProcess:
                                pass
                        # Esperar a que los hijos terminen
                        gone, alive = psutil.wait_procs(children, timeout=3)
                        for child in alive:
                            child.kill()
                            logger.warning(f"Killed child process {child.pid} of scan {scan_id}")
                    except (psutil.NoSuchProcess, ImportError):
                        # psutil no disponible o proceso ya no existe, continuar
                        pass
                    
                    process_terminated = True
                    logger.info(f"Terminated process {pid} and children for scan {scan_id}")
                except ProcessLookupError:
                    logger.warning(f"Process {pid} not found for scan {scan_id} (may have already terminated)")
                    process_terminated = True  # Considerar como terminado si ya no existe
            except ProcessLookupError:
                logger.warning(f"Process {pid} not found for scan {scan_id}")
            except PermissionError:
                logger.warning(f"Permission denied to terminate process {pid} for scan {scan_id}")
            except Exception as e:
                logger.error(f"Error terminating process {pid}: {e}", exc_info=True)
        
        # Marcar scan como cancelled
        scan_repo.update_status(scan, 'cancelled', 'Cancelled by user')
        
        # Log al workspace
        log_to_workspace(
            workspace_id=scan.workspace_id,
            source='SYSTEM',
            level='WARNING',
            message=f"Scan {scan_id} ({scan.scan_type}) cancelado por el usuario",
            metadata={
                'scan_id': scan_id,
                'scan_type': scan.scan_type,
                'target': scan.target,
                'process_terminated': process_terminated,
                'pid': pid,
                'previous_status': scan.status
            }
        )
        
        return jsonify({
            'message': 'Scan cancelled successfully',
            'scan_id': scan_id,
            'process_terminated': process_terminated,
            'previous_status': scan.status
        }), 200
        
    except Exception as e:
        logger.error(f"Error cancelling scan {scan_id}: {e}", exc_info=True)
        return jsonify({'error': 'Internal server error', 'message': str(e)}), 500


@system_bp.route('/scans/cancel-all', methods=['POST'])
@jwt_required()
def cancel_all_scans():
    """
    Cancela todos los scans en ejecución o pendientes.
    
    Returns:
        Resumen de cancelaciones realizadas
    """
    try:
        scan_repo = ScanRepository()
        running_scans = scan_repo.get_running_scans()
        
        if not running_scans:
            return jsonify({
                'message': 'No running scans to cancel',
                'cancelled': 0,
                'failed': 0,
                'total': 0
            }), 200
        
        cancelled_count = 0
        failed_count = 0
        cancelled_ids = []
        failed_ids = []
        
        for scan in running_scans:
            try:
                # Estados que pueden ser cancelados
                cancellable_states = ['running', 'pending', 'queued']
                
                # Si el scan ya está completado o falló, saltarlo
                if scan.status in ['completed', 'failed', 'cancelled']:
                    continue
                
                # Intentar terminar proceso si hay PID guardado
                process_terminated = False
                pid = scan.options.get('pid') if scan.options else None
                
                # Si no hay PID pero hay información del comando, intentar buscar el proceso
                if not pid and scan.status == 'running' and scan.options:
                    tool = scan.options.get('tool', '')
                    target = scan.target
                    
                    # Buscar proceso por comando
                    try:
                        import subprocess
                        if 'dnsenum' in tool.lower():
                            result = subprocess.run(
                                ['pgrep', '-f', f'dnsenum.*{target}'],
                                capture_output=True,
                                text=True
                            )
                            if result.returncode == 0 and result.stdout.strip():
                                pids = result.stdout.strip().split('\n')
                                if pids:
                                    pid = int(pids[0])
                                    scan_repo.update_options(scan, {'pid': pid})
                        elif 'amass' in tool.lower():
                            result = subprocess.run(
                                ['pgrep', '-f', f'amass.*{target}'],
                                capture_output=True,
                                text=True
                            )
                            if result.returncode == 0 and result.stdout.strip():
                                pids = result.stdout.strip().split('\n')
                                if pids:
                                    pid = int(pids[0])
                                    scan_repo.update_options(scan, {'pid': pid})
                    except Exception as e:
                        logger.warning(f"Error searching for process by command for scan {scan.id}: {e}")
                
                # Terminar proceso si existe
                if pid and scan.status == 'running':
                    try:
                        # Verificar que el proceso existe
                        os.kill(pid, 0)  # No termina, solo verifica existencia
                        
                        # Terminar el proceso principal
                        try:
                            os.kill(pid, signal.SIGTERM)
                            logger.info(f"Sent SIGTERM to process {pid} for scan {scan.id}")
                            
                            # Esperar un momento para que termine gracefully
                            import time
                            time.sleep(1)  # Reducido para cancelación masiva
                            
                            # Verificar si el proceso aún existe
                            try:
                                os.kill(pid, 0)
                                # Si aún existe, forzar terminación
                                logger.warning(f"Process {pid} still running, sending SIGKILL")
                                os.kill(pid, signal.SIGKILL)
                            except ProcessLookupError:
                                # Proceso terminó correctamente
                                pass
                            
                            # Intentar terminar procesos hijos
                            try:
                                import psutil
                                parent = psutil.Process(pid)
                                children = parent.children(recursive=True)
                                for child in children:
                                    try:
                                        child.terminate()
                                    except psutil.NoSuchProcess:
                                        pass
                                # Esperar a que los hijos terminen
                                gone, alive = psutil.wait_procs(children, timeout=2)
                                for child in alive:
                                    child.kill()
                            except (psutil.NoSuchProcess, ImportError):
                                pass
                            
                            process_terminated = True
                        except ProcessLookupError:
                            logger.warning(f"Process {pid} not found for scan {scan.id}")
                            process_terminated = True
                    except ProcessLookupError:
                        logger.warning(f"Process {pid} not found for scan {scan.id}")
                    except PermissionError:
                        logger.warning(f"Permission denied to terminate process {pid} for scan {scan.id}")
                    except Exception as e:
                        logger.error(f"Error terminating process {pid} for scan {scan.id}: {e}")
                
                # Marcar scan como cancelled
                scan_repo.update_status(scan, 'cancelled', 'Cancelled by user (cancel all)')
                
                # Log al workspace
                log_to_workspace(
                    workspace_id=scan.workspace_id,
                    source='SYSTEM',
                    level='WARNING',
                    message=f"Scan {scan.id} ({scan.scan_type}) cancelado (cancelación masiva)",
                    metadata={
                        'scan_id': scan.id,
                        'scan_type': scan.scan_type,
                        'target': scan.target,
                        'process_terminated': process_terminated,
                        'pid': pid,
                        'previous_status': scan.status
                    }
                )
                
                cancelled_count += 1
                cancelled_ids.append(scan.id)
                
            except Exception as e:
                logger.error(f"Error cancelling scan {scan.id}: {e}", exc_info=True)
                failed_count += 1
                failed_ids.append(scan.id)
        
        return jsonify({
            'message': f'Cancelled {cancelled_count} scan(s)',
            'cancelled': cancelled_count,
            'failed': failed_count,
            'total': len(running_scans),
            'cancelled_ids': cancelled_ids,
            'failed_ids': failed_ids
        }), 200
        
    except Exception as e:
        logger.error(f"Error cancelling all scans: {e}", exc_info=True)
        return jsonify({'error': 'Internal server error', 'message': str(e)}), 500


@system_bp.route('/console/execute', methods=['POST'])
@jwt_required()
def execute_console_command():
    """
    Ejecuta un comando de forma segura en el servidor.
    
    Body:
        {
            "command": "nmap -sV -p 80 example.com"
        }
    
    Returns:
        {
            "success": true,
            "output": "...",
            "returncode": 0,
            "error": null
        }
    """
    try:
        data = request.get_json()
        command_str = data.get('command', '').strip()
        
        if not command_str:
            return jsonify({'error': 'Command is required'}), 400
        
        # Parsear comando de forma segura
        from utils.validators.command_sanitizer import CommandSanitizer
        import shlex
        
        try:
            # Parsear comando en partes
            parts = shlex.split(command_str)
            if not parts:
                return jsonify({'error': 'Invalid command'}), 400
            
            command_base = parts[0]
            args = parts[1:] if len(parts) > 1 else []
            
            # Sanitizar comando
            safe_command = CommandSanitizer.sanitize_command(command_base, args, allow_unsafe=False)
            
        except ValueError as e:
            logger.warning(f"Command sanitization failed: {e}")
            return jsonify({'error': f'Command not allowed: {str(e)}'}), 400
        except Exception as e:
            logger.error(f"Error parsing command: {e}")
            return jsonify({'error': 'Invalid command format'}), 400
        
        # Ejecutar comando
        import subprocess
        import os
        
        try:
            result = subprocess.run(
                safe_command,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minutos máximo
                env=CommandSanitizer.get_safe_env(),
                cwd=os.getcwd()
            )
            
            return jsonify({
                'success': True,
                'output': result.stdout,
                'error': result.stderr if result.stderr else None,
                'returncode': result.returncode,
                'command': ' '.join(safe_command)
            }), 200
            
        except subprocess.TimeoutExpired:
            return jsonify({
                'success': False,
                'error': 'Command timeout (5 minutes)',
                'returncode': -1
            }), 408
        except Exception as e:
            logger.error(f"Error executing command: {e}")
            return jsonify({
                'success': False,
                'error': str(e),
                'returncode': -1
            }), 500
            
    except Exception as e:
        logger.error(f"Error in execute_console_command: {e}", exc_info=True)
        return jsonify({'error': 'Internal server error', 'message': str(e)}), 500


# ============================================
# NETWORK MONITORING - Endpoints
# ============================================

@system_bp.route('/network/metrics/', methods=['GET'], strict_slashes=False)
@system_bp.route('/network/metrics', methods=['GET'], strict_slashes=False)
@jwt_required()
def get_network_metrics():
    """
    Obtiene métricas agregadas de red del sistema.
    
    Incluye:
    - Estadísticas de todas las interfaces de red
    - Conexiones de red activas
    - Totales agregados de bytes y paquetes
    - Número de conexiones establecidas
    
    Returns:
        JSON con métricas de red en formato especificado por el equipo de monitoreo
    
    Seguridad:
        - Requiere autenticación JWT
        - Manejo seguro de errores sin exponer información sensible
    """
    if not PSUTIL_AVAILABLE:
        return jsonify({
            'error': 'psutil no disponible',
            'message': 'La librería psutil no está instalada. Instalar con: pip install psutil>=5.9.0'
        }), 503
    
    try:
        # Obtener estadísticas de interfaces de red
        interfaces = []
        total_bytes_sent = 0
        total_bytes_recv = 0
        total_packets_sent = 0
        total_packets_recv = 0
        
        try:
            net_io = psutil.net_io_counters(pernic=True)
            net_if_stats = psutil.net_if_stats()
        except Exception as e:
            logger.error(f"Error obteniendo estadísticas de interfaces: {e}")
            return jsonify({
                'error': 'Error obteniendo estadísticas de red',
                'message': str(e)
            }), 500
        
        for interface_name, stats in net_io.items():
            if_stats = net_if_stats.get(interface_name, {})
            
            interface_data = {
                "name": interface_name,
                "bytes_sent": stats.bytes_sent,
                "bytes_recv": stats.bytes_recv,
                "packets_sent": stats.packets_sent,
                "packets_recv": stats.packets_recv,
                "errin": stats.errin,
                "errout": stats.errout,
                "dropin": stats.dropin,
                "dropout": stats.dropout,
                "is_up": if_stats.get("isup", False) if if_stats else False
            }
            
            interfaces.append(interface_data)
            
            # Acumular totales
            total_bytes_sent += stats.bytes_sent
            total_bytes_recv += stats.bytes_recv
            total_packets_sent += stats.packets_sent
            total_packets_recv += stats.packets_recv
        
        # Obtener conexiones activas de red
        connections = []
        active_connections = 0
        
        try:
            # Obtener conexiones de tipo 'inet' (IPv4 e IPv6)
            # Nota: net_connections() puede requerir permisos elevados en algunos sistemas
            net_connections_list = psutil.net_connections(kind='inet')
        except (psutil.AccessDenied, PermissionError) as e:
            logger.warning(f"Permisos insuficientes para obtener conexiones de red: {e}")
            # Continuar sin conexiones, pero informar en la respuesta
            net_connections_list = []
        except Exception as e:
            logger.error(f"Error obteniendo conexiones de red: {e}")
            net_connections_list = []
        
        for conn in net_connections_list:
            try:
                # Manejar family y type de forma segura (pueden ser enums o ints)
                try:
                    if conn.family:
                        family_val = conn.family.value if hasattr(conn.family, 'value') else int(conn.family)
                    else:
                        family_val = 0
                except (AttributeError, TypeError, ValueError) as e:
                    logger.debug(f"Error obteniendo family de conexión: {e}")
                    family_val = 0
                
                try:
                    if conn.type:
                        type_val = conn.type.value if hasattr(conn.type, 'value') else int(conn.type)
                    else:
                        type_val = 0
                except (AttributeError, TypeError, ValueError) as e:
                    logger.debug(f"Error obteniendo type de conexión: {e}")
                    type_val = 0
                
                connection_data = {
                    "fd": conn.fd if conn.fd else -1,
                    "family": family_val,
                    "type": type_val,
                    "laddr": {
                        "ip": str(conn.laddr.ip) if conn.laddr else "0.0.0.0",
                        "port": int(conn.laddr.port) if conn.laddr else 0
                    },
                    "status": str(conn.status) if conn.status else "UNKNOWN",
                    "pid": int(conn.pid) if conn.pid else None
                }
                
                # Agregar dirección remota si existe
                if conn.raddr:
                    try:
                        connection_data["raddr"] = {
                            "ip": str(conn.raddr.ip),
                            "port": int(conn.raddr.port)
                        }
                    except (AttributeError, ValueError) as e:
                        logger.debug(f"Error obteniendo raddr de conexión: {e}")
                        connection_data["raddr"] = None
                else:
                    connection_data["raddr"] = None
                
                connections.append(connection_data)
                
                # Contar conexiones establecidas
                if conn.status and str(conn.status) == "ESTABLISHED":
                    active_connections += 1
                    
            except Exception as e:
                logger.warning(f"Error procesando conexión: {e}", exc_info=True)
                continue
        
        # Generar timestamp ISO 8601 (usando timezone-aware para evitar deprecation)
        timestamp = datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')
        
        return jsonify({
            "interfaces": interfaces,
            "connections": connections,
            "total_bytes_sent": total_bytes_sent,
            "total_bytes_recv": total_bytes_recv,
            "total_packets_sent": total_packets_sent,
            "total_packets_recv": total_packets_recv,
            "active_connections": active_connections,
            "timestamp": timestamp
        }), 200
        
    except Exception as e:
        logger.error(f"Error obteniendo métricas de red: {e}", exc_info=True)
        return jsonify({
            "error": "Error interno del servidor",
            "message": str(e)
        }), 500


@system_bp.route('/network/interfaces/', methods=['GET'], strict_slashes=False)
@system_bp.route('/network/interfaces', methods=['GET'], strict_slashes=False)
@jwt_required()
def get_network_interfaces():
    """
    Obtiene solo la lista de interfaces de red con sus estadísticas.
    
    Endpoint opcional para casos donde solo se necesitan interfaces.
    
    Returns:
        JSON con array de interfaces de red
    """
    if not PSUTIL_AVAILABLE:
        return jsonify({
            'error': 'psutil no disponible',
            'message': 'La librería psutil no está instalada. Instalar con: pip install psutil>=5.9.0'
        }), 503
    
    try:
        interfaces = []
        
        try:
            net_io = psutil.net_io_counters(pernic=True)
            net_if_stats = psutil.net_if_stats()
        except Exception as e:
            logger.error(f"Error obteniendo estadísticas de interfaces: {e}")
            return jsonify({
                'error': 'Error obteniendo interfaces de red',
                'message': str(e)
            }), 500
        
        for interface_name, stats in net_io.items():
            if_stats = net_if_stats.get(interface_name, {})
            
            interfaces.append({
                "name": interface_name,
                "bytes_sent": stats.bytes_sent,
                "bytes_recv": stats.bytes_recv,
                "packets_sent": stats.packets_sent,
                "packets_recv": stats.packets_recv,
                "errin": stats.errin,
                "errout": stats.errout,
                "dropin": stats.dropin,
                "dropout": stats.dropout,
                "is_up": if_stats.get("isup", False) if if_stats else False
            })
        
        return jsonify({
            "interfaces": interfaces,
            "count": len(interfaces),
            "timestamp": datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')
        }), 200
        
    except Exception as e:
        logger.error(f"Error obteniendo interfaces de red: {e}", exc_info=True)
        return jsonify({
            "error": "Error interno del servidor",
            "message": str(e)
        }), 500


@system_bp.route('/network/connections/', methods=['GET'], strict_slashes=False)
@system_bp.route('/network/connections', methods=['GET'], strict_slashes=False)
@jwt_required()
def get_network_connections():
    """
    Obtiene solo la lista de conexiones de red activas.
    
    Endpoint opcional para casos donde solo se necesitan conexiones.
    
    Returns:
        JSON con array de conexiones de red
    """
    if not PSUTIL_AVAILABLE:
        return jsonify({
            'error': 'psutil no disponible',
            'message': 'La librería psutil no está instalada. Instalar con: pip install psutil>=5.9.0'
        }), 503
    
    try:
        connections = []
        active_connections = 0
        
        try:
            net_connections_list = psutil.net_connections(kind='inet')
        except (psutil.AccessDenied, PermissionError) as e:
            logger.warning(f"Permisos insuficientes para obtener conexiones de red: {e}")
            return jsonify({
                "connections": [],
                "count": 0,
                "active_connections": 0,
                "warning": "Permisos insuficientes para obtener conexiones de red",
                "timestamp": datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')
            }), 200
        except Exception as e:
            logger.error(f"Error obteniendo conexiones de red: {e}")
            return jsonify({
                "error": "Error obteniendo conexiones de red",
                "message": str(e)
            }), 500
        
        for conn in net_connections_list:
            try:
                connection_data = {
                    "fd": conn.fd if conn.fd else -1,
                    "family": conn.family.value if conn.family else 0,
                    "type": conn.type.value if conn.type else 0,
                    "laddr": {
                        "ip": conn.laddr.ip if conn.laddr else "0.0.0.0",
                        "port": conn.laddr.port if conn.laddr else 0
                    },
                    "status": conn.status if conn.status else "UNKNOWN",
                    "pid": conn.pid if conn.pid else None
                }
                
                if conn.raddr:
                    connection_data["raddr"] = {
                        "ip": conn.raddr.ip,
                        "port": conn.raddr.port
                    }
                else:
                    connection_data["raddr"] = None
                
                connections.append(connection_data)
                
                if conn.status == "ESTABLISHED":
                    active_connections += 1
                    
            except Exception as e:
                logger.warning(f"Error procesando conexión: {e}")
                continue
        
        return jsonify({
            "connections": connections,
            "count": len(connections),
            "active_connections": active_connections,
            "timestamp": datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')
        }), 200
        
    except Exception as e:
        logger.error(f"Error obteniendo conexiones de red: {e}", exc_info=True)
        return jsonify({
            "error": "Error interno del servidor",
            "message": str(e)
        }), 500

