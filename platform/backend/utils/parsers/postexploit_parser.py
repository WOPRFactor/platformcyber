"""
Post-Exploitation Parsers
==========================

Parsers para herramientas de post-explotación.
"""

import json
import re
from typing import Dict, List, Any, Optional


class LinPEASParser:
    """Parser para resultados de LinPEAS."""
    
    @staticmethod
    def parse_output(output: str) -> Dict[str, Any]:
        """Parsea salida de LinPEAS."""
        findings = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': [],
            'info': []
        }
        
        # Extraer findings por severidad (LinPEAS usa colores)
        # [!] = Critical, [+] = Important, [*] = Info
        
        for line in output.split('\n'):
            if '[!]' in line or 'CRITICAL' in line.upper():
                findings['critical'].append(line.strip())
            elif '[+]' in line or 'HIGH' in line.upper():
                findings['high'].append(line.strip())
            elif '[*]' in line:
                findings['info'].append(line.strip())
        
        # Extraer información específica
        users = []
        sudo_users = []
        suid_binaries = []
        writable_dirs = []
        
        # Usuarios con shell
        user_matches = re.findall(r'uid=(\d+)\((\w+)\)', output)
        for uid, username in user_matches:
            users.append({'uid': uid, 'username': username})
        
        # SUID binaries
        suid_matches = re.findall(r'-rws.+?\s+(/[\w/]+)', output)
        suid_binaries = list(set(suid_matches))
        
        return {
            'tool': 'linpeas',
            'findings_by_severity': {
                'critical': len(findings['critical']),
                'high': len(findings['high']),
                'medium': len(findings['medium']),
                'low': len(findings['low']),
                'info': len(findings['info'])
            },
            'findings': findings,
            'users': users[:20],  # Primeros 20
            'suid_binaries': suid_binaries[:50],  # Primeros 50
            'total_findings': sum(len(v) for v in findings.values())
        }


class WinPEASParser:
    """Parser para resultados de WinPEAS."""
    
    @staticmethod
    def parse_output(output: str) -> Dict[str, Any]:
        """Parsea salida de WinPEAS."""
        findings = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
        
        # WinPEAS también usa [!], [+], [*]
        for line in output.split('\n'):
            if '[!]' in line or 'CRITICAL' in line.upper():
                findings['critical'].append(line.strip())
            elif '[+]' in line or 'HIGH' in line.upper():
                findings['high'].append(line.strip())
            elif '[*]' in line:
                findings['medium'].append(line.strip())
        
        # Extraer información de servicios
        services = []
        service_matches = re.findall(
            r'Service Name:\s+(\S+).*?Path:\s+(.+)',
            output,
            re.DOTALL
        )
        for name, path in service_matches[:50]:
            services.append({'name': name, 'path': path.strip()})
        
        # Extraer privilegios
        privileges = []
        priv_matches = re.findall(r'SeImpersonatePrivilege|SeDebugPrivilege|SeBackupPrivilege', output)
        privileges = list(set(priv_matches))
        
        return {
            'tool': 'winpeas',
            'findings_by_severity': {
                'critical': len(findings['critical']),
                'high': len(findings['high']),
                'medium': len(findings['medium']),
                'low': len(findings['low'])
            },
            'findings': findings,
            'services': services,
            'privileges': privileges,
            'total_findings': sum(len(v) for v in findings.values())
        }


class BloodHoundParser:
    """Parser para datos de BloodHound."""
    
    @staticmethod
    def parse_json(json_path: str) -> Dict[str, Any]:
        """Parsea JSON de BloodHound."""
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
            
            # BloodHound puede generar múltiples archivos
            computers = data.get('computers', [])
            users = data.get('users', [])
            groups = data.get('groups', [])
            domains = data.get('domains', [])
            
            # Análisis de paths críticos
            admin_paths = []
            for user in users:
                if user.get('Properties', {}).get('admincount', False):
                    admin_paths.append(user.get('Properties', {}).get('name'))
            
            return {
                'tool': 'bloodhound',
                'computers': len(computers),
                'users': len(users),
                'groups': len(groups),
                'domains': len(domains),
                'admin_users': len(admin_paths),
                'admin_paths': admin_paths[:20],
                'data': {
                    'computers': computers[:10],
                    'users': users[:10],
                    'groups': groups[:10]
                }
            }
        except Exception as e:
            return {
                'tool': 'bloodhound',
                'error': str(e)
            }


class MimikatzParser:
    """Parser para resultados de Mimikatz."""
    
    @staticmethod
    def parse_output(output: str) -> Dict[str, Any]:
        """Parsea salida de Mimikatz."""
        credentials = []
        tickets = []
        
        # Extraer credenciales (sekurlsa::logonpasswords)
        cred_blocks = re.split(r'Authentication Id.*?:', output)
        
        for block in cred_blocks[1:]:  # Skip first empty
            username_match = re.search(r'User Name\s+:\s+(\S+)', block)
            domain_match = re.search(r'Domain\s+:\s+(\S+)', block)
            ntlm_match = re.search(r'NTLM\s+:\s+([a-f0-9]{32})', block, re.IGNORECASE)
            password_match = re.search(r'Password\s+:\s+(.+)', block)
            
            if username_match:
                cred = {
                    'username': username_match.group(1),
                    'domain': domain_match.group(1) if domain_match else None,
                    'ntlm': ntlm_match.group(1) if ntlm_match else None,
                    'password': password_match.group(1).strip() if password_match else None
                }
                
                # Filtrar credenciales vacías
                if cred['ntlm'] or cred['password']:
                    credentials.append(cred)
        
        # Extraer tickets Kerberos (sekurlsa::tickets)
        ticket_matches = re.findall(
            r'\[(\d+)\]\s+.*?Client:\s+(\S+)\s+@\s+(\S+)',
            output
        )
        
        for ticket_id, client, domain in ticket_matches:
            tickets.append({
                'id': ticket_id,
                'client': client,
                'domain': domain
            })
        
        return {
            'tool': 'mimikatz',
            'credentials_found': len(credentials),
            'tickets_found': len(tickets),
            'credentials': credentials,
            'tickets': tickets[:20]  # Primeros 20
        }


class PowerViewParser:
    """Parser para resultados de PowerView."""
    
    @staticmethod
    def parse_output(output: str) -> Dict[str, Any]:
        """Parsea salida de PowerView."""
        users = []
        computers = []
        groups = []
        gpos = []
        
        # PowerView output es PowerShell objects
        # Intentar extraer información básica
        
        # Usuarios
        user_matches = re.findall(
            r'samaccountname\s+:\s+(\S+)',
            output,
            re.IGNORECASE
        )
        users = list(set(user_matches))
        
        # Computadoras
        computer_matches = re.findall(
            r'dnshostname\s+:\s+(\S+)',
            output,
            re.IGNORECASE
        )
        computers = list(set(computer_matches))
        
        # Grupos
        group_matches = re.findall(
            r'name\s+:\s+(.*?)(?:\r?\n)',
            output,
            re.IGNORECASE
        )
        groups = list(set(group_matches))
        
        return {
            'tool': 'powerview',
            'users': users[:50],
            'computers': computers[:50],
            'groups': groups[:50],
            'total_users': len(users),
            'total_computers': len(computers),
            'total_groups': len(groups)
        }


class SeatbeltParser:
    """Parser para resultados de Seatbelt."""
    
    @staticmethod
    def parse_output(output: str) -> Dict[str, Any]:
        """Parsea salida de Seatbelt."""
        findings = {}
        
        # Seatbelt organiza output por secciones
        sections = re.split(r'====\s+(\w+)\s+====', output)
        
        for i in range(1, len(sections), 2):
            if i + 1 < len(sections):
                section_name = sections[i]
                section_content = sections[i + 1]
                findings[section_name] = section_content.strip()[:500]  # Primeros 500 chars
        
        # Extraer información crítica
        privileges = []
        if 'TokenPrivileges' in output:
            priv_matches = re.findall(r'(\w+Privilege)\s+:\s+\w+', output)
            privileges = list(set(priv_matches))
        
        return {
            'tool': 'seatbelt',
            'sections_found': len(findings),
            'sections': list(findings.keys()),
            'privileges': privileges,
            'findings': findings
        }

