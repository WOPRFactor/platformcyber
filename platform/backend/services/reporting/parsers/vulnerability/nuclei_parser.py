"""
Nuclei Parser
=============

Parser para archivos JSONL de Nuclei.
Cada línea es un JSON independiente con un resultado de Nuclei.
"""

import json
from pathlib import Path
from typing import List
from ..base_parser import BaseParser, ParsedFinding
from ...config import MAX_FILE_SIZE


class NucleiParser(BaseParser):
    """Parser para archivos JSONL de Nuclei."""
    
    SEVERITY_MAP = {
        'critical': 'critical',
        'high': 'high',
        'medium': 'medium',
        'low': 'low',
        'info': 'info',
        'unknown': 'info'
    }
    
    def can_parse(self, file_path: Path) -> bool:
        """
        Verifica si es un archivo JSONL de Nuclei.
        
        Args:
            file_path: Ruta al archivo
            
        Returns:
            True si es JSONL y contiene 'nuclei' en el nombre
        """
        return (
            file_path.suffix.lower() == '.jsonl' and 
            'nuclei' in file_path.stem.lower()
        )
    
    def parse(self, file_path: Path) -> List[ParsedFinding]:
        """
        Parsea archivo JSONL de Nuclei (un JSON por línea).
        
        Args:
            file_path: Ruta al archivo JSONL
            
        Returns:
            Lista de ParsedFinding con vulnerabilidades encontradas
        """
        findings = []
        
        # Validar tamaño del archivo
        if not self._validate_file_size(file_path, MAX_FILE_SIZE):
            self.logger.warning(f"File {file_path} exceeds max size, skipping")
            return findings
        
        try:
            content = self._read_file(file_path)
            if not content:
                return findings
            
            # JSONL = una línea JSON por línea
            for line_num, line in enumerate(content.strip().split('\n'), 1):
                if not line.strip():
                    continue
                
                try:
                    data = json.loads(line)
                    finding = self._parse_line(data)
                    if finding:
                        findings.append(finding)
                        
                except json.JSONDecodeError as e:
                    self.logger.warning(
                        f"Invalid JSON at line {line_num} in {file_path}: {e}"
                    )
                    continue
            
            self.logger.info(f"Parsed {len(findings)} vulnerabilities from {file_path}")
            
        except Exception as e:
            self.logger.error(f"Error parsing Nuclei JSONL {file_path}: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
        
        return findings
    
    def _parse_line(self, data: dict) -> ParsedFinding:
        """
        Parsea una línea JSON de Nuclei.
        
        Args:
            data: Diccionario con datos de una línea JSONL
            
        Returns:
            ParsedFinding o None si no se puede parsear
        """
        # Extraer campos principales
        template_id = data.get('template-id', 'unknown')
        info = data.get('info', {})
        matched_at = data.get('matched-at', data.get('host', ''))
        
        # Severity
        severity = info.get('severity', 'info').lower()
        severity = self.SEVERITY_MAP.get(severity, 'info')
        
        # Nombre y descripción
        name = info.get('name', template_id)
        description = info.get('description', '')
        
        # Referencias
        references = info.get('reference', [])
        if isinstance(references, str):
            references = [references]
        
        # Tags
        tags = info.get('tags', [])
        if isinstance(tags, str):
            tags = tags.split(',')
        
        # CVE si existe
        cve_id = self._extract_cve(references)
        
        # Evidencia
        evidence = self._extract_evidence(data)
        
        return ParsedFinding(
            title=name,
            severity=severity,
            description=description,
            category='vulnerability',
            affected_target=matched_at,
            evidence=evidence,
            cve_id=cve_id,
            references=references,
            raw_data={
                'template_id': template_id,
                'tags': tags,
                'matcher_name': data.get('matcher-name'),
                'type': data.get('type')
            }
        )
    
    def _extract_cve(self, references: List[str]) -> str:
        """
        Extrae CVE de las referencias.
        
        Args:
            references: Lista de referencias
            
        Returns:
            CVE ID o None
        """
        import re
        for ref in references:
            # Buscar patrón CVE-YYYY-NNNNN en la referencia
            cve_match = re.search(r'CVE-\d{4}-\d+', ref.upper())
            if cve_match:
                return cve_match.group(0)
        return None
    
    def _extract_evidence(self, data: dict) -> str:
        """
        Extrae evidencia del resultado de Nuclei.
        
        Args:
            data: Diccionario con datos de Nuclei
            
        Returns:
            String con evidencia o None
        """
        evidence = data.get('matched-line', '')
        if not evidence:
            evidence = data.get('extracted-results', [])
            if evidence:
                evidence = str(evidence)
        return evidence if evidence else None
