"""
XSS Multi-Tool Scanner Service
===============================

Servicio unificado para escaneo XSS con múltiples herramientas.

Herramientas soportadas:
- XSStrike (Primary - Recommended)
- XSSer (Secondary - Fast fallback)
- OWASP ZAP (Professional - Requires daemon)
- Nuclei (Template-based - Optional)

Modos de escaneo:
- AUTO: XSStrike → XSSer (fallback)
- SINGLE: Una herramienta seleccionada
- COMPARE: Múltiples herramientas en paralelo
"""

import subprocess
import logging
import json
import threading
import shutil
import os
import time
import requests
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError

from utils.validators import CommandSanitizer, DomainValidator
from utils.workspace_logger import log_to_workspace
from repositories import ScanRepository
from models import db

logger = logging.getLogger(__name__)


class XSSScannerService:
    """Servicio unificado para escaneo XSS multi-herramienta."""
    
    # Timeouts por defecto (en segundos)
    DEFAULT_TIMEOUTS = {
        'xsstrike': 300,  # 5 minutos
        'xsser': 180,     # 3 minutos
        'zap': 600,       # 10 minutos
        'nuclei': 180     # 3 minutos
    }
    
    # Timeout global para modo ALL/COMPARE
    DEFAULT_GLOBAL_TIMEOUT = 900  # 15 minutos
    
    def __init__(self, scan_repository: ScanRepository = None):
        """Inicializa el servicio."""
        self.scan_repo = scan_repository or ScanRepository()
        
    def _get_workspace_output_dir(self, scan_id: int) -> Path:
        """Obtiene directorio de output del workspace para un scan."""
        from utils.workspace_filesystem import get_workspace_output_dir_from_scan
        return get_workspace_output_dir_from_scan(scan_id, 'vuln_scans')
    
    # ============================================
    # VERIFICACIÓN DE HERRAMIENTAS
    # ============================================
    
    def check_tool_availability(self) -> Dict[str, bool]:
        """
        Verifica qué herramientas están disponibles en el sistema.
        
        Returns:
            Dict con disponibilidad de cada herramienta
        """
        availability = {
            'xsstrike': False,
            'xsser': False,
            'zap': False,
            'nuclei': False
        }
        
        # Verificar XSStrike
        xsstrike_paths = [
            '/usr/share/xsstrike/xsstrike.py',
            shutil.which('xsstrike.py'),
            shutil.which('xsstrike')
        ]
        for path in xsstrike_paths:
            if path and os.path.exists(path):
                availability['xsstrike'] = True
                break
        
        # Verificar XSSer
        if shutil.which('xsser'):
            availability['xsser'] = True
        
        # Verificar Nuclei
        if shutil.which('nuclei'):
            availability['nuclei'] = True
        
        # Verificar ZAP (binario y daemon)
        if shutil.which('zaproxy') or shutil.which('zap-cli'):
            # Verificar si el daemon está corriendo
            try:
                response = requests.get('http://localhost:8080', timeout=2)
                if response.status_code in [200, 401, 403]:  # ZAP responde aunque requiera auth
                    availability['zap'] = True
            except:
                availability['zap'] = False  # Binario existe pero daemon no está corriendo
        
        return availability
    
    def check_zap_daemon(self) -> Tuple[bool, Optional[str]]:
        """
        Verifica si el daemon de ZAP está corriendo.
        
        Returns:
            Tuple (is_running, error_message)
        """
        try:
            response = requests.get('http://localhost:8080', timeout=2)
            return True, None
        except requests.exceptions.RequestException:
            return False, "ZAP daemon not running. Please start ZAP first: 'zaproxy -daemon -port 8080'"
    
    # ============================================
    # WRAPPERS POR HERRAMIENTA
    # ============================================
    
    def _find_xsstrike(self) -> Optional[str]:
        """Encuentra la ruta de XSStrike."""
        paths = [
            '/usr/share/xsstrike/xsstrike.py',
            shutil.which('xsstrike.py'),
            shutil.which('xsstrike')
        ]
        for path in paths:
            if path and os.path.exists(path):
                return path
        return None
    
    def _execute_xsstrike(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Ejecuta escaneo con XSStrike.
        
        Args:
            url: URL objetivo
            scan_id: ID del scan
            workspace_id: ID del workspace
            options: Opciones de configuración
            
        Returns:
            Dict con resultados
        """
        xsstrike_path = self._find_xsstrike()
        if not xsstrike_path:
            raise ValueError("XSStrike not found. Install with: git clone https://github.com/s0md3v/XSStrike.git /usr/share/xsstrike")
        
        workspace_output_dir = self._get_workspace_output_dir(scan_id)
        output_file = str(workspace_output_dir / f'xsstrike_{scan_id}.json')
        
        # Construir comando
        command = ['python3', xsstrike_path, '-u', url, '--json']
        
        # Opciones configurables
        if options.get('crawl', False):
            command.append('--crawl')
        
        if options.get('fuzzing', False):
            command.append('--fuzzer')
        
        if options.get('skip_dom', False):
            command.append('--skip')
        
        if options.get('timeout'):
            command.extend(['--timeout', str(options['timeout'])])
        
        if options.get('custom_headers'):
            headers_str = ' '.join([f"{k}: {v}" for k, v in options['custom_headers'].items()])
            command.extend(['--headers', headers_str])
        
        timeout = options.get('timeout', self.DEFAULT_TIMEOUTS['xsstrike'])
        
        log_to_workspace(
            workspace_id=workspace_id,
            source='XSSTRIKE',
            level='INFO',
            message=f"Starting XSStrike scan {scan_id}",
            metadata={'scan_id': scan_id, 'target': url, 'command': ' '.join(command)}
        )
        
        try:
            # Ejecutar comando
            process = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=os.path.dirname(xsstrike_path) if os.path.dirname(xsstrike_path) else None
            )
            
            # Guardar output en archivo
            with open(output_file, 'w') as f:
                f.write(process.stdout)
            
            # Parsear resultados
            results = self._parse_xsstrike_output(process.stdout, output_file)
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='XSSTRIKE',
                level='INFO',
                message=f"XSStrike scan {scan_id} completed",
                metadata={'scan_id': scan_id, 'vulnerabilities_found': len(results.get('vulnerabilities', []))}
            )
            
            return {
                'success': True,
                'tool': 'xsstrike',
                'vulnerabilities': results.get('vulnerabilities', []),
                'raw_output': process.stdout,
                'output_file': output_file
            }
            
        except subprocess.TimeoutExpired:
            error_msg = f"XSStrike scan {scan_id} timed out after {timeout} seconds"
            log_to_workspace(
                workspace_id=workspace_id,
                source='XSSTRIKE',
                level='ERROR',
                message=error_msg,
                metadata={'scan_id': scan_id}
            )
            raise TimeoutError(error_msg)
        except Exception as e:
            error_msg = f"XSStrike scan {scan_id} failed: {str(e)}"
            log_to_workspace(
                workspace_id=workspace_id,
                source='XSSTRIKE',
                level='ERROR',
                message=error_msg,
                metadata={'scan_id': scan_id, 'error': str(e)}
            )
            raise
    
    def _execute_xsser(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Ejecuta escaneo con XSSer.
        
        Args:
            url: URL objetivo
            scan_id: ID del scan
            workspace_id: ID del workspace
            options: Opciones de configuración
            
        Returns:
            Dict con resultados
        """
        if not shutil.which('xsser'):
            raise ValueError("XSSer not found. Install with: apt install xsser")
        
        workspace_output_dir = self._get_workspace_output_dir(scan_id)
        output_file = str(workspace_output_dir / f'xsser_{scan_id}.txt')
        
        # Construir comando
        command = ['xsser']
        
        # Modo automático (recomendado)
        if options.get('auto_mode', True):
            command.extend(['--auto', '-u', url])
        else:
            command.extend(['-u', url])
        
        # Opciones configurables
        if options.get('custom_cookies'):
            command.extend(['--Coo', options['custom_cookies']])
        
        if options.get('custom_payload'):
            command.extend(['--payload', options['custom_payload']])
        
        if options.get('threads'):
            command.extend(['--threads', str(options['threads'])])
        
        if options.get('timeout'):
            command.extend(['--timeout', str(options['timeout'])])
        
        if options.get('verbose', False):
            command.append('--verbose')
        
        timeout = options.get('timeout', self.DEFAULT_TIMEOUTS['xsser'])
        
        log_to_workspace(
            workspace_id=workspace_id,
            source='XSSER',
            level='INFO',
            message=f"Starting XSSer scan {scan_id}",
            metadata={'scan_id': scan_id, 'target': url, 'command': ' '.join(command)}
        )
        
        try:
            # Ejecutar comando
            process = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            # Guardar output en archivo
            with open(output_file, 'w') as f:
                f.write(process.stdout)
                if process.stderr:
                    f.write(f"\n--- STDERR ---\n{process.stderr}")
            
            # Parsear resultados
            results = self._parse_xsser_output(process.stdout)
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='XSSER',
                level='INFO',
                message=f"XSSer scan {scan_id} completed",
                metadata={'scan_id': scan_id, 'vulnerabilities_found': len(results.get('vulnerabilities', []))}
            )
            
            return {
                'success': True,
                'tool': 'xsser',
                'vulnerabilities': results.get('vulnerabilities', []),
                'raw_output': process.stdout,
                'output_file': output_file
            }
            
        except subprocess.TimeoutExpired:
            error_msg = f"XSSer scan {scan_id} timed out after {timeout} seconds"
            log_to_workspace(
                workspace_id=workspace_id,
                source='XSSER',
                level='ERROR',
                message=error_msg,
                metadata={'scan_id': scan_id}
            )
            raise TimeoutError(error_msg)
        except Exception as e:
            error_msg = f"XSSer scan {scan_id} failed: {str(e)}"
            log_to_workspace(
                workspace_id=workspace_id,
                source='XSSER',
                level='ERROR',
                message=error_msg,
                metadata={'scan_id': scan_id, 'error': str(e)}
            )
            raise
    
    def _execute_zap(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Ejecuta escaneo con OWASP ZAP.
        
        Args:
            url: URL objetivo
            scan_id: ID del scan
            workspace_id: ID del workspace
            options: Opciones de configuración
            
        Returns:
            Dict con resultados
        """
        # Verificar daemon
        is_running, error_msg = self.check_zap_daemon()
        if not is_running:
            raise ValueError(error_msg or "ZAP daemon not running")
        
        if not shutil.which('zap-cli'):
            raise ValueError("zap-cli not found. Install with: pip3 install zapcli")
        
        workspace_output_dir = self._get_workspace_output_dir(scan_id)
        output_file = str(workspace_output_dir / f'zap_{scan_id}.json')
        
        # Construir comando
        command = ['zap-cli', 'quick-scan', '--self-contained', '--start-options', '-config api.disablekey=true', url]
        
        timeout = options.get('timeout', self.DEFAULT_TIMEOUTS['zap'])
        
        log_to_workspace(
            workspace_id=workspace_id,
            source='ZAP',
            level='INFO',
            message=f"Starting ZAP scan {scan_id}",
            metadata={'scan_id': scan_id, 'target': url}
        )
        
        try:
            # Ejecutar comando
            process = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            # Generar reporte JSON
            report_cmd = ['zap-cli', 'report', '-o', output_file, '-f', 'json']
            subprocess.run(report_cmd, capture_output=True, timeout=30)
            
            # Parsear resultados
            results = self._parse_zap_output(output_file)
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='ZAP',
                level='INFO',
                message=f"ZAP scan {scan_id} completed",
                metadata={'scan_id': scan_id, 'vulnerabilities_found': len(results.get('vulnerabilities', []))}
            )
            
            return {
                'success': True,
                'tool': 'zap',
                'vulnerabilities': results.get('vulnerabilities', []),
                'raw_output': process.stdout,
                'output_file': output_file
            }
            
        except subprocess.TimeoutExpired:
            error_msg = f"ZAP scan {scan_id} timed out after {timeout} seconds"
            log_to_workspace(
                workspace_id=workspace_id,
                source='ZAP',
                level='ERROR',
                message=error_msg,
                metadata={'scan_id': scan_id}
            )
            raise TimeoutError(error_msg)
        except Exception as e:
            error_msg = f"ZAP scan {scan_id} failed: {str(e)}"
            log_to_workspace(
                workspace_id=workspace_id,
                source='ZAP',
                level='ERROR',
                message=error_msg,
                metadata={'scan_id': scan_id, 'error': str(e)}
            )
            raise
    
    def _execute_nuclei_xss(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Ejecuta escaneo XSS con Nuclei usando templates XSS.
        
        Args:
            url: URL objetivo
            scan_id: ID del scan
            workspace_id: ID del workspace
            options: Opciones de configuración
            
        Returns:
            Dict con resultados
        """
        if not shutil.which('nuclei'):
            raise ValueError("Nuclei not found. Install with: apt install nuclei")
        
        workspace_output_dir = self._get_workspace_output_dir(scan_id)
        output_file = str(workspace_output_dir / f'nuclei_xss_{scan_id}.json')
        
        # Construir comando
        command = ['nuclei', '-u', url, '-tags', 'xss', '-json']
        
        # Opciones configurables
        if options.get('severity'):
            severities = ','.join(options['severity'])
            command.extend(['-severity', severities])
        
        timeout = options.get('timeout', self.DEFAULT_TIMEOUTS['nuclei'])
        
        log_to_workspace(
            workspace_id=workspace_id,
            source='NUCLEI',
            level='INFO',
            message=f"Starting Nuclei XSS scan {scan_id}",
            metadata={'scan_id': scan_id, 'target': url}
        )
        
        try:
            # Ejecutar comando
            process = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            # Guardar output en archivo
            with open(output_file, 'w') as f:
                f.write(process.stdout)
            
            # Parsear resultados
            results = self._parse_nuclei_output(process.stdout)
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='NUCLEI',
                level='INFO',
                message=f"Nuclei XSS scan {scan_id} completed",
                metadata={'scan_id': scan_id, 'vulnerabilities_found': len(results.get('vulnerabilities', []))}
            )
            
            return {
                'success': True,
                'tool': 'nuclei',
                'vulnerabilities': results.get('vulnerabilities', []),
                'raw_output': process.stdout,
                'output_file': output_file
            }
            
        except subprocess.TimeoutExpired:
            error_msg = f"Nuclei XSS scan {scan_id} timed out after {timeout} seconds"
            log_to_workspace(
                workspace_id=workspace_id,
                source='NUCLEI',
                level='ERROR',
                message=error_msg,
                metadata={'scan_id': scan_id}
            )
            raise TimeoutError(error_msg)
        except Exception as e:
            error_msg = f"Nuclei XSS scan {scan_id} failed: {str(e)}"
            log_to_workspace(
                workspace_id=workspace_id,
                source='NUCLEI',
                level='ERROR',
                message=error_msg,
                metadata={'scan_id': scan_id, 'error': str(e)}
            )
            raise
    
    # ============================================
    # PARSERS DE SALIDA
    # ============================================
    
    def _parse_xsstrike_output(self, stdout: str, output_file: str) -> Dict[str, Any]:
        """
        Parsea salida JSON de XSStrike.
        XSStrike puede generar múltiples líneas JSON.
        """
        vulnerabilities = []
        
        # Intentar leer del archivo primero
        if os.path.exists(output_file):
            try:
                with open(output_file, 'r') as f:
                    content = f.read()
                    for line in content.strip().split('\n'):
                        if not line.strip():
                            continue
                        try:
                            finding = json.loads(line)
                            vuln = self._normalize_xss_vulnerability(finding, 'xsstrike')
                            if vuln:
                                vulnerabilities.append(vuln)
                        except json.JSONDecodeError:
                            continue
            except Exception as e:
                logger.warning(f"Error reading XSStrike output file: {e}")
        
        # Si no hay resultados del archivo, parsear stdout
        if not vulnerabilities:
            for line in stdout.strip().split('\n'):
                if not line.strip():
                    continue
                try:
                    finding = json.loads(line)
                    vuln = self._normalize_xss_vulnerability(finding, 'xsstrike')
                    if vuln:
                        vulnerabilities.append(vuln)
                except json.JSONDecodeError:
                    continue
        
        return {'vulnerabilities': vulnerabilities}
    
    def _parse_xsser_output(self, stdout: str) -> Dict[str, Any]:
        """
        Parsea salida de texto de XSSer.
        Busca líneas con "XSS", "FOUND", "VULNERABLE".
        """
        vulnerabilities = []
        
        lines = stdout.split('\n')
        for i, line in enumerate(lines):
            line_lower = line.lower()
            if any(keyword in line_lower for keyword in ['xss', 'found', 'vulnerable', 'payload']):
                # Intentar extraer información de la línea
                vuln = self._extract_xsser_vulnerability(line, lines, i)
                if vuln:
                    vulnerabilities.append(vuln)
        
        return {'vulnerabilities': vulnerabilities}
    
    def _parse_zap_output(self, output_file: str) -> Dict[str, Any]:
        """Parsea reporte JSON de ZAP."""
        vulnerabilities = []
        
        if not os.path.exists(output_file):
            return {'vulnerabilities': []}
        
        try:
            with open(output_file, 'r') as f:
                data = json.load(f)
                
            # ZAP report structure
            sites = data.get('site', [])
            for site in sites:
                alerts = site.get('alerts', [])
                for alert in alerts:
                    if 'xss' in alert.get('name', '').lower() or 'cross-site scripting' in alert.get('name', '').lower():
                        vuln = self._normalize_zap_vulnerability(alert, site)
                        if vuln:
                            vulnerabilities.append(vuln)
        except Exception as e:
            logger.error(f"Error parsing ZAP output: {e}")
        
        return {'vulnerabilities': vulnerabilities}
    
    def _parse_nuclei_output(self, stdout: str) -> Dict[str, Any]:
        """Parsea salida JSONL de Nuclei."""
        vulnerabilities = []
        
        for line in stdout.strip().split('\n'):
            if not line.strip():
                continue
            try:
                finding = json.loads(line)
                # Filtrar solo XSS
                if 'xss' in finding.get('template-id', '').lower() or 'xss' in finding.get('info', {}).get('tags', []):
                    vuln = self._normalize_nuclei_vulnerability(finding)
                    if vuln:
                        vulnerabilities.append(vuln)
            except json.JSONDecodeError:
                continue
        
        return {'vulnerabilities': vulnerabilities}
    
    # ============================================
    # NORMALIZACIÓN DE RESULTADOS
    # ============================================
    
    def _normalize_xss_vulnerability(self, finding: Dict, tool: str) -> Optional[Dict[str, Any]]:
        """Normaliza vulnerabilidad de XSStrike a formato común."""
        try:
            return {
                'type': 'XSS',
                'subtype': finding.get('type', 'reflected'),  # reflected, stored, dom
                'payload': finding.get('payload', ''),
                'parameter': finding.get('parameter', ''),
                'context': finding.get('context', 'html'),
                'severity': 'high',  # XSS generalmente es high
                'confidence': 'high',
                'detected_by': tool,
                'url': finding.get('url', ''),
                'method': finding.get('method', 'GET'),
                'evidence': finding.get('evidence', ''),
                'remediation': 'Sanitize user input and use Content Security Policy (CSP)'
            }
        except Exception:
            return None
    
    def _extract_xsser_vulnerability(self, line: str, all_lines: List[str], line_index: int) -> Optional[Dict[str, Any]]:
        """Extrae información de vulnerabilidad de salida de XSSer."""
        try:
            # Buscar payload en la línea o líneas siguientes
            payload = ''
            url = ''
            
            # Buscar URL y payload en líneas cercanas
            for i in range(max(0, line_index - 2), min(len(all_lines), line_index + 3)):
                current_line = all_lines[i]
                if 'http' in current_line.lower():
                    url = current_line.strip()
                if '<script' in current_line.lower() or 'alert' in current_line.lower():
                    payload = current_line.strip()
            
            if not payload and not url:
                return None
            
            return {
                'type': 'XSS',
                'subtype': 'reflected',
                'payload': payload,
                'parameter': '',
                'context': 'html',
                'severity': 'high',
                'confidence': 'medium',
                'detected_by': 'xsser',
                'url': url,
                'method': 'GET',
                'evidence': line,
                'remediation': 'Sanitize user input and use Content Security Policy (CSP)'
            }
        except Exception:
            return None
    
    def _normalize_zap_vulnerability(self, alert: Dict, site: Dict) -> Optional[Dict[str, Any]]:
        """Normaliza vulnerabilidad de ZAP a formato común."""
        try:
            return {
                'type': 'XSS',
                'subtype': 'reflected',  # ZAP puede detectar ambos tipos
                'payload': alert.get('attack', ''),
                'parameter': alert.get('param', ''),
                'context': alert.get('other', {}).get('context', 'html'),
                'severity': self._map_zap_severity(alert.get('risk', 'Medium')),
                'confidence': self._map_zap_confidence(alert.get('confidence', 'Medium')),
                'detected_by': 'zap',
                'url': alert.get('uri', ''),
                'method': alert.get('method', 'GET'),
                'evidence': alert.get('evidence', ''),
                'remediation': alert.get('solution', 'Sanitize user input and use Content Security Policy (CSP)')
            }
        except Exception:
            return None
    
    def _normalize_nuclei_vulnerability(self, finding: Dict) -> Optional[Dict[str, Any]]:
        """Normaliza vulnerabilidad de Nuclei a formato común."""
        try:
            info = finding.get('info', {})
            return {
                'type': 'XSS',
                'subtype': 'reflected',
                'payload': finding.get('matched-at', ''),
                'parameter': '',
                'context': 'html',
                'severity': info.get('severity', 'medium').lower(),
                'confidence': 'high',
                'detected_by': 'nuclei',
                'url': finding.get('host', ''),
                'method': 'GET',
                'evidence': finding.get('matched-at', ''),
                'remediation': info.get('reference', '') or 'Sanitize user input and use Content Security Policy (CSP)'
            }
        except Exception:
            return None
    
    def _map_zap_severity(self, risk: str) -> str:
        """Mapea severidad de ZAP a formato común."""
        mapping = {
            'Informational': 'low',
            'Low': 'low',
            'Medium': 'medium',
            'High': 'high',
            'Critical': 'critical'
        }
        return mapping.get(risk, 'medium').lower()
    
    def _map_zap_confidence(self, confidence: str) -> str:
        """Mapea confianza de ZAP a formato común."""
        mapping = {
            'False Positive': 'low',
            'Low': 'low',
            'Medium': 'medium',
            'High': 'high',
            'Confirmed': 'high'
        }
        return mapping.get(confidence, 'medium').lower()
    
    # ============================================
    # DEDUPLICACIÓN
    # ============================================
    
    def _deduplicate_vulnerabilities(self, all_vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Deduplica vulnerabilidades basándose en (payload, parameter, url).
        Si múltiples herramientas detectan la misma, consolida.
        """
        seen = {}
        deduplicated = []
        
        for vuln in all_vulnerabilities:
            # Crear clave única
            key = (
                vuln.get('payload', '').strip(),
                vuln.get('parameter', '').strip(),
                vuln.get('url', '').strip()
            )
            
            if key in seen:
                # Consolidar: agregar herramienta a detected_by
                existing = seen[key]
                existing_tools = existing.get('detected_by', [])
                if isinstance(existing_tools, str):
                    existing_tools = [existing_tools]
                
                new_tool = vuln.get('detected_by', '')
                if new_tool and new_tool not in existing_tools:
                    existing_tools.append(new_tool)
                
                existing['detected_by'] = existing_tools
                
                # Aumentar confidence si múltiples herramientas confirman
                if len(existing_tools) > 1:
                    existing['confidence'] = 'high'
            else:
                # Nueva vulnerabilidad
                vuln_copy = vuln.copy()
                detected_by = vuln_copy.get('detected_by', '')
                if isinstance(detected_by, str):
                    vuln_copy['detected_by'] = [detected_by]
                seen[key] = vuln_copy
                deduplicated.append(vuln_copy)
        
        return deduplicated
    
    # ============================================
    # MÉTODOS PRINCIPALES DE ESCANEO
    # ============================================
    
    def start_xss_scan(
        self,
        url: str,
        workspace_id: int,
        user_id: int,
        engine: str = 'auto',
        scan_mode: str = 'single',
        engines: Optional[List[str]] = None,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Inicia escaneo XSS según modo especificado.
        
        Args:
            url: URL objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            engine: 'auto', 'xsstrike', 'xsser', 'zap', 'nuclei'
            scan_mode: 'single', 'all', 'compare'
            engines: Lista de engines para modo COMPARE (default: ['xsstrike', 'xsser'])
            options: Opciones de configuración
            
        Returns:
            Dict con información del scan iniciado
        """
        if not DomainValidator.validate_url(url):
            raise ValueError(f'Invalid URL: {url}')
        
        options = options or {}
        
        # Crear scan principal
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=url,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'xss',
                'engine': engine,
                'scan_mode': scan_mode,
                'engines': engines or [],
                **options
            }
        )
        
        try:
            if scan_mode == 'auto':
                return self._start_auto_scan(url, scan.id, workspace_id, options)
            elif scan_mode == 'single':
                return self._start_single_scan(url, scan.id, workspace_id, engine, options)
            elif scan_mode == 'compare' or scan_mode == 'all':
                return self._start_compare_scan(url, scan.id, workspace_id, engines or ['xsstrike', 'xsser'], options)
            else:
                raise ValueError(f"Invalid scan_mode: {scan_mode}")
        except Exception as e:
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def _start_auto_scan(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Modo AUTO: XSStrike → XSSer (fallback)
        """
        log_to_workspace(
            workspace_id=workspace_id,
            source='XSS',
            level='INFO',
            message=f"Starting AUTO XSS scan {scan_id} (XSStrike → XSSer)",
            metadata={'scan_id': scan_id, 'target': url}
        )
        
        # Intentar XSStrike primero
        try:
            result = self._execute_xsstrike(url, scan_id, workspace_id, options)
            if result.get('vulnerabilities'):
                # Encontró vulnerabilidades, retornar
                self.scan_repo.update_status(
                    self.scan_repo.find_by_id(scan_id),
                    'completed',
                    f"Found {len(result['vulnerabilities'])} vulnerabilities with XSStrike"
                )
                return {
                    'scan_id': scan_id,
                    'status': 'completed',
                    'mode': 'auto',
                    'tool_used': 'xsstrike',
                    'vulnerabilities': result['vulnerabilities'],
                    'fallback_used': False
                }
        except Exception as e:
            logger.warning(f"XSStrike failed, trying XSSer: {e}")
        
        # Fallback a XSSer
        try:
            result = self._execute_xsser(url, scan_id, workspace_id, options)
            self.scan_repo.update_status(
                self.scan_repo.find_by_id(scan_id),
                'completed',
                f"Found {len(result.get('vulnerabilities', []))} vulnerabilities with XSSer (fallback)"
            )
            return {
                'scan_id': scan_id,
                'status': 'completed',
                'mode': 'auto',
                'tool_used': 'xsser',
                'vulnerabilities': result.get('vulnerabilities', []),
                'fallback_used': True
            }
        except Exception as e:
            error_msg = f"Both XSStrike and XSSer failed: {str(e)}"
            self.scan_repo.update_status(
                self.scan_repo.find_by_id(scan_id),
                'failed',
                error_msg
            )
            raise Exception(error_msg)
    
    def _start_single_scan(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        engine: str,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Modo SINGLE: Una herramienta específica
        """
        log_to_workspace(
            workspace_id=workspace_id,
            source='XSS',
            level='INFO',
            message=f"Starting SINGLE XSS scan {scan_id} with {engine}",
            metadata={'scan_id': scan_id, 'target': url, 'engine': engine}
        )
        
        # Ejecutar en thread para no bloquear
        def execute_scan():
            from celery_app import get_flask_app
            app = get_flask_app()
            with app.app_context():
                try:
                    if engine == 'xsstrike':
                        result = self._execute_xsstrike(url, scan_id, workspace_id, options)
                    elif engine == 'xsser':
                        result = self._execute_xsser(url, scan_id, workspace_id, options)
                    elif engine == 'zap':
                        result = self._execute_zap(url, scan_id, workspace_id, options)
                    elif engine == 'nuclei':
                        result = self._execute_nuclei_xss(url, scan_id, workspace_id, options)
                    else:
                        raise ValueError(f"Unknown engine: {engine}")
                    
                    self.scan_repo.update_status(
                        self.scan_repo.find_by_id(scan_id),
                        'completed',
                        f"Found {len(result.get('vulnerabilities', []))} vulnerabilities"
                    )
                except Exception as e:
                    self.scan_repo.update_status(
                        self.scan_repo.find_by_id(scan_id),
                        'failed',
                        str(e)
                    )
        
        thread = threading.Thread(target=execute_scan)
        thread.daemon = True
        thread.start()
        
        self.scan_repo.update_status(
            self.scan_repo.find_by_id(scan_id),
            'running'
        )
        
        return {
            'scan_id': scan_id,
            'status': 'running',
            'mode': 'single',
            'engine': engine,
            'target': url
        }
    
    def _start_compare_scan(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        engines: List[str],
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Modo COMPARE/ALL: Múltiples herramientas en paralelo
        """
        log_to_workspace(
            workspace_id=workspace_id,
            source='XSS',
            level='INFO',
            message=f"Starting COMPARE XSS scan {scan_id} with engines: {engines}",
            metadata={'scan_id': scan_id, 'target': url, 'engines': engines}
        )
        
        global_timeout = options.get('global_timeout', self.DEFAULT_GLOBAL_TIMEOUT)
        
        # Ejecutar en thread para no bloquear
        def execute_parallel_scans():
            from celery_app import get_flask_app
            app = get_flask_app()
            with app.app_context():
                all_results = []
                incomplete = False
                
                start_time = time.time()
                
                def run_tool(engine_name: str):
                    try:
                        tool_options = options.copy()
                        tool_options['timeout'] = options.get('timeout_per_tool', self.DEFAULT_TIMEOUTS.get(engine_name, 300))
                        
                        if engine_name == 'xsstrike':
                            return self._execute_xsstrike(url, scan_id, workspace_id, tool_options)
                        elif engine_name == 'xsser':
                            return self._execute_xsser(url, scan_id, workspace_id, tool_options)
                        elif engine_name == 'zap':
                            return self._execute_zap(url, scan_id, workspace_id, tool_options)
                        elif engine_name == 'nuclei':
                            return self._execute_nuclei_xss(url, scan_id, workspace_id, tool_options)
                        else:
                            return None
                    except Exception as e:
                        logger.error(f"Tool {engine_name} failed: {e}")
                        return {'success': False, 'tool': engine_name, 'error': str(e), 'vulnerabilities': []}
                
                # Ejecutar herramientas en paralelo con ThreadPoolExecutor
                with ThreadPoolExecutor(max_workers=len(engines)) as executor:
                    futures = {executor.submit(run_tool, engine): engine for engine in engines}
                    
                    for future in futures:
                        elapsed = time.time() - start_time
                        if elapsed > global_timeout:
                            incomplete = True
                            logger.warning(f"Global timeout reached, stopping remaining tools")
                            break
                        
                        try:
                            result = future.result(timeout=global_timeout - elapsed)
                            if result:
                                all_results.append(result)
                        except FutureTimeoutError:
                            incomplete = True
                            logger.warning(f"Tool {futures[future]} timed out")
                
                # Consolidar resultados
                all_vulnerabilities = []
                for result in all_results:
                    if result.get('success') and result.get('vulnerabilities'):
                        all_vulnerabilities.extend(result['vulnerabilities'])
                
                # Deduplicar
                deduplicated = self._deduplicate_vulnerabilities(all_vulnerabilities)
                
                # Actualizar scan
                status_msg = f"Found {len(deduplicated)} unique vulnerabilities across {len(engines)} tools"
                if incomplete:
                    status_msg += " (incomplete - timeout reached)"
                
                self.scan_repo.update_status(
                    self.scan_repo.find_by_id(scan_id),
                    'completed',
                    status_msg
                )
        
        thread = threading.Thread(target=execute_parallel_scans)
        thread.daemon = True
        thread.start()
        
        self.scan_repo.update_status(
            self.scan_repo.find_by_id(scan_id),
            'running'
        )
        
        return {
            'scan_id': scan_id,
            'status': 'running',
            'mode': 'compare',
            'engines': engines,
            'target': url
        }
    
    # ============================================
    # PREVIEW DE COMANDOS
    # ============================================
    
    def preview_xss_command(
        self,
        url: str,
        workspace_id: int,
        engine: str = 'auto',
        scan_mode: str = 'single',
        engines: Optional[List[str]] = None,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Genera preview del comando que se ejecutará.
        
        Returns:
            Dict con información del comando preview
        """
        options = options or {}
        engines = engines or ['xsstrike', 'xsser']
        
        commands = []
        warnings = []
        
        if scan_mode == 'auto':
            # Preview de XSStrike
            xsstrike_path = self._find_xsstrike()
            if xsstrike_path:
                cmd = ['python3', xsstrike_path, '-u', url, '--json']
                if options.get('crawl'):
                    cmd.append('--crawl')
                if options.get('fuzzing'):
                    cmd.append('--fuzzer')
                commands.append({
                    'tool': 'xsstrike',
                    'command': ' '.join(cmd),
                    'description': 'Primary scan with XSStrike'
                })
            else:
                warnings.append('XSStrike not found')
            
            # Preview de XSSer (fallback)
            if shutil.which('xsser'):
                cmd = ['xsser', '--auto', '-u', url]
                commands.append({
                    'tool': 'xsser',
                    'command': ' '.join(cmd),
                    'description': 'Fallback scan with XSSer (if XSStrike finds nothing)'
                })
            else:
                warnings.append('XSSer not found')
        
        elif scan_mode == 'single':
            if engine == 'xsstrike':
                xsstrike_path = self._find_xsstrike()
                if xsstrike_path:
                    cmd = ['python3', xsstrike_path, '-u', url, '--json']
                    if options.get('crawl'):
                        cmd.append('--crawl')
                    if options.get('fuzzing'):
                        cmd.append('--fuzzer')
                    commands.append({
                        'tool': 'xsstrike',
                        'command': ' '.join(cmd)
                    })
            elif engine == 'xsser':
                if shutil.which('xsser'):
                    cmd = ['xsser', '--auto', '-u', url]
                    commands.append({
                        'tool': 'xsser',
                        'command': ' '.join(cmd)
                    })
            elif engine == 'zap':
                is_running, error_msg = self.check_zap_daemon()
                if is_running:
                    cmd = ['zap-cli', 'quick-scan', '--self-contained', url]
                    commands.append({
                        'tool': 'zap',
                        'command': ' '.join(cmd)
                    })
                else:
                    warnings.append(error_msg or 'ZAP daemon not running')
            elif engine == 'nuclei':
                if shutil.which('nuclei'):
                    cmd = ['nuclei', '-u', url, '-tags', 'xss', '-json']
                    commands.append({
                        'tool': 'nuclei',
                        'command': ' '.join(cmd)
                    })
        
        elif scan_mode == 'compare' or scan_mode == 'all':
            for engine in engines:
                if engine == 'xsstrike':
                    xsstrike_path = self._find_xsstrike()
                    if xsstrike_path:
                        cmd = ['python3', xsstrike_path, '-u', url, '--json']
                        commands.append({
                            'tool': 'xsstrike',
                            'command': ' '.join(cmd)
                        })
                elif engine == 'xsser':
                    if shutil.which('xsser'):
                        cmd = ['xsser', '--auto', '-u', url]
                        commands.append({
                            'tool': 'xsser',
                            'command': ' '.join(cmd)
                        })
                elif engine == 'zap':
                    is_running, error_msg = self.check_zap_daemon()
                    if is_running:
                        cmd = ['zap-cli', 'quick-scan', '--self-contained', url]
                        commands.append({
                            'tool': 'zap',
                            'command': ' '.join(cmd)
                        })
                    else:
                        warnings.append(f'ZAP: {error_msg or "daemon not running"}')
                elif engine == 'nuclei':
                    if shutil.which('nuclei'):
                        cmd = ['nuclei', '-u', url, '-tags', 'xss', '-json']
                        commands.append({
                            'tool': 'nuclei',
                            'command': ' '.join(cmd)
                        })
        
        return {
            'commands': commands,
            'warnings': warnings,
            'estimated_timeout': options.get('timeout_per_tool', 300) if scan_mode == 'single' else options.get('global_timeout', 900),
            'parameters': {
                'url': url,
                'engine': engine,
                'scan_mode': scan_mode,
                'engines': engines,
                **options
            }
        }



