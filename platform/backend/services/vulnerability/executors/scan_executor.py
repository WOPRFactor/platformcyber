"""
Scan Executor
=============

Ejecutor de scans de vulnerabilidades en background.
"""

import subprocess
import logging
import json
import threading
import time
import signal
import os
from typing import List, Optional
from pathlib import Path

from utils.validators import CommandSanitizer
from utils.workspace_logger import log_to_workspace
from repositories import ScanRepository
from utils.parsers.vuln_parser import (
    NucleiParser, NiktoParser, SQLMapParser,
    TestSSLParser, WhatWebParser, WappalyzerParser, ZAPParser
)

logger = logging.getLogger(__name__)


class ScanExecutor:
    """Ejecutor de scans en background."""
    
    def __init__(self, scan_repository: ScanRepository = None):
        """Inicializa el ejecutor."""
        self.scan_repo = scan_repository or ScanRepository()
        
        # Parsers por herramienta
        self.parsers = {
            'nuclei': NucleiParser(),
            'nikto': NiktoParser(),
            'sqlmap': SQLMapParser(),
            'testssl': TestSSLParser(),
            'whatweb': WhatWebParser(),
            'wappalyzer': WappalyzerParser(),
            'zap': ZAPParser()
        }
        
        # Timeouts por herramienta
        self.timeout_map = {
            'nuclei': 3600,    # 1 hora
            'nikto': 3600,     # 1 hora
            'sqlmap': 3600,    # 1 hora
            'zap': 7200,       # 2 horas
            'testssl': 600,    # 10 minutos
            'whatweb': 300,    # 5 minutos
            'dalfox': 1800     # 30 minutos
        }
    
    def execute_scan(
        self,
        scan_id: int,
        command: List[str],
        output_file: str,
        tool: str,
        workspace_id: int
    ) -> None:
        """
        Ejecuta un scan en background y procesa los resultados.
        
        Args:
            scan_id: ID del scan
            command: Comando a ejecutar
            output_file: Archivo de salida
            tool: Nombre de la herramienta
            workspace_id: ID del workspace
        """
        from celery_app import get_flask_app
        
        app = get_flask_app()
        
        with app.app_context():
            try:
                from models import Scan
                scan = Scan.query.get(scan_id)
                if not scan:
                    logger.error(f"Scan {scan_id} not found")
                    return
                
                log_to_workspace(
                    workspace_id=workspace_id,
                    source=tool.upper(),
                    level='INFO',
                    message=f"Executing {tool} scan {scan_id}",
                    metadata={'scan_id': scan_id, 'command': ' '.join(command)}
                )
                
                timeout = self.timeout_map.get(tool, 1800)
                
                # Preparar entorno para ejecución
                env = CommandSanitizer.get_safe_env()
                
                # Configuraciones especiales por herramienta
                if tool == 'whatweb':
                    env['RUBYLIB'] = '/usr/lib/ruby/vendor_ruby:' + env.get('RUBYLIB', '')
                
                if tool == 'zap':
                    script_path = command[0] if command else None
                    if script_path and Path(script_path).exists():
                        script_dir = str(Path(script_path).parent)
                        pythonpath = env.get('PYTHONPATH', '')
                        if pythonpath:
                            env['PYTHONPATH'] = f'{script_dir}:{pythonpath}'
                        else:
                            env['PYTHONPATH'] = script_dir
                        current_path = env.get('PATH', '')
                        home_bin = os.path.expanduser('~/.local/bin')
                        if home_bin not in current_path:
                            env['PATH'] = f'{home_bin}:{current_path}'
                
                process = subprocess.Popen(
                    command,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    env=env
                )
                
                # Guardar PID
                if scan.options:
                    scan.options['pid'] = process.pid
                    from repositories import ScanRepository
                    ScanRepository().update_options(scan, scan.options)
                
                start_time = time.time()
                last_update = start_time
                
                # Actualizar progreso durante la ejecución
                while process.poll() is None:
                    elapsed = time.time() - start_time
                    
                    if time.time() - last_update >= 10:
                        progress = min(5 + int((elapsed / timeout) * 80), 85)
                        elapsed_min = int(elapsed / 60)
                        elapsed_sec = int(elapsed % 60)
                        status_msg = f"Ejecutando {tool}... ({elapsed_min}m {elapsed_sec}s)"
                        
                        scan = self.scan_repo.find_by_id(scan_id)
                        if scan:
                            self.scan_repo.update_progress(scan, progress, status_msg)
                        last_update = time.time()
                    
                    if elapsed > timeout:
                        process.terminate()
                        try:
                            process.wait(timeout=5)
                        except subprocess.TimeoutExpired:
                            process.kill()
                        raise subprocess.TimeoutExpired(command, timeout)
                    
                    time.sleep(2)
                
                stdout, stderr = process.communicate()
                
                # Guardar stdout si no hay archivo de salida
                output_path = Path(output_file)
                if not output_path.exists() and stdout:
                    output_path.parent.mkdir(parents=True, exist_ok=True)
                    with open(output_file, 'w') as f:
                        f.write(stdout)
                
                # Esperar para herramientas que escriben directamente a archivo
                if tool in ['nikto', 'nuclei']:
                    time.sleep(1)
                
                # Verificar contenido del archivo
                file_exists = output_path.exists()
                file_size = output_path.stat().st_size if file_exists else 0
                file_is_empty = file_exists and file_size == 0
                
                file_has_valid_content = False
                if file_exists and file_size > 0:
                    try:
                        with open(output_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content_preview = f.read(1000)
                            if content_preview.strip() and len(content_preview.strip()) > 2:
                                file_has_valid_content = True
                    except Exception as e:
                        logger.warning(f"Error reading output file: {e}")
                
                # Log stderr y stdout para debugging
                if stderr:
                    log_to_workspace(
                        workspace_id=workspace_id,
                        source=tool.upper(),
                        level='DEBUG',
                        message=f"{tool} scan {scan_id} stderr: {stderr[:1000]}",
                        metadata={'scan_id': scan_id, 'stderr': stderr[:500]}
                    )
                
                if stdout:
                    log_to_workspace(
                        workspace_id=workspace_id,
                        source=tool.upper(),
                        level='DEBUG',
                        message=f"{tool} scan {scan_id} stdout: {stdout[:500]}",
                        metadata={'scan_id': scan_id}
                    )
                
                if process.returncode == 0:
                    # Casos especiales por herramienta
                    if tool == 'nuclei' and file_is_empty:
                        stderr_lower = (stderr or '').lower()
                        stdout_lower = (stdout or '').lower()
                        if ('0 matches found' in stderr_lower or 
                            'scan completed' in stderr_lower or
                            '"matched":"0"' in stdout_lower):
                            self.scan_repo.update_status(scan, 'completed')
                            self.scan_repo.update_progress(scan, 100, "Scan completed - No vulnerabilities found")
                            log_to_workspace(
                                workspace_id=workspace_id,
                                source=tool.upper(),
                                level='SUCCESS',
                                message=f"{tool} scan {scan_id} completed. No vulnerabilities found.",
                                metadata={'scan_id': scan_id, 'matches': 0}
                            )
                        else:
                            error_msg = f"Output file is empty. stderr: {stderr[:200] if stderr else 'No stderr'}"
                            self.scan_repo.update_status(scan, 'failed', error_msg)
                    
                    elif tool == 'nikto' and file_exists:
                        try:
                            import json
                            with open(output_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                                content_stripped = content.strip()
                                if ((content_stripped.startswith('[') and content_stripped.endswith(']')) or
                                    (content_stripped.startswith('{') and content_stripped.endswith('}'))):
                                    json.loads(content)
                                    self.scan_repo.update_status(scan, 'completed')
                                    self.scan_repo.update_progress(scan, 100, "Completed")
                                    log_to_workspace(
                                        workspace_id=workspace_id,
                                        source=tool.upper(),
                                        level='SUCCESS',
                                        message=f"{tool} scan {scan_id} completed. Output size: {file_size} bytes",
                                        metadata={'scan_id': scan_id, 'output_size': file_size}
                                    )
                                else:
                                    error_msg = f"JSON file is incomplete or malformed"
                                    self.scan_repo.update_status(scan, 'failed', error_msg)
                        except json.JSONDecodeError as e:
                            error_msg = f"JSON file is invalid: {str(e)}"
                            self.scan_repo.update_status(scan, 'failed', error_msg)
                        except Exception as e:
                            error_msg = f"Error validating output file: {str(e)}"
                            self.scan_repo.update_status(scan, 'failed', error_msg)
                    
                    elif file_is_empty or not file_has_valid_content:
                        error_msg = f"Output file is empty or invalid. File size: {file_size} bytes"
                        self.scan_repo.update_status(scan, 'failed', error_msg)
                        log_to_workspace(
                            workspace_id=workspace_id,
                            source=tool.upper(),
                            level='ERROR',
                            message=f"{tool} scan {scan_id} completed but output file is empty or invalid",
                            metadata={'scan_id': scan_id, 'error': error_msg, 'file_size': file_size}
                        )
                    else:
                        # Parsear resultados si hay parser disponible
                        if tool in self.parsers:
                            try:
                                parser = self.parsers[tool]
                                vulnerabilities = parser.parse(str(output_path))
                                
                                for vuln in vulnerabilities:
                                    self.scan_repo.add_vulnerability(scan, vuln)
                                
                                log_to_workspace(
                                    workspace_id=workspace_id,
                                    source=tool.upper(),
                                    level='INFO',
                                    message=f"Scan {scan_id} completed. Found {len(vulnerabilities)} vulnerabilities",
                                    metadata={'scan_id': scan_id, 'vulnerabilities_count': len(vulnerabilities)}
                                )
                            except Exception as parse_error:
                                logger.error(f"Error parsing {tool} results: {parse_error}")
                                log_to_workspace(
                                    workspace_id=workspace_id,
                                    source=tool.upper(),
                                    level='WARNING',
                                    message=f"Scan completed but parsing failed: {str(parse_error)}",
                                    metadata={'scan_id': scan_id}
                                )
                        
                        self.scan_repo.update_status(scan, 'completed')
                        self.scan_repo.update_progress(scan, 100, f"{tool} completado")
                        log_to_workspace(
                            workspace_id=workspace_id,
                            source=tool.upper(),
                            level='SUCCESS',
                            message=f"{tool} scan {scan_id} completed successfully. Output size: {file_size} bytes",
                            metadata={'scan_id': scan_id, 'output_size': file_size}
                        )
                else:
                    error_msg = stderr or stdout or 'Unknown error'
                    logger.error(f"{tool} scan {scan_id} failed: {error_msg}")
                    self.scan_repo.update_status(scan, 'failed', error_msg)
                    log_to_workspace(
                        workspace_id=workspace_id,
                        source=tool.upper(),
                        level='ERROR',
                        message=f"{tool} scan {scan_id} failed: {error_msg[:500]}",
                        metadata={'scan_id': scan_id, 'error': error_msg, 'returncode': process.returncode}
                    )
                    
            except Exception as e:
                logger.error(f"Error executing {tool} scan {scan_id}: {e}")
                log_to_workspace(
                    workspace_id=workspace_id,
                    source=tool.upper(),
                    level='ERROR',
                    message=f"Error executing scan: {str(e)}",
                    metadata={'scan_id': scan_id, 'error': str(e)}
                )
                scan = self.scan_repo.find_by_id(scan_id)
                if scan:
                    self.scan_repo.update_status(scan, 'failed', str(e))
    
    def execute_async(
        self,
        scan_id: int,
        command: List[str],
        output_file: str,
        tool: str,
        workspace_id: int
    ) -> None:
        """
        Ejecuta un scan de forma asíncrona en un thread separado.
        
        Args:
            scan_id: ID del scan
            command: Comando a ejecutar
            output_file: Archivo de salida
            tool: Nombre de la herramienta
            workspace_id: ID del workspace
        """
        thread = threading.Thread(
            target=self.execute_scan,
            args=(scan_id, command, output_file, tool, workspace_id)
        )
        thread.daemon = True
        thread.start()

