"""
XSS Multi-Tool Scanner Service
===============================

Servicio unificado para escaneo XSS con múltiples herramientas.

Herramientas soportadas:
- XSStrike (Primary - Recommended)
- XSSer (Secondary - Fast fallback)
- OWASP ZAP (Professional - Requires daemon)
- Nuclei (Template-based - Optional)

Modos de escaneo:
- AUTO: XSStrike → XSSer (fallback)
- SINGLE: Una herramienta seleccionada
- COMPARE: Múltiples herramientas en paralelo

Refactorizado: 2025-12-04
"""

import logging
import threading
import time
from typing import Dict, Any, List, Optional
from concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError

from utils.validators import DomainValidator
from utils.workspace_logger import log_to_workspace
from repositories import ScanRepository
from services.vulnerability.xss_scanner.base import BaseXSSScanner
from services.vulnerability.xss_scanner.tools import (
    XSStrikeScanner,
    XSSerScanner,
    ZAPScanner,
    NucleiXSSScanner
)
from services.vulnerability.xss_scanner.utils import deduplicate_vulnerabilities

logger = logging.getLogger(__name__)


class XSSScannerService(BaseXSSScanner):
    """Servicio unificado para escaneo XSS multi-herramienta."""
    
    # Timeouts por defecto (en segundos)
    DEFAULT_TIMEOUTS = {
        'xsstrike': 300,  # 5 minutos
        'xsser': 180,     # 3 minutos
        'zap': 600,       # 10 minutos
        'nuclei': 180     # 3 minutos
    }
    
    # Timeout global para modo ALL/COMPARE
    DEFAULT_GLOBAL_TIMEOUT = 900  # 15 minutos
    
    def __init__(self, scan_repository: ScanRepository = None):
        """Inicializa el servicio."""
        super().__init__(scan_repository)
        
        # Inicializar scanners individuales
        self.xsstrike_scanner = XSStrikeScanner(scan_repository)
        self.xsser_scanner = XSSerScanner(scan_repository)
        self.zap_scanner = ZAPScanner(scan_repository)
        self.nuclei_scanner = NucleiXSSScanner(scan_repository)
    
    def check_tool_availability(self) -> Dict[str, bool]:
        """
        Verifica qué herramientas están disponibles en el sistema.
        
        Returns:
            Dict con disponibilidad de cada herramienta
        """
        availability = {
            'xsstrike': False,
            'xsser': False,
            'zap': False,
            'nuclei': False
        }
        
        if self.xsstrike_scanner._find_xsstrike():
            availability['xsstrike'] = True
        
        import shutil
        if shutil.which('xsser'):
            availability['xsser'] = True
        
        if shutil.which('nuclei'):
            availability['nuclei'] = True
        
        is_running, _ = self.zap_scanner.check_zap_daemon()
        availability['zap'] = is_running
        
        return availability
    
    def check_zap_daemon(self) -> tuple[bool, Optional[str]]:
        """
        Verifica si el daemon de ZAP está corriendo.
        
        Returns:
            Tuple (is_running, error_message)
        """
        return self.zap_scanner.check_zap_daemon()
    
    def start_xss_scan(
        self,
        url: str,
        workspace_id: int,
        user_id: int,
        engine: str = 'auto',
        scan_mode: str = 'single',
        engines: Optional[List[str]] = None,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Inicia escaneo XSS según modo especificado.
        
        Args:
            url: URL objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            engine: 'auto', 'xsstrike', 'xsser', 'zap', 'nuclei'
            scan_mode: 'single', 'all', 'compare'
            engines: Lista de engines para modo COMPARE (default: ['xsstrike', 'xsser'])
            options: Opciones de configuración
            
        Returns:
            Dict con información del scan iniciado
        """
        if not DomainValidator.validate_url(url):
            raise ValueError(f'Invalid URL: {url}')
        
        options = options or {}
        
        # Crear scan principal
        scan = self._create_scan(
            scan_type='vulnerability',
            target=url,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='xss',
            options={
                'engine': engine,
                'scan_mode': scan_mode,
                'engines': engines or [],
                **options
            }
        )
        
        try:
            if scan_mode == 'auto':
                return self._start_auto_scan(url, scan.id, workspace_id, options)
            elif scan_mode == 'single':
                return self._start_single_scan(url, scan.id, workspace_id, engine, options)
            elif scan_mode == 'compare' or scan_mode == 'all':
                return self._start_compare_scan(url, scan.id, workspace_id, engines or ['xsstrike', 'xsser'], options)
            else:
                raise ValueError(f"Invalid scan_mode: {scan_mode}")
        except Exception as e:
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def _start_auto_scan(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Modo AUTO: XSStrike → XSSer (fallback)
        """
        log_to_workspace(
            workspace_id=workspace_id,
            source='XSS',
            level='INFO',
            message=f"Starting AUTO XSS scan {scan_id} (XSStrike → XSSer)",
            metadata={'scan_id': scan_id, 'target': url}
        )
        
        # Intentar XSStrike primero
        try:
            result = self.xsstrike_scanner.execute_scan(url, scan_id, workspace_id, options)
            if result.get('vulnerabilities'):
                # Encontró vulnerabilidades, retornar
                self.scan_repo.update_status(
                    self.scan_repo.find_by_id(scan_id),
                    'completed',
                    f"Found {len(result['vulnerabilities'])} vulnerabilities with XSStrike"
                )
                return {
                    'scan_id': scan_id,
                    'status': 'completed',
                    'mode': 'auto',
                    'tool_used': 'xsstrike',
                    'vulnerabilities': result['vulnerabilities'],
                    'fallback_used': False
                }
        except Exception as e:
            logger.warning(f"XSStrike failed, trying XSSer: {e}")
        
        # Fallback a XSSer
        try:
            result = self.xsser_scanner.execute_scan(url, scan_id, workspace_id, options)
            self.scan_repo.update_status(
                self.scan_repo.find_by_id(scan_id),
                'completed',
                f"Found {len(result.get('vulnerabilities', []))} vulnerabilities with XSSer (fallback)"
            )
            return {
                'scan_id': scan_id,
                'status': 'completed',
                'mode': 'auto',
                'tool_used': 'xsser',
                'vulnerabilities': result.get('vulnerabilities', []),
                'fallback_used': True
            }
        except Exception as e:
            error_msg = f"Both XSStrike and XSSer failed: {str(e)}"
            self.scan_repo.update_status(
                self.scan_repo.find_by_id(scan_id),
                'failed',
                error_msg
            )
            raise Exception(error_msg)
    
    def _start_single_scan(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        engine: str,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Modo SINGLE: Una herramienta específica
        """
        log_to_workspace(
            workspace_id=workspace_id,
            source='XSS',
            level='INFO',
            message=f"Starting SINGLE XSS scan {scan_id} with {engine}",
            metadata={'scan_id': scan_id, 'target': url, 'engine': engine}
        )
        
        # Ejecutar en thread para no bloquear
        def execute_scan():
            from celery_app import get_flask_app
            app = get_flask_app()
            with app.app_context():
                try:
                    if engine == 'xsstrike':
                        result = self.xsstrike_scanner.execute_scan(url, scan_id, workspace_id, options)
                    elif engine == 'xsser':
                        result = self.xsser_scanner.execute_scan(url, scan_id, workspace_id, options)
                    elif engine == 'zap':
                        result = self.zap_scanner.execute_scan(url, scan_id, workspace_id, options)
                    elif engine == 'nuclei':
                        result = self.nuclei_scanner.execute_scan(url, scan_id, workspace_id, options)
                    else:
                        raise ValueError(f"Unknown engine: {engine}")
                    
                    self.scan_repo.update_status(
                        self.scan_repo.find_by_id(scan_id),
                        'completed',
                        f"Found {len(result.get('vulnerabilities', []))} vulnerabilities"
                    )
                except Exception as e:
                    self.scan_repo.update_status(
                        self.scan_repo.find_by_id(scan_id),
                        'failed',
                        str(e)
                    )
        
        thread = threading.Thread(target=execute_scan)
        thread.daemon = True
        thread.start()
        
        self.scan_repo.update_status(
            self.scan_repo.find_by_id(scan_id),
            'running'
        )
        
        return {
            'scan_id': scan_id,
            'status': 'running',
            'mode': 'single',
            'engine': engine,
            'target': url
        }
    
    def _start_compare_scan(
        self,
        url: str,
        scan_id: int,
        workspace_id: int,
        engines: List[str],
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Modo COMPARE/ALL: Múltiples herramientas en paralelo
        """
        log_to_workspace(
            workspace_id=workspace_id,
            source='XSS',
            level='INFO',
            message=f"Starting COMPARE XSS scan {scan_id} with engines: {engines}",
            metadata={'scan_id': scan_id, 'target': url, 'engines': engines}
        )
        
        global_timeout = options.get('global_timeout', self.DEFAULT_GLOBAL_TIMEOUT)
        
        # Ejecutar en thread para no bloquear
        def execute_parallel_scans():
            from celery_app import get_flask_app
            app = get_flask_app()
            with app.app_context():
                all_results = []
                incomplete = False
                
                start_time = time.time()
                
                def run_tool(engine_name: str):
                    try:
                        tool_options = options.copy()
                        tool_options['timeout'] = options.get('timeout_per_tool', self.DEFAULT_TIMEOUTS.get(engine_name, 300))
                        
                        if engine_name == 'xsstrike':
                            return self.xsstrike_scanner.execute_scan(url, scan_id, workspace_id, tool_options)
                        elif engine_name == 'xsser':
                            return self.xsser_scanner.execute_scan(url, scan_id, workspace_id, tool_options)
                        elif engine_name == 'zap':
                            return self.zap_scanner.execute_scan(url, scan_id, workspace_id, tool_options)
                        elif engine_name == 'nuclei':
                            return self.nuclei_scanner.execute_scan(url, scan_id, workspace_id, tool_options)
                        else:
                            return None
                    except Exception as e:
                        logger.error(f"Tool {engine_name} failed: {e}")
                        return {'success': False, 'tool': engine_name, 'error': str(e), 'vulnerabilities': []}
                
                # Ejecutar herramientas en paralelo con ThreadPoolExecutor
                with ThreadPoolExecutor(max_workers=len(engines)) as executor:
                    futures = {executor.submit(run_tool, engine): engine for engine in engines}
                    
                    for future in futures:
                        elapsed = time.time() - start_time
                        if elapsed > global_timeout:
                            incomplete = True
                            logger.warning(f"Global timeout reached, stopping remaining tools")
                            break
                        
                        try:
                            result = future.result(timeout=global_timeout - elapsed)
                            if result:
                                all_results.append(result)
                        except FutureTimeoutError:
                            incomplete = True
                            logger.warning(f"Tool {futures[future]} timed out")
                
                # Consolidar resultados
                all_vulnerabilities = []
                for result in all_results:
                    if result.get('success') and result.get('vulnerabilities'):
                        all_vulnerabilities.extend(result['vulnerabilities'])
                
                # Deduplicar
                deduplicated = deduplicate_vulnerabilities(all_vulnerabilities)
                
                # Actualizar scan
                status_msg = f"Found {len(deduplicated)} unique vulnerabilities across {len(engines)} tools"
                if incomplete:
                    status_msg += " (incomplete - timeout reached)"
                
                self.scan_repo.update_status(
                    self.scan_repo.find_by_id(scan_id),
                    'completed',
                    status_msg
                )
        
        thread = threading.Thread(target=execute_parallel_scans)
        thread.daemon = True
        thread.start()
        
        self.scan_repo.update_status(
            self.scan_repo.find_by_id(scan_id),
            'running'
        )
        
        return {
            'scan_id': scan_id,
            'status': 'running',
            'mode': 'compare',
            'engines': engines,
            'target': url
        }
    
    def preview_xss_command(
        self,
        url: str,
        workspace_id: int,
        engine: str = 'auto',
        scan_mode: str = 'single',
        engines: Optional[List[str]] = None,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Genera preview del comando que se ejecutará.
        
        Returns:
            Dict con información del comando preview
        """
        options = options or {}
        engines = engines or ['xsstrike', 'xsser']
        
        commands = []
        warnings = []
        
        if scan_mode == 'auto':
            # Preview de XSStrike
            preview = self.xsstrike_scanner.preview_command(url, options)
            if preview.get('command'):
                commands.append(preview)
            elif preview.get('warning'):
                warnings.append(f"XSStrike: {preview['warning']}")
            
            # Preview de XSSer (fallback)
            preview = self.xsser_scanner.preview_command(url, options)
            if preview.get('command'):
                preview['description'] = 'Fallback scan with XSSer (if XSStrike finds nothing)'
                commands.append(preview)
            elif preview.get('warning'):
                warnings.append(f"XSSer: {preview['warning']}")
        
        elif scan_mode == 'single':
            if engine == 'xsstrike':
                preview = self.xsstrike_scanner.preview_command(url, options)
                if preview.get('command'):
                    commands.append(preview)
            elif engine == 'xsser':
                preview = self.xsser_scanner.preview_command(url, options)
                if preview.get('command'):
                    commands.append(preview)
            elif engine == 'zap':
                preview = self.zap_scanner.preview_command(url, options)
                if preview.get('command'):
                    commands.append(preview)
                elif preview.get('warning'):
                    warnings.append(preview['warning'])
            elif engine == 'nuclei':
                preview = self.nuclei_scanner.preview_command(url, options)
                if preview.get('command'):
                    commands.append(preview)
        
        elif scan_mode == 'compare' or scan_mode == 'all':
            for engine in engines:
                if engine == 'xsstrike':
                    preview = self.xsstrike_scanner.preview_command(url, options)
                    if preview.get('command'):
                        commands.append(preview)
                elif engine == 'xsser':
                    preview = self.xsser_scanner.preview_command(url, options)
                    if preview.get('command'):
                        commands.append(preview)
                elif engine == 'zap':
                    preview = self.zap_scanner.preview_command(url, options)
                    if preview.get('command'):
                        commands.append(preview)
                    elif preview.get('warning'):
                        warnings.append(f'ZAP: {preview["warning"]}')
                elif engine == 'nuclei':
                    preview = self.nuclei_scanner.preview_command(url, options)
                    if preview.get('command'):
                        commands.append(preview)
        
        return {
            'commands': commands,
            'warnings': warnings,
            'estimated_timeout': options.get('timeout_per_tool', 300) if scan_mode == 'single' else options.get('global_timeout', 900),
            'parameters': {
                'url': url,
                'engine': engine,
                'scan_mode': scan_mode,
                'engines': engines,
                **options
            }
        }


