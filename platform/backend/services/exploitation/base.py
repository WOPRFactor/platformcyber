"""
Base Exploitation Service
=========================

Clase base común para todos los servicios de explotación.
Proporciona funcionalidad compartida: ejecución de scans, logging, etc.
"""

import subprocess
import logging
import threading
from typing import Dict, Any, Optional
from pathlib import Path

from utils.validators import CommandSanitizer
from utils.workspace_logger import log_to_workspace
from repositories import ScanRepository

logger = logging.getLogger(__name__)


class BaseExploitationService:
    """Clase base para servicios de explotación."""
    
    def __init__(self, scan_repository: ScanRepository = None, output_dir: Path = None):
        """
        Inicializa el servicio base.
        
        Args:
            scan_repository: Repositorio de scans
            output_dir: Directorio de salida (default: {proyecto}/tmp/exploitation)
                      Nota: Se usa dinámicamente por workspace, este es solo fallback
        """
        self.scan_repo = scan_repository or ScanRepository()
        if output_dir is None:
            from utils.workspace_filesystem import PROJECT_TMP_DIR
            output_dir = PROJECT_TMP_DIR / 'exploitation'
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def _get_workspace_output_dir(self, scan_id: int) -> Path:
        """
        Obtiene directorio de output del workspace para un scan.
        
        Args:
            scan_id: ID del scan
        
        Returns:
            Path al directorio de output del workspace
        """
        from utils.workspace_filesystem import get_workspace_output_dir_from_scan
        return get_workspace_output_dir_from_scan(scan_id, 'exploitation')
    
    def _execute_scan(
        self,
        scan_id: int,
        command: list,
        output_file: str,
        tool: str,
        timeout: Optional[int] = None
    ) -> None:
        """
        Ejecuta un scan en thread separado.
        
        Args:
            scan_id: ID del scan
            command: Comando a ejecutar (lista)
            output_file: Archivo de salida
            tool: Nombre de la herramienta
            timeout: Timeout en segundos (opcional)
        """
        try:
            # Obtener scan para workspace_id
            scan = self.scan_repo.find_by_id(scan_id)
            workspace_id = scan.workspace_id if scan else None
            
            command_str = ' '.join([c for c in command if c not in ['>', '2>&1']])
            logger.info(f"Executing {tool} {scan_id}: {command_str}")
            
            # Log inicial
            if workspace_id:
                log_to_workspace(
                    workspace_id=workspace_id,
                    source=tool.upper(),
                    level='INFO',
                    message=f"Iniciando {tool}: {command_str}",
                    metadata={'command': command_str, 'scan_id': scan_id}
                )
            
            # Timeouts por defecto por herramienta
            timeout_map = {
                'hydra': 3600,          # 1 hora
                'john': 7200,           # 2 horas
                'hashcat': 10800,       # 3 horas
                'kerbrute': 1800,       # 30 min
                'crackmapexec': 1800,   # 30 min
                'responder': 3600,      # 1 hora
                'psexec': 600,          # 10 min
                'wmiexec': 600,         # 10 min
                'smbexec': 600,         # 10 min
                'secretsdump': 1800,    # 30 min
                'getuserspns': 600,     # 10 min
                'getnpusers': 600,      # 10 min
                'evilwinrm': 300,       # 5 min
                'msfvenom': 60,         # 1 min
                'metasploit': 3600      # 1 hora
            }
            timeout = timeout or timeout_map.get(tool, 1800)
            
            # Filtrar redirecciones de la lista de comandos
            clean_command = [c for c in command if c not in ['>', '2>&1']]
            
            # Ejecutar comando
            with open(output_file, 'w') as f:
                result = subprocess.run(
                    clean_command,
                    stdout=f,
                    stderr=subprocess.STDOUT,  # Redirigir stderr a stdout
                    text=True,
                    timeout=timeout,
                    cwd=str(self.output_dir),
                    env=CommandSanitizer.get_safe_env() if hasattr(CommandSanitizer, 'get_safe_env') else None
                )
            
            # Agregar return code al archivo
            with open(output_file, 'a') as f:
                f.write(f"\n=== RETURN CODE ===\n{result.returncode}\n")
            
            # Leer output del archivo
            output_content = ""
            try:
                with open(output_file, 'r') as f:
                    output_content = f.read()
            except Exception:
                pass
            
            # Obtener scan y actualizar estado
            scan = self.scan_repo.find_by_id(scan_id)
            workspace_id = scan.workspace_id if scan else None
            
            if result.returncode == 0:
                self.scan_repo.update_status(scan, 'completed')
                logger.info(f"{tool} {scan_id} completed successfully")
                
                # Log de éxito
                if workspace_id:
                    log_to_workspace(
                        workspace_id=workspace_id,
                        source=tool.upper(),
                        level='INFO',
                        message=f"{tool} completado exitosamente",
                        metadata={'scan_id': scan_id, 'output_file': output_file}
                    )
            else:
                error_msg = result.stderr or f"Exit code: {result.returncode}"
                self.scan_repo.update_status(scan, 'failed', error_msg)
                logger.error(f"{tool} {scan_id} failed: {error_msg}")
                
                # Log de error
                if workspace_id:
                    log_to_workspace(
                        workspace_id=workspace_id,
                        source=tool.upper(),
                        level='ERROR',
                        message=f"{tool} falló: {error_msg}",
                        metadata={'scan_id': scan_id, 'error': error_msg, 'return_code': result.returncode}
                    )
                
        except subprocess.TimeoutExpired:
            scan = self.scan_repo.find_by_id(scan_id)
            workspace_id = scan.workspace_id if scan else None
            error_msg = f"Timeout after {timeout} seconds"
            self.scan_repo.update_status(scan, 'failed', error_msg)
            logger.error(f"{tool} {scan_id} timeout: {error_msg}")
            
            # Log de timeout
            if workspace_id:
                log_to_workspace(
                    workspace_id=workspace_id,
                    source=tool.upper(),
                    level='ERROR',
                    message=f"{tool} timeout después de {timeout} segundos",
                    metadata={'scan_id': scan_id, 'timeout': timeout}
                )
            
        except Exception as e:
            scan = self.scan_repo.find_by_id(scan_id)
            workspace_id = scan.workspace_id if scan else None
            error_msg = str(e)
            self.scan_repo.update_status(scan, 'failed', error_msg)
            logger.error(f"Error executing {tool} {scan_id}: {error_msg}")
            
            # Log de error
            if workspace_id:
                log_to_workspace(
                    workspace_id=workspace_id,
                    source=tool.upper(),
                    level='ERROR',
                    message=f"Error ejecutando {tool}: {error_msg}",
                    metadata={'scan_id': scan_id, 'error': error_msg}
                )
    
    def _create_scan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        tool: str,
        options: Optional[Dict[str, Any]] = None
    ) -> Any:
        """
        Crea un nuevo scan en la base de datos.
        
        Args:
            target: Target del scan
            workspace_id: ID del workspace
            user_id: ID del usuario
            tool: Nombre de la herramienta
            options: Opciones adicionales
            
        Returns:
            Scan object
        """
        return self.scan_repo.create(
            scan_type='exploitation',
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': tool,
                **(options or {})
            }
        )
    
    def _start_scan_thread(
        self,
        scan_id: int,
        command: list,
        output_file: str,
        tool: str,
        timeout: Optional[int] = None
    ) -> None:
        """
        Inicia un scan en un thread separado.
        
        Args:
            scan_id: ID del scan
            command: Comando a ejecutar
            output_file: Archivo de salida
            tool: Nombre de la herramienta
            timeout: Timeout en segundos
        """
        thread = threading.Thread(
            target=self._execute_scan,
            args=(scan_id, command, output_file, tool, timeout)
        )
        thread.daemon = True
        thread.start()

