"""
Async executor for post-exploitation commands.
"""

import logging
import subprocess
import threading
from pathlib import Path
from typing import Dict, List

from utils.validators import CommandSanitizer

logger = logging.getLogger(__name__)


class PostExploitExecutor:
    """Runs tooling asynchronously and updates scan status."""

    def __init__(self, scan_repo, timeout_map: Dict[str, int], output_dir: Path):
        self.scan_repo = scan_repo
        self.timeout_map = timeout_map
        self.output_dir = output_dir

    def run_async(self, scan_id: int, command: List[str], output_path: str, tool: str) -> None:
        """Launch a thread to execute the command."""
        target_path = Path(output_path)
        if target_path.suffix:
            target_path.parent.mkdir(parents=True, exist_ok=True)
        else:
            target_path.mkdir(parents=True, exist_ok=True)

        thread = threading.Thread(
            target=self._execute,
            args=(scan_id, command, output_path, tool),
            daemon=True,
        )
        thread.start()

    def _execute(self, scan_id: int, command: List[str], output_path: str, tool: str) -> None:
        """Execute command and persist results."""
        timeout = self.timeout_map.get(tool, 600)
        logger.info("Executing %s %s: %s", tool, scan_id, ' '.join(command))

        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                env=CommandSanitizer.get_safe_env(),
            )
            self._persist_output(output_path, result.stdout)
            self._handle_result(scan_id, tool, result)
        except subprocess.TimeoutExpired:
            self._mark_failure(scan_id, f'Timeout ({timeout}s)')
            logger.error("%s %s timeout after %ss", tool, scan_id, timeout)
        except Exception as exc:  # pylint: disable=broad-except
            self._mark_failure(scan_id, str(exc))
            logger.error("%s %s error: %s", tool, scan_id, exc, exc_info=True)

    def _persist_output(self, output_path: str, stdout: str) -> None:
        """Store stdout if present."""
        if not stdout:
            return
        path = Path(output_path)
        if path.is_dir():
            return
        if not path.exists():
            with open(path, 'w', encoding='utf-8') as handler:
                handler.write(stdout)

    def _handle_result(self, scan_id: int, tool: str, result: subprocess.CompletedProcess) -> None:
        """Update scan status based on return code."""
        scan = self.scan_repo.find_by_id(scan_id)
        if result.returncode == 0:
            self.scan_repo.update_status(scan, 'completed')
            snippet = (result.stdout or '')[:1000]
            self.scan_repo.update_progress(scan, 100, snippet)
            logger.info("%s %s completed", tool, scan_id)
            return
        error_msg = result.stderr or 'Unknown error'
        self.scan_repo.update_status(scan, 'failed', error_msg)
        logger.error("%s %s failed: %s", tool, scan_id, error_msg)

    def _mark_failure(self, scan_id: int, message: str) -> None:
        """Set scan as failed with message."""
        scan = self.scan_repo.find_by_id(scan_id)
        self.scan_repo.update_status(scan, 'failed', message)






