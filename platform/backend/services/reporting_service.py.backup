"""
Advanced Reporting Service
===========================

Servicio completo para generación de reportes profesionales de pentesting.

Características:
- Generación de reportes ejecutivos y técnicos
- Exportación a múltiples formatos (PDF, DOCX, HTML, JSON, CSV)
- Plantillas personalizables
- Estadísticas y métricas consolidadas
- Executive summary
- Technical details con evidencias
- Remediation roadmap
- Compliance mapping
"""

import logging
import json
from typing import Dict, Any, List, Optional
from pathlib import Path
from datetime import datetime
from collections import defaultdict

from repositories import (
    ScanRepository, VulnerabilityRepository,
    WorkspaceRepository, UserRepository
)
from models import Scan, Vulnerability, Workspace

logger = logging.getLogger(__name__)


class ReportingService:
    """Servicio avanzado para generación de reportes."""
    
    def __init__(
        self,
        scan_repository: ScanRepository = None,
        vuln_repository: VulnerabilityRepository = None,
        workspace_repository: WorkspaceRepository = None,
        user_repository: UserRepository = None
    ):
        """Inicializa el servicio."""
        self.scan_repo = scan_repository or ScanRepository()
        self.vuln_repo = vuln_repository or VulnerabilityRepository()
        self.workspace_repo = workspace_repository or WorkspaceRepository()
        self.user_repo = user_repository or UserRepository()
        from utils.workspace_filesystem import PROJECT_TMP_DIR
        self.output_dir = PROJECT_TMP_DIR / 'reports'
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    # ============================================
    # GENERACIÓN DE REPORTES COMPLETOS
    # ============================================
    
    def generate_comprehensive_report(
        self,
        workspace_id: int,
        report_type: str = 'full',
        include_scans: Optional[List[int]] = None,
        include_vulns: Optional[List[int]] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """
        Genera un reporte comprehensivo de pentesting.
        
        Args:
            workspace_id: ID del workspace
            report_type: Tipo de reporte (full, executive, technical, compliance)
            include_scans: Lista de scan IDs a incluir (opcional)
            include_vulns: Lista de vulnerability IDs a incluir (opcional)
            date_from: Fecha inicio (opcional)
            date_to: Fecha fin (opcional)
        
        Returns:
            Dict con el reporte completo
        """
        workspace = self.workspace_repo.find_by_id(workspace_id)
        
        if not workspace:
            raise ValueError(f'Workspace {workspace_id} not found')
        
        # Obtener scans
        if include_scans:
            scans = [self.scan_repo.find_by_id(sid) for sid in include_scans]
            scans = [s for s in scans if s]  # Filtrar None
        else:
            scans = self.scan_repo.find_by_workspace(workspace_id)
        
        # Filtrar por fecha
        if date_from:
            scans = [s for s in scans if s.started_at and s.started_at >= date_from]
        if date_to:
            scans = [s for s in scans if s.started_at and s.started_at <= date_to]
        
        # Obtener vulnerabilidades
        if include_vulns:
            vulns = [self.vuln_repo.find_by_id(vid) for vid in include_vulns]
            vulns = [v for v in vulns if v]
        else:
            vulns = self.vuln_repo.find_by_workspace(workspace_id)
        
        # Filtrar por fecha
        if date_from:
            vulns = [v for v in vulns if v.discovered_at and v.discovered_at >= date_from]
        if date_to:
            vulns = [v for v in vulns if v.discovered_at and v.discovered_at <= date_to]
        
        # Construir reporte según tipo
        report = {
            'metadata': self._generate_metadata(workspace, report_type),
            'executive_summary': self._generate_executive_summary(scans, vulns),
            'statistics': self._generate_statistics(scans, vulns),
            'vulnerability_breakdown': self._generate_vulnerability_breakdown(vulns),
            'scan_summary': self._generate_scan_summary(scans),
        }
        
        if report_type in ['full', 'technical']:
            report['technical_details'] = self._generate_technical_details(scans, vulns)
            report['timeline'] = self._generate_timeline(scans, vulns)
        
        if report_type in ['full', 'compliance']:
            report['compliance_mapping'] = self._generate_compliance_mapping(vulns)
        
        if report_type in ['full', 'executive']:
            report['remediation_roadmap'] = self._generate_remediation_roadmap(vulns)
            report['risk_assessment'] = self._generate_risk_assessment(vulns)
        
        return report
    
    # ============================================
    # GENERADORES DE SECCIONES
    # ============================================
    
    def _generate_metadata(self, workspace: Workspace, report_type: str) -> Dict[str, Any]:
        """Genera metadata del reporte."""
        return {
            'report_id': f'RPT-{workspace.id}-{datetime.utcnow().strftime("%Y%m%d%H%M%S")}',
            'report_type': report_type,
            'workspace': {
                'id': workspace.id,
                'name': workspace.name,
                'description': workspace.description
            },
            'generated_at': datetime.utcnow().isoformat(),
            'generated_by': 'dev3-refactor Pentesting Platform',
            'version': '1.0.0'
        }
    
    def _generate_executive_summary(
        self,
        scans: List[Scan],
        vulns: List[Vulnerability]
    ) -> Dict[str, Any]:
        """Genera resumen ejecutivo."""
        # Contar por severidad
        severity_counts = defaultdict(int)
        for vuln in vulns:
            severity_counts[vuln.severity] += 1
        
        # Calcular risk score (simplificado)
        risk_score = (
            severity_counts.get('critical', 0) * 10 +
            severity_counts.get('high', 0) * 7 +
            severity_counts.get('medium', 0) * 4 +
            severity_counts.get('low', 0) * 2 +
            severity_counts.get('info', 0) * 1
        )
        
        # Determinar nivel de riesgo
        if risk_score >= 100:
            risk_level = 'Critical'
        elif risk_score >= 50:
            risk_level = 'High'
        elif risk_score >= 20:
            risk_level = 'Medium'
        else:
            risk_level = 'Low'
        
        return {
            'total_scans': len(scans),
            'total_vulnerabilities': len(vulns),
            'severity_distribution': dict(severity_counts),
            'risk_score': risk_score,
            'risk_level': risk_level,
            'key_findings': [
                f'{severity_counts.get("critical", 0)} critical vulnerabilities requiring immediate attention',
                f'{severity_counts.get("high", 0)} high-severity vulnerabilities',
                f'{len(scans)} security assessments performed',
                f'Overall risk level: {risk_level}'
            ]
        }
    
    def _generate_statistics(
        self,
        scans: List[Scan],
        vulns: List[Vulnerability]
    ) -> Dict[str, Any]:
        """Genera estadísticas detalladas."""
        # Scans por tipo
        scans_by_type = defaultdict(int)
        scans_by_status = defaultdict(int)
        scans_by_tool = defaultdict(int)
        
        for scan in scans:
            scans_by_type[scan.scan_type] += 1
            scans_by_status[scan.status] += 1
            tool = scan.options.get('tool', 'unknown')
            scans_by_tool[tool] += 1
        
        # Vulnerabilidades por estado
        vulns_by_status = defaultdict(int)
        vulns_by_target = defaultdict(int)
        vulns_by_service = defaultdict(int)
        
        for vuln in vulns:
            vulns_by_status[vuln.status] += 1
            if vuln.target:
                vulns_by_target[vuln.target] += 1
            if vuln.service:
                vulns_by_service[vuln.service] += 1
        
        return {
            'scans': {
                'by_type': dict(scans_by_type),
                'by_status': dict(scans_by_status),
                'by_tool': dict(scans_by_tool),
                'total': len(scans)
            },
            'vulnerabilities': {
                'by_status': dict(vulns_by_status),
                'top_targets': dict(sorted(
                    vulns_by_target.items(),
                    key=lambda x: x[1],
                    reverse=True
                )[:10]),
                'by_service': dict(sorted(
                    vulns_by_service.items(),
                    key=lambda x: x[1],
                    reverse=True
                )[:10]),
                'total': len(vulns)
            }
        }
    
    def _generate_vulnerability_breakdown(
        self,
        vulns: List[Vulnerability]
    ) -> Dict[str, Any]:
        """Genera desglose detallado de vulnerabilidades."""
        breakdown = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': [],
            'info': []
        }
        
        for vuln in vulns:
            vuln_data = {
                'id': vuln.id,
                'title': vuln.title,
                'cve_id': vuln.cve_id,
                'target': vuln.target,
                'port': vuln.port,
                'service': vuln.service,
                'status': vuln.status,
                'discovered_at': vuln.discovered_at.isoformat() if vuln.discovered_at else None,
                'cvss_score': vuln.cvss_score
            }
            
            if vuln.severity in breakdown:
                breakdown[vuln.severity].append(vuln_data)
        
        # Ordenar por CVSS score (descendente)
        for severity in breakdown:
            breakdown[severity].sort(
                key=lambda x: x.get('cvss_score', 0),
                reverse=True
            )
        
        return breakdown
    
    def _generate_scan_summary(self, scans: List[Scan]) -> List[Dict[str, Any]]:
        """Genera resumen de scans realizados."""
        summary = []
        
        for scan in scans:
            summary.append({
                'scan_id': scan.id,
                'scan_type': scan.scan_type,
                'target': scan.target,
                'tool': scan.options.get('tool'),
                'status': scan.status,
                'progress': scan.progress,
                'started_at': scan.started_at.isoformat() if scan.started_at else None,
                'completed_at': scan.completed_at.isoformat() if scan.completed_at else None,
                'duration': self._calculate_duration(scan)
            })
        
        # Ordenar por fecha (más reciente primero)
        summary.sort(
            key=lambda x: x['started_at'] or '',
            reverse=True
        )
        
        return summary
    
    def _generate_technical_details(
        self,
        scans: List[Scan],
        vulns: List[Vulnerability]
    ) -> List[Dict[str, Any]]:
        """Genera detalles técnicos de vulnerabilidades."""
        details = []
        
        # Solo vulnerabilidades críticas y altas
        critical_high = [v for v in vulns if v.severity in ['critical', 'high']]
        
        for vuln in critical_high:
            details.append({
                'vulnerability_id': vuln.id,
                'title': vuln.title,
                'severity': vuln.severity,
                'cve_id': vuln.cve_id,
                'cvss_score': vuln.cvss_score,
                'description': vuln.description,
                'target': vuln.target,
                'port': vuln.port,
                'service': vuln.service,
                'proof_of_concept': vuln.proof_of_concept,
                'impact': vuln.impact,
                'remediation': vuln.remediation,
                'references': vuln.references,
                'discovered_at': vuln.discovered_at.isoformat() if vuln.discovered_at else None
            })
        
        return details
    
    def _generate_timeline(
        self,
        scans: List[Scan],
        vulns: List[Vulnerability]
    ) -> List[Dict[str, Any]]:
        """Genera timeline de actividades."""
        events = []
        
        # Agregar scans
        for scan in scans:
            if scan.started_at:
                events.append({
                    'timestamp': scan.started_at.isoformat(),
                    'type': 'scan_started',
                    'scan_id': scan.id,
                    'scan_type': scan.scan_type,
                    'target': scan.target,
                    'tool': scan.options.get('tool')
                })
            
            if scan.completed_at:
                events.append({
                    'timestamp': scan.completed_at.isoformat(),
                    'type': 'scan_completed',
                    'scan_id': scan.id,
                    'status': scan.status
                })
        
        # Agregar vulnerabilidades descubiertas
        for vuln in vulns:
            if vuln.discovered_at:
                events.append({
                    'timestamp': vuln.discovered_at.isoformat(),
                    'type': 'vulnerability_discovered',
                    'vulnerability_id': vuln.id,
                    'severity': vuln.severity,
                    'title': vuln.title,
                    'target': vuln.target
                })
        
        # Ordenar por timestamp
        events.sort(key=lambda x: x['timestamp'])
        
        return events
    
    def _generate_compliance_mapping(
        self,
        vulns: List[Vulnerability]
    ) -> Dict[str, Any]:
        """Genera mapeo de vulnerabilidades a frameworks de compliance."""
        # Simplificado: basado en severidad y tipo
        compliance_map = {
            'OWASP_Top_10': defaultdict(list),
            'CIS_Controls': defaultdict(list),
            'NIST_CSF': defaultdict(list),
            'ISO_27001': defaultdict(list),
            'PCI_DSS': defaultdict(list)
        }
        
        for vuln in vulns:
            # Mapeo simplificado basado en título
            title_lower = vuln.title.lower()
            
            # OWASP Top 10
            if 'injection' in title_lower or 'sql' in title_lower:
                compliance_map['OWASP_Top_10']['A03:2021-Injection'].append(vuln.id)
            if 'xss' in title_lower or 'cross-site' in title_lower:
                compliance_map['OWASP_Top_10']['A03:2021-Injection'].append(vuln.id)
            if 'authentication' in title_lower or 'password' in title_lower:
                compliance_map['OWASP_Top_10']['A07:2021-Identification_and_Authentication_Failures'].append(vuln.id)
            if 'crypto' in title_lower or 'encryption' in title_lower or 'ssl' in title_lower:
                compliance_map['OWASP_Top_10']['A02:2021-Cryptographic_Failures'].append(vuln.id)
            
            # CIS Controls (simplificado)
            if vuln.severity in ['critical', 'high']:
                compliance_map['CIS_Controls']['Control_1_Inventory'].append(vuln.id)
                compliance_map['CIS_Controls']['Control_18_Application_Software_Security'].append(vuln.id)
        
        # Convertir defaultdict a dict normal y contar
        result = {}
        for framework, mappings in compliance_map.items():
            result[framework] = {
                control: {'count': len(vuln_ids), 'vulnerabilities': vuln_ids}
                for control, vuln_ids in mappings.items()
            }
        
        return result
    
    def _generate_remediation_roadmap(
        self,
        vulns: List[Vulnerability]
    ) -> Dict[str, Any]:
        """Genera roadmap de remediación priorizado."""
        # Agrupar por prioridad
        immediate = []  # Critical
        short_term = []  # High
        medium_term = []  # Medium
        long_term = []  # Low
        
        for vuln in vulns:
            if vuln.status in ['resolved', 'false_positive']:
                continue  # Skip resolved/FP
            
            vuln_item = {
                'id': vuln.id,
                'title': vuln.title,
                'target': vuln.target,
                'remediation': vuln.remediation,
                'estimated_effort': self._estimate_remediation_effort(vuln)
            }
            
            if vuln.severity == 'critical':
                immediate.append(vuln_item)
            elif vuln.severity == 'high':
                short_term.append(vuln_item)
            elif vuln.severity == 'medium':
                medium_term.append(vuln_item)
            else:
                long_term.append(vuln_item)
        
        return {
            'immediate_action': {
                'timeframe': '0-7 days',
                'priority': 'Critical',
                'items': immediate,
                'count': len(immediate)
            },
            'short_term': {
                'timeframe': '1-4 weeks',
                'priority': 'High',
                'items': short_term,
                'count': len(short_term)
            },
            'medium_term': {
                'timeframe': '1-3 months',
                'priority': 'Medium',
                'items': medium_term,
                'count': len(medium_term)
            },
            'long_term': {
                'timeframe': '3-6 months',
                'priority': 'Low',
                'items': long_term,
                'count': len(long_term)
            }
        }
    
    def _generate_risk_assessment(self, vulns: List[Vulnerability]) -> Dict[str, Any]:
        """Genera evaluación de riesgos."""
        # Calcular métricas de riesgo
        total_vulns = len(vulns)
        unresolved = len([v for v in vulns if v.status not in ['resolved', 'false_positive']])
        
        severity_counts = defaultdict(int)
        for vuln in vulns:
            if vuln.status not in ['resolved', 'false_positive']:
                severity_counts[vuln.severity] += 1
        
        # Risk score ponderado
        risk_score = (
            severity_counts.get('critical', 0) * 10 +
            severity_counts.get('high', 0) * 7 +
            severity_counts.get('medium', 0) * 4 +
            severity_counts.get('low', 0) * 2 +
            severity_counts.get('info', 0) * 1
        )
        
        # Normalizar a 0-100
        max_possible_score = total_vulns * 10
        normalized_score = (risk_score / max_possible_score * 100) if max_possible_score > 0 else 0
        
        return {
            'overall_risk_score': round(normalized_score, 2),
            'total_vulnerabilities': total_vulns,
            'unresolved_vulnerabilities': unresolved,
            'resolution_rate': round((total_vulns - unresolved) / total_vulns * 100, 2) if total_vulns > 0 else 0,
            'critical_count': severity_counts.get('critical', 0),
            'high_count': severity_counts.get('high', 0),
            'medium_count': severity_counts.get('medium', 0),
            'low_count': severity_counts.get('low', 0),
            'recommendations': self._generate_risk_recommendations(severity_counts)
        }
    
    # ============================================
    # HELPERS
    # ============================================
    
    def _calculate_duration(self, scan: Scan) -> Optional[str]:
        """Calcula duración del scan."""
        if scan.started_at and scan.completed_at:
            duration = scan.completed_at - scan.started_at
            total_seconds = int(duration.total_seconds())
            hours, remainder = divmod(total_seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            if hours > 0:
                return f'{hours}h {minutes}m {seconds}s'
            elif minutes > 0:
                return f'{minutes}m {seconds}s'
            else:
                return f'{seconds}s'
        return None
    
    def _estimate_remediation_effort(self, vuln: Vulnerability) -> str:
        """Estima esfuerzo de remediación."""
        # Simplificado basado en severidad
        effort_map = {
            'critical': 'High',
            'high': 'Medium-High',
            'medium': 'Medium',
            'low': 'Low',
            'info': 'Minimal'
        }
        return effort_map.get(vuln.severity, 'Unknown')
    
    def _generate_risk_recommendations(self, severity_counts: Dict[str, int]) -> List[str]:
        """Genera recomendaciones basadas en el perfil de riesgo."""
        recommendations = []
        
        if severity_counts.get('critical', 0) > 0:
            recommendations.append('Immediate action required: Address all critical vulnerabilities within 7 days')
        
        if severity_counts.get('high', 0) > 5:
            recommendations.append('High-priority remediation plan needed for numerous high-severity findings')
        
        if severity_counts.get('medium', 0) > 10:
            recommendations.append('Consider systematic approach to medium-severity vulnerabilities')
        
        if not recommendations:
            recommendations.append('Maintain current security posture with regular assessments')
        
        return recommendations
    
    # ============================================
    # EXPORTAR A FORMATOS
    # ============================================
    
    def export_to_json(self, report_data: Dict[str, Any], filename: Optional[str] = None) -> str:
        """Exporta reporte a JSON."""
        if not filename:
            report_id = report_data.get('metadata', {}).get('report_id', 'report')
            filename = f'{report_id}.json'
        
        output_path = self.output_dir / filename
        
        with open(output_path, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        logger.info(f"Report exported to JSON: {output_path}")
        return str(output_path)
    
    def export_to_html(self, report_data: Dict[str, Any], filename: Optional[str] = None) -> str:
        """Exporta reporte a HTML."""
        if not filename:
            report_id = report_data.get('metadata', {}).get('report_id', 'report')
            filename = f'{report_id}.html'
        
        output_path = self.output_dir / filename
        
        html_content = self._generate_html_report(report_data)
        
        with open(output_path, 'w') as f:
            f.write(html_content)
        
        logger.info(f"Report exported to HTML: {output_path}")
        return str(output_path)
    
    def _generate_html_report(self, report_data: Dict[str, Any]) -> str:
        """Genera HTML del reporte."""
        # HTML básico (se puede mejorar con templates)
        metadata = report_data.get('metadata', {})
        exec_summary = report_data.get('executive_summary', {})
        
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Penetration Testing Report - {metadata.get('report_id')}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        h1 {{ color: #333; }}
        h2 {{ color: #666; border-bottom: 2px solid #ddd; padding-bottom: 5px; }}
        .severity-critical {{ color: #d32f2f; font-weight: bold; }}
        .severity-high {{ color: #f57c00; font-weight: bold; }}
        .severity-medium {{ color: #fbc02d; font-weight: bold; }}
        .severity-low {{ color: #388e3c; font-weight: bold; }}
        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
    </style>
</head>
<body>
    <h1>Penetration Testing Report</h1>
    <p><strong>Report ID:</strong> {metadata.get('report_id')}</p>
    <p><strong>Generated:</strong> {metadata.get('generated_at')}</p>
    
    <h2>Executive Summary</h2>
    <p><strong>Total Vulnerabilities:</strong> {exec_summary.get('total_vulnerabilities')}</p>
    <p><strong>Risk Level:</strong> <span class="severity-{exec_summary.get('risk_level', '').lower()}">{exec_summary.get('risk_level')}</span></p>
    <p><strong>Risk Score:</strong> {exec_summary.get('risk_score')}</p>
    
    <h3>Severity Distribution</h3>
    <ul>
        {"".join([f"<li class='severity-{sev}'>{sev.capitalize()}: {count}</li>" for sev, count in exec_summary.get('severity_distribution', {}).items()])}
    </ul>
    
    <h2>Detailed Report</h2>
    <p>For complete technical details, please refer to the JSON export.</p>
</body>
</html>
"""
        return html
