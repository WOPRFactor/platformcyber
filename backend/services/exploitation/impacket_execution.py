"""
Impacket Execution Service
===========================

Servicios para ejecución remota con Impacket:
- psexec (Shell remota)
- wmiexec (Ejecución vía WMI)
- smbexec (Ejecución SMB)
"""

import logging
from typing import Dict, Any, Optional

from utils.validators import CommandSanitizer, IPValidator
from .base import BaseExploitationService

logger = logging.getLogger(__name__)


class ImpacketExecutionService(BaseExploitationService):
    """Servicio para ejecución remota con Impacket."""
    
    def start_psexec(
        self,
        target: str,
        username: str,
        password: str,
        workspace_id: int,
        user_id: int,
        domain: Optional[str] = None,
        hash: Optional[str] = None,
        command: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Ejecuta psexec.py de Impacket.
        
        Args:
            target: IP objetivo
            username: Usuario
            password: Password (o usar hash)
            workspace_id: ID del workspace
            user_id: ID del usuario
            domain: Dominio
            hash: NTLM hash
            command: Comando a ejecutar
        """
        IPValidator.validate(target)
        
        scan = self._create_scan(
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='psexec',
            options={
                'username': username,
                'domain': domain
            }
        )
        
        try:
            output_file = str(self.output_dir / f'psexec_{scan.id}.txt')
            
            # Construir credencial
            if domain:
                cred = f'{domain}/{username}'
            else:
                cred = username
            
            command_list = [
                'psexec.py',
                f'{cred}:{password}@{target}' if password else f'{cred}@{target}',
            ]
            
            if hash:
                command_list.extend(['-hashes', hash])
            
            if command:
                command_list.append(command)
            
            command_list.extend(['>', output_file, '2>&1'])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command_list[0], command_list[1:])
            
            logger.info(f"Starting psexec {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='psexec'
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'psexec',
                'target': target
            }
            
        except Exception as e:
            logger.error(f"Error starting psexec: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def start_wmiexec(
        self,
        target: str,
        username: str,
        password: str,
        workspace_id: int,
        user_id: int,
        domain: Optional[str] = None,
        hash: Optional[str] = None,
        command: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Ejecuta wmiexec.py de Impacket.
        
        Args:
            target: IP objetivo
            username: Usuario
            password: Password (o usar hash)
            workspace_id: ID del workspace
            user_id: ID del usuario
            domain: Dominio
            hash: NTLM hash
            command: Comando a ejecutar
        """
        IPValidator.validate(target)
        
        scan = self._create_scan(
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='wmiexec',
            options={
                'username': username,
                'domain': domain
            }
        )
        
        try:
            output_file = str(self.output_dir / f'wmiexec_{scan.id}.txt')
            
            # Construir credencial
            if domain:
                cred = f'{domain}/{username}'
            else:
                cred = username
            
            command_list = [
                'wmiexec.py',
                f'{cred}:{password}@{target}' if password else f'{cred}@{target}',
            ]
            
            if hash:
                command_list.extend(['-hashes', hash])
            
            if command:
                command_list.append(command)
            
            command_list.extend(['>', output_file, '2>&1'])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command_list[0], command_list[1:])
            
            logger.info(f"Starting wmiexec {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='wmiexec'
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'wmiexec',
                'target': target
            }
            
        except Exception as e:
            logger.error(f"Error starting wmiexec: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def start_smbexec(
        self,
        target: str,
        username: str,
        password: str,
        workspace_id: int,
        user_id: int,
        domain: Optional[str] = None,
        hash: Optional[str] = None,
        command: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Ejecuta smbexec.py de Impacket.
        
        Args:
            target: IP objetivo
            username: Usuario
            password: Password (o usar hash)
            workspace_id: ID del workspace
            user_id: ID del usuario
            domain: Dominio
            hash: NTLM hash
            command: Comando a ejecutar
        """
        IPValidator.validate(target)
        
        scan = self._create_scan(
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='smbexec',
            options={
                'username': username,
                'domain': domain
            }
        )
        
        try:
            output_file = str(self.output_dir / f'smbexec_{scan.id}.txt')
            
            # Construir credencial
            if domain:
                cred = f'{domain}/{username}'
            else:
                cred = username
            
            command_list = [
                'smbexec.py',
                f'{cred}:{password}@{target}' if password else f'{cred}@{target}',
            ]
            
            if hash:
                command_list.extend(['-hashes', hash])
            
            if command:
                command_list.append(command)
            
            command_list.extend(['>', output_file, '2>&1'])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command_list[0], command_list[1:])
            
            logger.info(f"Starting smbexec {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='smbexec'
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'smbexec',
                'target': target
            }
            
        except Exception as e:
            logger.error(f"Error starting smbexec: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise


    def preview_psexec(
        self,
        target: str,
        username: str,
        password: str,
        workspace_id: int,
        domain: Optional[str] = None,
        hash: Optional[str] = None,
        command: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando psexec.py."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/psexec_{{scan_id}}.txt'
        
        if domain:
            cred = f'{domain}/{username}'
        else:
            cred = username
        
        command_list = [
            'psexec.py',
            f'{cred}:***@{target}' if password else f'{cred}@{target}',
        ]
        
        if hash:
            command_list.extend(['-hashes', hash])
        
        if command:
            command_list.append(command)
        
        command_list.extend(['>', output_file, '2>&1'])
        command_str = ' '.join([str(c) for c in command_list])
        
        warnings = []
        warnings.append('psexec puede ser detectado por antivirus y EDR')
        
        return {
            'command': command_list,
            'command_string': command_str,
            'parameters': {
                'tool': 'psexec',
                'target': target,
                'username': username,
                'password': '***',
                'domain': domain,
                'hash': hash,
                'command': command
            },
            'estimated_timeout': 1800,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
    
    def preview_wmiexec(
        self,
        target: str,
        username: str,
        password: str,
        workspace_id: int,
        domain: Optional[str] = None,
        hash: Optional[str] = None,
        command: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando wmiexec.py."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/wmiexec_{{scan_id}}.txt'
        
        if domain:
            cred = f'{domain}/{username}'
        else:
            cred = username
        
        command_list = [
            'wmiexec.py',
            f'{cred}:***@{target}' if password else f'{cred}@{target}',
        ]
        
        if hash:
            command_list.extend(['-hashes', hash])
        
        if command:
            command_list.append(command)
        
        command_list.extend(['>', output_file, '2>&1'])
        command_str = ' '.join([str(c) for c in command_list])
        
        warnings = []
        warnings.append('wmiexec puede ser detectado por sistemas de monitoreo')
        
        return {
            'command': command_list,
            'command_string': command_str,
            'parameters': {
                'tool': 'wmiexec',
                'target': target,
                'username': username,
                'password': '***',
                'domain': domain,
                'hash': hash,
                'command': command
            },
            'estimated_timeout': 1800,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
    
    def preview_smbexec(
        self,
        target: str,
        username: str,
        password: str,
        workspace_id: int,
        domain: Optional[str] = None,
        hash: Optional[str] = None,
        command: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando smbexec.py."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/smbexec_{{scan_id}}.txt'
        
        if domain:
            cred = f'{domain}/{username}'
        else:
            cred = username
        
        command_list = [
            'smbexec.py',
            f'{cred}:***@{target}' if password else f'{cred}@{target}',
        ]
        
        if hash:
            command_list.extend(['-hashes', hash])
        
        if command:
            command_list.append(command)
        
        command_list.extend(['>', output_file, '2>&1'])
        command_str = ' '.join([str(c) for c in command_list])
        
        warnings = []
        warnings.append('smbexec puede ser detectado por sistemas de seguridad')
        
        return {
            'command': command_list,
            'command_string': command_str,
            'parameters': {
                'tool': 'smbexec',
                'target': target,
                'username': username,
                'password': '***',
                'domain': domain,
                'hash': hash,
                'command': command
            },
            'estimated_timeout': 1800,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
