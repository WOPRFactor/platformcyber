"""
Hash Cracking Service
=====================

Servicios para cracking de hashes:
- John the Ripper (cracking de hashes)
- Hashcat (cracking GPU acelerado)
- Kerbrute (enumeración y bruteforce Kerberos)
"""

import logging
from typing import Dict, Any, Optional
from pathlib import Path

from utils.validators import CommandSanitizer
from utils.workspace_logger import log_to_workspace
from .base import BaseExploitationService

logger = logging.getLogger(__name__)


class HashCrackingService(BaseExploitationService):
    """Servicio para cracking de hashes."""
    
    def start_john(
        self,
        hash_file: str,
        workspace_id: int,
        user_id: int,
        wordlist: Optional[str] = None,
        format: Optional[str] = None,
        rules: bool = False
    ) -> Dict[str, Any]:
        """
        Cracking de hashes con John the Ripper.
        
        Args:
            hash_file: Path al archivo con hashes
            workspace_id: ID del workspace
            user_id: ID del usuario
            wordlist: Path a wordlist (opcional)
            format: Formato del hash (Raw-MD5, NT, sha512crypt, etc.)
            rules: Usar reglas de transformación
        """
        if not Path(hash_file).exists():
            raise ValueError(f"Hash file not found: {hash_file}")
        
        scan = self._create_scan(
            target=hash_file,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='john',
            options={
                'format': format,
                'rules': rules
            }
        )
        
        try:
            output_file = str(self.output_dir / f'john_{scan.id}.txt')
            
            command = ['john', '--show', hash_file]
            
            if format:
                command.extend(['--format', format])
            
            if wordlist:
                if not Path(wordlist).exists():
                    raise ValueError(f"Wordlist not found: {wordlist}")
                command.extend(['--wordlist', wordlist])
            
            if rules:
                command.append('--rules')
            
            command.extend(['>', output_file])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            # Log inicial del cracking
            command_str = ' '.join([str(c) for c in sanitized_cmd if c not in ['>', '2>&1']])
            log_to_workspace(
                workspace_id=workspace_id,
                source='JOHN',
                level='INFO',
                message=f"Iniciando John the Ripper para cracking de hashes",
                metadata={
                    'scan_id': scan.id,
                    'hash_file': hash_file,
                    'format': format,
                    'wordlist': wordlist if wordlist else 'incremental mode',
                    'rules': rules,
                    'command': command_str
                }
            )
            
            logger.info(f"Starting John the Ripper {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='john'
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'john',
                'target': hash_file
            }
            
        except Exception as e:
            error_msg = str(e)
            logger.error(f"Error starting John: {error_msg}")
            
            # Log de error
            log_to_workspace(
                workspace_id=workspace_id,
                source='JOHN',
                level='ERROR',
                message=f"Error iniciando John the Ripper: {error_msg}",
                metadata={
                    'scan_id': scan.id if 'scan' in locals() else None,
                    'hash_file': hash_file,
                    'error': error_msg
                }
            )
            
            self.scan_repo.update_status(scan, 'failed', error_msg)
            raise
    
    def start_hashcat(
        self,
        hash_file: str,
        workspace_id: int,
        user_id: int,
        mode: int,
        wordlist: str,
        rules_file: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Cracking GPU acelerado con Hashcat.
        
        Args:
            hash_file: Path al archivo con hashes
            workspace_id: ID del workspace
            user_id: ID del usuario
            mode: Modo de hashcat (0=MD5, 1000=NTLM, 5600=NetNTLMv2, 1800=SHA-512, etc.)
            wordlist: Path a wordlist (requerido)
            rules_file: Path a archivo de reglas (opcional)
        """
        if not Path(hash_file).exists():
            raise ValueError(f"Hash file not found: {hash_file}")
        if not Path(wordlist).exists():
            raise ValueError(f"Wordlist not found: {wordlist}")
        
        scan = self._create_scan(
            target=hash_file,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='hashcat',
            options={
                'mode': mode
            }
        )
        
        try:
            output_file = str(self.output_dir / f'hashcat_{scan.id}.txt')
            
            command = [
                'hashcat',
                '-m', str(mode),
                '-a', '0',  # Attack mode: dictionary
                hash_file,
                wordlist,
                '-o', output_file
            ]
            
            if rules_file:
                if not Path(rules_file).exists():
                    raise ValueError(f"Rules file not found: {rules_file}")
                command.extend(['-r', rules_file])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            # Log inicial del cracking
            command_str = ' '.join([str(c) for c in sanitized_cmd if c not in ['>', '2>&1']])
            log_to_workspace(
                workspace_id=workspace_id,
                source='HASHCAT',
                level='INFO',
                message=f"Iniciando Hashcat (modo {mode}) para cracking de hashes",
                metadata={
                    'scan_id': scan.id,
                    'hash_file': hash_file,
                    'mode': mode,
                    'wordlist': wordlist,
                    'rules_file': rules_file,
                    'command': command_str
                }
            )
            
            logger.info(f"Starting Hashcat {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='hashcat'
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'hashcat',
                'mode': mode,
                'target': hash_file
            }
            
        except Exception as e:
            error_msg = str(e)
            logger.error(f"Error starting Hashcat: {error_msg}")
            
            # Log de error
            log_to_workspace(
                workspace_id=workspace_id,
                source='HASHCAT',
                level='ERROR',
                message=f"Error iniciando Hashcat: {error_msg}",
                metadata={
                    'scan_id': scan.id if 'scan' in locals() else None,
                    'hash_file': hash_file,
                    'mode': mode,
                    'error': error_msg
                }
            )
            
            self.scan_repo.update_status(scan, 'failed', error_msg)
            raise
    
    def start_kerbrute(
        self,
        domain: str,
        workspace_id: int,
        user_id: int,
        mode: str,
        users_file: Optional[str] = None,
        passwords_file: Optional[str] = None,
        password: Optional[str] = None,
        dc_ip: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Enumeración y bruteforce Kerberos con Kerbrute.
        
        Args:
            domain: Dominio objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            mode: 'userenum', 'passwordspray', o 'bruteuser'
            users_file: Path a archivo de usuarios (para userenum/bruteuser)
            passwords_file: Path a archivo de passwords (para bruteuser)
            password: Password única (para passwordspray)
            dc_ip: IP del Domain Controller
        """
        CommandSanitizer.validate_target(domain)
        
        scan = self._create_scan(
            target=domain,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='kerbrute',
            options={
                'mode': mode
            }
        )
        
        try:
            output_file = str(self.output_dir / f'kerbrute_{scan.id}.txt')
            
            if mode == 'userenum':
                if not users_file or not Path(users_file).exists():
                    raise ValueError(f"Users file required and must exist: {users_file}")
                command = [
                    'kerbrute', 'userenum',
                    '-d', domain,
                    users_file,
                    '--dc', dc_ip or domain
                ]
            elif mode == 'passwordspray':
                if not users_file or not Path(users_file).exists():
                    raise ValueError(f"Users file required and must exist: {users_file}")
                if not password:
                    raise ValueError("Password required for passwordspray mode")
                command = [
                    'kerbrute', 'passwordspray',
                    '-d', domain,
                    users_file,
                    password,
                    '--dc', dc_ip or domain
                ]
            elif mode == 'bruteuser':
                if not passwords_file or not Path(passwords_file).exists():
                    raise ValueError(f"Passwords file required and must exist: {passwords_file}")
                if not users_file:
                    raise ValueError("Username required for bruteuser mode")
                command = [
                    'kerbrute', 'bruteuser',
                    '-d', domain,
                    passwords_file,
                    users_file,
                    '--dc', dc_ip or domain
                ]
            else:
                raise ValueError(f"Invalid mode: {mode}. Use 'userenum', 'passwordspray', or 'bruteuser'")
            
            command.extend(['>', output_file])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            # Log inicial del ataque
            command_str = ' '.join([str(c) for c in sanitized_cmd if c not in ['>', '2>&1']])
            log_to_workspace(
                workspace_id=workspace_id,
                source='KERBRUTE',
                level='INFO',
                message=f"Iniciando Kerbrute {mode} contra dominio {domain}",
                metadata={
                    'scan_id': scan.id,
                    'domain': domain,
                    'mode': mode,
                    'dc_ip': dc_ip,
                    'command': command_str
                }
            )
            
            logger.info(f"Starting Kerbrute {mode} {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='kerbrute'
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'kerbrute',
                'mode': mode,
                'domain': domain
            }
            
        except Exception as e:
            error_msg = str(e)
            logger.error(f"Error starting Kerbrute: {error_msg}")
            
            # Log de error
            log_to_workspace(
                workspace_id=workspace_id,
                source='KERBRUTE',
                level='ERROR',
                message=f"Error iniciando Kerbrute {mode}: {error_msg}",
                metadata={
                    'scan_id': scan.id if 'scan' in locals() else None,
                    'domain': domain,
                    'mode': mode,
                    'error': error_msg
                }
            )
            
            self.scan_repo.update_status(scan, 'failed', error_msg)
            raise


    def preview_john(
        self,
        hash_file: str,
        workspace_id: int,
        wordlist: Optional[str] = None,
        format: Optional[str] = None,
        rules: bool = False
    ) -> Dict[str, Any]:
        """Preview del comando John the Ripper."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/john_{{scan_id}}.txt'
        
        command = ['john', '--show', hash_file]
        
        if format:
            command.extend(['--format', format])
        
        if wordlist:
            command.extend(['--wordlist', wordlist])
        
        if rules:
            command.append('--rules')
        
        command.extend(['>', output_file])
        command_str = ' '.join([str(c) for c in command])
        
        warnings = []
        if not wordlist:
            warnings.append('Sin wordlist, John usará modo incremental (muy lento)')
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'john',
                'hash_file': hash_file,
                'wordlist': wordlist,
                'format': format,
                'rules': rules
            },
            'estimated_timeout': 7200,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
    
    def preview_hashcat(
        self,
        hash_file: str,
        workspace_id: int,
        mode: int,
        wordlist: str,
        rules_file: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando Hashcat."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/hashcat_{{scan_id}}.txt'
        
        command = [
            'hashcat',
            '-m', str(mode),
            '-a', '0',
            hash_file,
            wordlist,
            '-o', output_file
        ]
        
        if rules_file:
            command.extend(['-r', rules_file])
        
        command_str = ' '.join([str(c) for c in command])
        
        warnings = []
        if mode in [1000, 5600, 1800]:
            warnings.append('Modos de hash complejos pueden tardar mucho tiempo')
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'hashcat',
                'hash_file': hash_file,
                'mode': mode,
                'wordlist': wordlist,
                'rules_file': rules_file
            },
            'estimated_timeout': 10800,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
    
    def preview_kerbrute(
        self,
        domain: str,
        workspace_id: int,
        mode: str,
        users_file: Optional[str] = None,
        passwords_file: Optional[str] = None,
        password: Optional[str] = None,
        dc_ip: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando Kerbrute."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/kerbrute_{{scan_id}}.txt'
        
        command = ['kerbrute', mode, '-d', domain]
        
        if mode == 'userenum' and users_file:
            command.extend(['-users', users_file])
        elif mode == 'bruteuser' and users_file and passwords_file:
            command.extend(['-users', users_file, '-passwords', passwords_file])
        elif mode == 'passwordspray' and users_file and password:
            command.extend(['-users', users_file, '-p', password])
        
        if dc_ip:
            command.extend(['-dc-ip', dc_ip])
        
        command.extend(['>', output_file])
        command_str = ' '.join([str(c) for c in command])
        
        warnings = []
        if mode == 'bruteuser':
            warnings.append('Brute force puede causar bloqueos de cuenta')
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'kerbrute',
                'domain': domain,
                'mode': mode,
                'users_file': users_file,
                'passwords_file': passwords_file,
                'password': '***' if password else None,
                'dc_ip': dc_ip
            },
            'estimated_timeout': 3600,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
