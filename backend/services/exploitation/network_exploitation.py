"""
Network Exploitation Service
============================

Servicios para explotación de red:
- CrackMapExec (AD/Windows exploitation)
- Responder (LLMNR/NBT-NS Poisoning)
"""

import logging
from typing import Dict, Any, Optional
from pathlib import Path

from utils.validators import CommandSanitizer, IPValidator
from .base import BaseExploitationService

logger = logging.getLogger(__name__)


class NetworkExploitationService(BaseExploitationService):
    """Servicio para explotación de red."""
    
    def start_crackmapexec_scan(
        self,
        targets: str,
        protocol: str,
        workspace_id: int,
        user_id: int,
        username: Optional[str] = None,
        password: Optional[str] = None,
        hash: Optional[str] = None,
        domain: Optional[str] = None,
        command: Optional[str] = None,
        shares: bool = False,
        pass_pol: bool = False
    ) -> Dict[str, Any]:
        """
        Escaneo/explotación con CrackMapExec.
        
        Args:
            targets: IPs o rangos (ej: "192.168.1.0/24" o "192.168.1.1,192.168.1.2")
            protocol: smb, winrm, ssh, ldap, mssql
            workspace_id: ID del workspace
            user_id: ID del usuario
            username: Usuario
            password: Password
            hash: NTLM hash (pass-the-hash)
            domain: Dominio AD
            command: Comando a ejecutar (opcional)
            shares: Enumerar shares
            pass_pol: Dump password policy
        """
        IPValidator.validate(targets.split(',')[0])  # Validar primer target
        
        scan = self._create_scan(
            target=targets,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='crackmapexec',
            options={
                'protocol': protocol,
                'command': command
            }
        )
        
        try:
            output_file = str(self.output_dir / f'crackmapexec_{scan.id}.txt')
            
            command_list = ['crackmapexec', protocol, targets]
            
            if username:
                command_list.extend(['-u', username])
            
            if password:
                command_list.extend(['-p', password])
            elif hash:
                command_list.extend(['-H', hash])
            
            if domain:
                command_list.extend(['-d', domain])
            
            if command:
                command_list.extend(['-x', command])
            
            if shares:
                command_list.append('--shares')
            
            if pass_pol:
                command_list.append('--pass-pol')
            
            command_list.extend(['>', output_file])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command_list[0], command_list[1:])
            
            logger.info(f"Starting CrackMapExec {protocol} scan {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='crackmapexec'
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'crackmapexec',
                'protocol': protocol,
                'targets': targets
            }
            
        except Exception as e:
            logger.error(f"Error starting CrackMapExec: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def start_responder(
        self,
        interface: str,
        workspace_id: int,
        user_id: int,
        lm: bool = False
    ) -> Dict[str, Any]:
        """
        LLMNR/NBT-NS Poisoning con Responder.
        
        Args:
            interface: Interfaz de red (ej: "eth0")
            workspace_id: ID del workspace
            user_id: ID del usuario
            lm: Capturar LM hashes (menos seguro pero compatible)
        """
        scan = self._create_scan(
            target=interface,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='responder',
            options={
                'lm': lm
            }
        )
        
        try:
            output_file = str(self.output_dir / f'responder_{scan.id}.txt')
            
            command_list = [
                'responder',
                '-I', interface,
                '-rdwv'  # -r: Respond to requests, -d: Enable answers for netbios domain, -w: Start WPAD rogue proxy, -v: Verbose
            ]
            
            if lm:
                command_list.append('--lm')
            
            command_list.extend(['>', output_file, '2>&1'])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command_list[0], command_list[1:])
            
            logger.info(f"Starting Responder on {interface} {scan.id}")
            
            self._start_scan_thread(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=output_file,
                tool='responder'
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'responder',
                'interface': interface
            }
            
        except Exception as e:
            logger.error(f"Error starting Responder: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise


    def preview_crackmapexec_scan(
        self,
        targets: str,
        protocol: str,
        workspace_id: int,
        username: Optional[str] = None,
        password: Optional[str] = None,
        hash: Optional[str] = None,
        domain: Optional[str] = None,
        command: Optional[str] = None,
        shares: bool = False,
        pass_pol: bool = False
    ) -> Dict[str, Any]:
        """Preview del comando CrackMapExec."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/crackmapexec_{{scan_id}}.txt'
        
        command_list = ['crackmapexec', protocol, targets]
        
        if username:
            command_list.extend(['-u', username])
        
        if password:
            command_list.extend(['-p', '***'])
        elif hash:
            command_list.extend(['-H', hash])
        
        if domain:
            command_list.extend(['-d', domain])
        
        if command:
            command_list.extend(['-x', command])
        
        if shares:
            command_list.append('--shares')
        
        if pass_pol:
            command_list.append('--pass-pol')
        
        command_list.extend(['>', output_file])
        command_str = ' '.join([str(c) for c in command_list])
        
        warnings = []
        if command:
            warnings.append('Comandos remotos pueden ser detectados por EDR')
        
        return {
            'command': command_list,
            'command_string': command_str,
            'parameters': {
                'tool': 'crackmapexec',
                'targets': targets,
                'protocol': protocol,
                'username': username,
                'password': '***' if password else None,
                'hash': hash,
                'domain': domain,
                'command': command,
                'shares': shares,
                'pass_pol': pass_pol
            },
            'estimated_timeout': 1800,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
    
    def preview_responder(
        self,
        interface: str,
        workspace_id: int,
        lm: bool = False
    ) -> Dict[str, Any]:
        """Preview del comando Responder."""
        output_file = f'/workspaces/workspace_{workspace_id}/exploitation/responder_{{scan_id}}.txt'
        
        command = ['responder', '-I', interface]
        
        if lm:
            command.append('-lm')
        
        command.extend(['>', output_file, '2>&1'])
        command_str = ' '.join([str(c) for c in command])
        
        warnings = []
        warnings.append('Responder debe ejecutarse en modo interactivo, puede requerir Ctrl+C para detener')
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'responder',
                'interface': interface,
                'lm': lm
            },
            'estimated_timeout': 3600,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
