"""
SQLMap Scanner
==============

Scanner de inyección SQL usando SQLMap.
"""

import logging
from typing import Dict, Any, Optional

from utils.validators import CommandSanitizer, DomainValidator
from utils.commands import SafeSQLMap
from utils.workspace_logger import log_to_workspace
from ..base import BaseVulnerabilityScanner
from ..executors.scan_executor import ScanExecutor

logger = logging.getLogger(__name__)


class SQLMapScanner(BaseVulnerabilityScanner):
    """Scanner de inyección SQL con SQLMap."""
    
    def __init__(self, scan_repository=None, vuln_repository=None):
        """Inicializa el scanner de SQLMap."""
        super().__init__(scan_repository, vuln_repository)
        self.executor = ScanExecutor(scan_repository)
    
    def start_scan(
        self,
        url: str,
        workspace_id: int,
        user_id: int,
        method: str = 'GET',
        data: Optional[str] = None,
        cookie: Optional[str] = None,
        cookies: Optional[str] = None,
        risk: int = 1,
        level: int = 1,
        dbms: Optional[str] = None,
        database: Optional[str] = None,
        table: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Inicia scan con SQLMap.
        
        Args:
            url: URL objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            method: Método HTTP
            data: POST data
            cookie: Cookie values (deprecated)
            cookies: Cookie values
            risk: Risk level (1-3)
            level: Level (1-5)
            dbms: DBMS específico
            database: Base de datos específica
            table: Tabla específica
        
        Returns:
            Dict con información del scan iniciado
        """
        # Agregar protocolo si falta (como otros scanners)
        original_target = url
        if not url.startswith(('http://', 'https://')):
            url = f'https://{url}'
        
        if not DomainValidator.validate_url(url):
            if url.startswith('https://'):
                url = url.replace('https://', 'http://')
            if not DomainValidator.validate_url(url):
                raise ValueError(f'Invalid URL: {original_target}')
        
        cookie_value = cookies or cookie
        dbms_value = dbms or database
        
        scan = self._create_scan(
            scan_type='vulnerability',
            target=url,
            workspace_id=workspace_id,
            user_id=user_id,
            tool='sqlmap',
            options={
                'method': method,
                'risk': risk,
                'level': level,
                'dbms': dbms_value,
                'database': database,
                'table': table
            }
        )
        
        try:
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_dir = workspace_output_dir / f'sqlmap_{scan.id}'
            output_dir.mkdir(exist_ok=True)
            
            command = SafeSQLMap.build_injection_test(
                url=url,
                output_dir=str(output_dir),
                method=method,
                data=data,
                cookie=cookie_value,
                risk=risk,
                level=level
            )
            
            if dbms_value:
                command.extend(['--dbms', dbms_value])
            
            if database:
                command.extend(['-D', database])
            
            if table:
                command.extend(['-T', table])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='SQLMAP',
                level='INFO',
                message=f"Starting SQLMap scan {scan.id}",
                metadata={'scan_id': scan.id, 'target': url}
            )
            
            self.executor.execute_async(
                scan_id=scan.id,
                command=sanitized_cmd,
                output_file=str(output_dir / 'log'),
                tool='sqlmap',
                workspace_id=workspace_id
            )
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'sqlmap',
                'target': url
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='SQLMAP',
                level='ERROR',
                message=f"Error starting SQLMap scan: {str(e)}",
                metadata={'scan_id': scan.id, 'target': url}
            )
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def preview_scan(
        self,
        url: str,
        workspace_id: int,
        method: str = 'GET',
        data: Optional[str] = None,
        cookie: Optional[str] = None,
        cookies: Optional[str] = None,
        risk: int = 1,
        level: int = 1,
        dbms: Optional[str] = None,
        database: Optional[str] = None,
        table: Optional[str] = None,
        techniques: Optional[list] = None
    ) -> Dict[str, Any]:
        """Preview del comando SQLMap (sin ejecutar)."""
        # Agregar protocolo si falta (como otros scanners)
        original_url = url
        if not url.startswith(('http://', 'https://')):
            url = f'https://{url}'
        
        if not DomainValidator.validate_url(url):
            if url.startswith('https://'):
                url = url.replace('https://', 'http://')
            if not DomainValidator.validate_url(url):
                raise ValueError(f'Invalid URL: {original_url}')
        
        cookie_value = cookies or cookie
        dbms_value = dbms or database
        
        output_dir = f'/workspaces/workspace_{workspace_id}/vuln_scans/sqlmap_{{scan_id}}'
        command = SafeSQLMap.build_injection_test(
            url=url,
            output_dir=output_dir,
            method=method,
            data=data,
            cookie=cookie_value,
            risk=risk,
            level=level
        )
        
        if dbms_value:
            command.extend(['--dbms', dbms_value])
        
        if database:
            command.extend(['-D', database])
        
        if table:
            command.extend(['-T', table])
        
        command_str = ' '.join([str(c) for c in command])
        
        warnings = []
        suggestions = []
        
        if risk > 2 or level > 3:
            warnings.append('Risk/Level alto puede causar que el servidor bloquee las peticiones')
        
        if not cookie_value and method == 'GET':
            suggestions.append('Considera usar cookies para mantener la sesión')
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'sqlmap',
                'url': url,
                'method': method,
                'risk': risk,
                'level': level,
                'dbms': dbms_value,
                'database': database,
                'table': table
            },
            'estimated_timeout': 3600,
            'output_file': f'{output_dir}/log',
            'warnings': warnings,
            'suggestions': suggestions
        }

