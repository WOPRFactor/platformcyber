"""
Vulnerability Assessment Service
=================================

Servicio completo para detección de vulnerabilidades.

Herramientas integradas:
- Nuclei (5000+ templates, CVE, OWASP)
- Nikto (web server scanner)
- SQLMap (SQL injection)
- OWASP ZAP (web application scanner)
- testssl.sh (SSL/TLS testing)
- sslyze (SSL/TLS analysis)
- WhatWeb (technology detection)
- Wappalyzer (technology profiling)
- Dalfox (XSS scanner)
- Commix (command injection)
- tplmap (SSTI scanner)
- SSRFmap (SSRF testing)
"""

import subprocess
import logging
import json
import threading
import shutil
import os
from typing import Dict, Any, List, Optional
from pathlib import Path
from datetime import datetime

from utils.validators import CommandSanitizer, DomainValidator
from utils.commands import SafeSQLMap
from utils.parsers.vuln_parser import (
    NucleiParser, NiktoParser, SQLMapParser,
    TestSSLParser, WhatWebParser, WappalyzerParser, ZAPParser
)
from utils.workspace_logger import log_to_workspace
from repositories import ScanRepository, VulnerabilityRepository
from models import db

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Servicio completo de evaluación de vulnerabilidades."""
    
    def __init__(
        self,
        scan_repository: ScanRepository = None,
        vuln_repository: VulnerabilityRepository = None
    ):
        """Inicializa el servicio."""
        self.scan_repo = scan_repository or ScanRepository()
        self.vuln_repo = vuln_repository or VulnerabilityRepository()
        # output_dir se obtiene dinámicamente por workspace
        # Mantener fallback para compatibilidad (usar tmp del proyecto)
        from utils.workspace_filesystem import PROJECT_TMP_DIR
        self.output_dir = PROJECT_TMP_DIR / 'vuln_scans'
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Parsers
        self.nuclei_parser = NucleiParser()
        self.nikto_parser = NiktoParser()
        self.sqlmap_parser = SQLMapParser()
    
    def _get_workspace_output_dir(self, scan_id: int) -> Path:
        """
        Obtiene directorio de output del workspace para un scan.
        
        Args:
            scan_id: ID del scan
        
        Returns:
            Path al directorio de output del workspace
        """
        from utils.workspace_filesystem import get_workspace_output_dir_from_scan
        return get_workspace_output_dir_from_scan(scan_id, 'vuln_scans')
        self.testssl_parser = TestSSLParser()
        self.whatweb_parser = WhatWebParser()
        self.wappalyzer_parser = WappalyzerParser()
        self.zap_parser = ZAPParser()
    
    # ============================================
    # NUCLEI (5000+ templates)
    # ============================================
    
    def start_nuclei_scan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        severity: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        templates: Optional[str] = None,
        rate_limit: int = 150
    ) -> Dict[str, Any]:
        """
        Inicia scan con Nuclei.
        
        Args:
            target: URL o lista de URLs
            workspace_id: ID del workspace
            user_id: ID del usuario
            severity: Lista de severidades (critical, high, medium, low, info)
            tags: Tags de templates (cve, owasp, tech, etc)
            templates: Path a templates específicos
            rate_limit: Requests por segundo
        """
        # Validar que sea un dominio o URL válido (Nuclei acepta ambos)
        is_url = DomainValidator.validate_url(target)
        is_domain = DomainValidator.is_valid_domain(target)
        
        if not is_url and not is_domain:
            raise ValueError(f'Invalid URL or domain: {target}')
        
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'nuclei',
                'severity': severity,
                'tags': tags,
                'templates': templates,
                'rate_limit': rate_limit
            }
        )
        
        try:
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_file = str(workspace_output_dir / f'nuclei_{scan.id}.jsonl')
            
            command = [
                'nuclei',
                '-u', target,
                '-j',  # JSON output
                '-o', output_file,
                '-rl', str(rate_limit),
                '-stats',  # Show statistics
                '-si', '10'  # Status interval
            ]
            
            # Severidades
            if severity:
                command.extend(['-severity', ','.join(severity)])
            else:
                command.extend(['-severity', 'critical,high,medium,low'])
            
            # Tags
            if tags:
                command.extend(['-tags', ','.join(tags)])
            
            # Templates específicos
            # Si se proporciona una ruta o archivo específico, usarlo
            # Si no, Nuclei usará automáticamente todos los templates disponibles
            if templates:
                # Si es una ruta válida, usarla
                from pathlib import Path
                template_path = Path(templates)
                if template_path.exists():
                    command.extend(['-t', str(template_path)])
                else:
                    # Si no existe, intentar como nombre de template o ruta relativa
                    command.extend(['-t', templates])
            # Si no hay templates, Nuclei usa sus templates por defecto automáticamente
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='NUCLEI',
                level='INFO',
                message=f"Starting Nuclei scan {scan.id}",
                metadata={'scan_id': scan.id, 'target': target}
            )
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_file, 'nuclei')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'nuclei',
                'target': target
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='NUCLEI',
                level='ERROR',
                message=f"Error starting Nuclei scan: {str(e)}",
                metadata={'scan_id': scan.id, 'target': target}
            )
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # NIKTO (Web server scanner)
    # ============================================
    
    def start_nikto_scan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        port: int = 80,
        ssl: bool = False,
        tuning: Optional[str] = None,
        maxtime: Optional[str] = None,
        maxtests: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Inicia scan con Nikto.
        
        Args:
            target: Host objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            port: Puerto
            ssl: Usar SSL/TLS
            tuning: Tuning options (1-9,0,a-e,x) - Categorías de tests a ejecutar
                    Ejemplos: "1,2,3" (solo esas), "x1" (todas excepto 1)
            maxtime: Tiempo máximo de ejecución (formato: "1h", "60m", "3600s")
            maxtests: Número máximo de tests a ejecutar
            timeout: Timeout por request en segundos (default: 10)
        """
        CommandSanitizer.validate_target(target)
        
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'nikto',
                'port': port,
                'ssl': ssl,
                'tuning': tuning,
                'maxtime': maxtime,
                'maxtests': maxtests,
                'timeout': timeout
            }
        )
        
        try:
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_file = str(workspace_output_dir / f'nikto_{scan.id}')
            
            command = [
                'nikto',
                '-h', target,
                '-p', str(port),
                '-Format', 'json',
                '-output', f'{output_file}.json'
            ]
            
            if ssl:
                command.append('-ssl')
            
            # Opciones para limitar el alcance del scan
            if tuning:
                command.extend(['-Tuning', tuning])
            
            # -maxtime: Limita el tiempo máximo de ejecución
            # Formato: "1h", "60m", "3600s"
            if maxtime:
                command.extend(['-maxtime', maxtime])
            
            # -maxtests: Limita el número máximo de tests a ejecutar
            if maxtests:
                command.extend(['-maxtests', str(maxtests)])
            
            # -timeout: Timeout por request (acelera el scan si el servidor es lento)
            if timeout:
                command.extend(['-timeout', str(timeout)])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='NIKTO',
                level='INFO',
                message=f"Starting Nikto scan {scan.id}",
                metadata={'scan_id': scan.id, 'target': target, 'command': ' '.join(sanitized_cmd)}
            )
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, f'{output_file}.json', 'nikto')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'nikto',
                'target': target
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='NIKTO',
                level='ERROR',
                message=f"Error starting Nikto scan: {str(e)}",
                metadata={'scan_id': scan.id, 'target': target}
            )
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # NMAP VULN SCAN (Vulnerability scripts)
    # ============================================
    
    def start_nmap_vuln_scan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        ports: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Inicia scan de vulnerabilidades con Nmap usando scripts NSE.
        
        Args:
            target: Host objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            ports: Puertos a escanear (opcional, default: top 1000)
        
        Returns:
            Dict con información del scan iniciado
        """
        CommandSanitizer.validate_target(target)
        
        # Usar ScanningService para el scan de Nmap vuln
        from services import ScanningService
        scanning_service = ScanningService()
        
        return scanning_service.start_nmap_scan(
            target=target,
            scan_type='vuln',
            workspace_id=workspace_id,
            user_id=user_id,
            ports=ports
        )
    
    # ============================================
    # SQLMAP (SQL Injection)
    # ============================================
    
    def start_sqlmap_scan(
        self,
        url: str,
        workspace_id: int,
        user_id: int,
        method: str = 'GET',
        data: Optional[str] = None,
        cookie: Optional[str] = None,
        cookies: Optional[str] = None,
        risk: int = 1,
        level: int = 1,
        dbms: Optional[str] = None,
        database: Optional[str] = None,
        table: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Inicia scan con SQLMap.
        
        Args:
            url: URL objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            method: Método HTTP
            data: POST data
            cookie: Cookie values (deprecated, usar cookies)
            cookies: Cookie values
            risk: Risk level (1-3)
            level: Level (1-5)
            dbms: DBMS específico
            database: Base de datos específica (opcional)
            table: Tabla específica (opcional)
        """
        if not DomainValidator.validate_url(url):
            raise ValueError(f'Invalid URL: {url}')
        
        # Usar cookies si está disponible, sino usar cookie (backward compatibility)
        cookie_value = cookies or cookie
        
        # Usar database como dbms si dbms no está especificado
        dbms_value = dbms or database
        
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=url,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'sqlmap',
                'method': method,
                'risk': risk,
                'level': level,
                'dbms': dbms_value,
                'database': database,
                'table': table
            }
        )
        
        try:
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_dir = workspace_output_dir / f'sqlmap_{scan.id}'
            output_dir.mkdir(exist_ok=True)
            
            # Usar SafeSQLMap para prevenir --dump-all
            command = SafeSQLMap.build_injection_test(
                url=url,
                output_dir=str(output_dir),
                method=method,
                data=data,
                cookie=cookie_value,
                risk=risk,
                level=level
            )
            
            if dbms_value:
                command.extend(['--dbms', dbms_value])
            
            if database:
                command.extend(['-D', database])
            
            if table:
                command.extend(['-T', table])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='SQLMAP',
                level='INFO',
                message=f"Starting SQLMap scan {scan.id}",
                metadata={'scan_id': scan.id, 'target': url}
            )
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, str(output_dir / 'log'), 'sqlmap')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'sqlmap',
                'target': url
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='SQLMAP',
                level='ERROR',
                message=f"Error starting SQLMap scan: {str(e)}",
                metadata={'scan_id': scan.id, 'target': url}
            )
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # OWASP ZAP (Web Application Scanner)
    # ============================================
    
    def start_zap_scan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        scan_type: str = 'baseline',
        ajax_spider: bool = False
    ) -> Dict[str, Any]:
        """
        Inicia scan con OWASP ZAP.
        
        Args:
            target: URL objetivo (puede ser dominio o URL completa)
            workspace_id: ID del workspace
            user_id: ID del usuario
            scan_type: baseline, full, api
            ajax_spider: Usar AJAX spider
        """
        # Agregar protocolo si no lo tiene
        original_target = target
        if not target.startswith(('http://', 'https://')):
            # Intentar HTTPS primero
            target = f'https://{target}'
            logger.info(f"ZAP: Agregado protocolo HTTPS a target: {original_target} -> {target}")
        
        if not DomainValidator.validate_url(target):
            # Si HTTPS falla, intentar HTTP
            if target.startswith('https://'):
                target = target.replace('https://', 'http://')
                logger.info(f"ZAP: Cambiado a HTTP: {target}")
            if not DomainValidator.validate_url(target):
                logger.error(f"ZAP: URL inválida después de agregar protocolo: {target} (original: {original_target})")
                raise ValueError(f'Invalid URL: {original_target}. Intenté agregar protocolo pero sigue siendo inválido.')
        
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'zap',
                'scan_type': scan_type,
                'ajax_spider': ajax_spider
            }
        )
        
        try:
            import shutil
            
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_file = str(workspace_output_dir / f'zap_{scan.id}')
            
            # Buscar scripts de ZAP en ubicaciones comunes
            zap_baseline = shutil.which('zap-baseline.py')
            zap_full = shutil.which('zap-full-scan.py')
            zap_api = shutil.which('zap-api-scan.py')
            
            # Si no están en PATH, buscar en ubicaciones comunes
            if not zap_baseline:
                import os
                from utils.workspace_filesystem import PROJECT_TMP_DIR
                home_dir = os.path.expanduser('~')
                common_paths = [
                    f'{home_dir}/.local/bin/zap-baseline.py',
                    '/usr/share/zaproxy/zap-baseline.py',
                    '/opt/zaproxy/zap-baseline.py',
                    '/usr/local/bin/zap-baseline.py',
                    '/usr/bin/zap-baseline.py',
                    str(PROJECT_TMP_DIR / 'zap-baseline.py')
                ]
                for path in common_paths:
                    if Path(path).exists():
                        zap_baseline = path
                        break
            
            if not zap_full:
                import os
                from utils.workspace_filesystem import PROJECT_TMP_DIR
                home_dir = os.path.expanduser('~')
                common_paths = [
                    f'{home_dir}/.local/bin/zap-full-scan.py',
                    '/usr/share/zaproxy/zap-full-scan.py',
                    '/opt/zaproxy/zap-full-scan.py',
                    '/usr/local/bin/zap-full-scan.py',
                    '/usr/bin/zap-full-scan.py',
                    str(PROJECT_TMP_DIR / 'zap-full-scan.py')
                ]
                for path in common_paths:
                    if Path(path).exists():
                        zap_full = path
                        break
            
            if not zap_api:
                import os
                from utils.workspace_filesystem import PROJECT_TMP_DIR
                home_dir = os.path.expanduser('~')
                common_paths = [
                    f'{home_dir}/.local/bin/zap-api-scan.py',
                    '/usr/share/zaproxy/zap-api-scan.py',
                    '/opt/zaproxy/zap-api-scan.py',
                    '/usr/local/bin/zap-api-scan.py',
                    '/usr/bin/zap-api-scan.py',
                    str(PROJECT_TMP_DIR / 'zap-api-scan.py')
                ]
                for path in common_paths:
                    if Path(path).exists():
                        zap_api = path
                        break
            
            # Construir comando según tipo
            if scan_type == 'baseline':
                if not zap_baseline:
                    raise ValueError(
                        'zap-baseline.py no encontrado. '
                        'Instala ZAP: sudo apt install zaproxy o descarga desde https://www.zaproxy.org/download/'
                    )
                command = [
                    zap_baseline,
                    '-t', target,
                    '-J', f'{output_file}.json',
                    '-r', f'{output_file}.html'
                ]
            
            elif scan_type == 'full':
                if not zap_full:
                    raise ValueError(
                        'zap-full-scan.py no encontrado. '
                        'Instala ZAP: sudo apt install zaproxy o descarga desde https://www.zaproxy.org/download/'
                    )
                command = [
                    zap_full,
                    '-t', target,
                    '-J', f'{output_file}.json',
                    '-r', f'{output_file}.html'
                ]
            
            elif scan_type == 'api':
                if not zap_api:
                    raise ValueError(
                        'zap-api-scan.py no encontrado. '
                        'Instala ZAP: sudo apt install zaproxy o descarga desde https://www.zaproxy.org/download/'
                    )
                command = [
                    zap_api,
                    '-t', target,
                    '-f', 'openapi',
                    '-J', f'{output_file}.json',
                    '-r', f'{output_file}.html'
                ]
            
            else:
                raise ValueError(f'Invalid scan_type: {scan_type}')
            
            if ajax_spider:
                command.append('-j')
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='ZAP',
                level='INFO',
                message=f"Starting ZAP {scan_type} scan {scan.id}",
                metadata={'scan_id': scan.id, 'target': target, 'scan_type': scan_type}
            )
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, f'{output_file}.json', 'zap')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'zap',
                'scan_type': scan_type,
                'target': target
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='ZAP',
                level='ERROR',
                message=f"Error starting ZAP scan: {str(e)}",
                metadata={'scan_id': scan.id, 'target': target}
            )
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # testssl.sh (SSL/TLS Testing)
    # ============================================
    
    def start_testssl_scan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        port: int = 443
    ) -> Dict[str, Any]:
        """
        Inicia análisis SSL/TLS con testssl.sh.
        
        Args:
            target: Host objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            port: Puerto SSL/TLS
        """
        CommandSanitizer.validate_target(target)
        
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'testssl',
                'port': port
            }
        )
        
        try:
            # Buscar testssl.sh en el PATH
            testssl_path = shutil.which('testssl.sh')
            if not testssl_path:
                # Intentar ubicaciones comunes
                common_paths = [
                    '/usr/local/bin/testssl.sh',
                    '/opt/testssl.sh/testssl.sh',
                    os.path.expanduser('~/testssl.sh'),
                    os.path.expanduser('~/.local/bin/testssl.sh')
                ]
                for path in common_paths:
                    if os.path.exists(path) and os.access(path, os.X_OK):
                        testssl_path = path
                        break
            
            if not testssl_path:
                error_msg = "testssl.sh no está instalado. Instala con: git clone --depth 1 https://github.com/drwetter/testssl.sh.git /opt/testssl.sh && ln -s /opt/testssl.sh/testssl.sh /usr/local/bin/testssl.sh"
                log_to_workspace(
                    workspace_id=workspace_id,
                    source='TESTSSL',
                    level='ERROR',
                    message=error_msg,
                    metadata={'scan_id': scan.id, 'target': target}
                )
                self.scan_repo.update_status(scan, 'failed', error_msg)
                raise ValueError(error_msg)
            
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_file = str(workspace_output_dir / f'testssl_{scan.id}')
            
            command = [
                testssl_path,
                '--jsonfile', f'{output_file}.json',
                '--htmlfile', f'{output_file}.html',
                f'{target}:{port}'
            ]
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='TESTSSL',
                level='INFO',
                message=f"Starting testssl scan {scan.id}",
                metadata={'scan_id': scan.id, 'target': target}
            )
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, f'{output_file}.json', 'testssl')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'testssl',
                'target': target
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='TESTSSL',
                level='ERROR',
                message=f"Error starting testssl scan: {str(e)}",
                metadata={'scan_id': scan.id, 'target': target}
            )
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # WhatWeb (Technology Detection)
    # ============================================
    
    def start_whatweb_scan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        aggression: int = 1
    ) -> Dict[str, Any]:
        """
        Detecta tecnologías con WhatWeb.
        
        Args:
            target: URL objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            aggression: Nivel de agresión (1-4)
        """
        if not DomainValidator.validate_url(target):
            raise ValueError(f'Invalid URL: {target}')
        
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'whatweb',
                'aggression': aggression
            }
        )
        
        try:
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_file = str(workspace_output_dir / f'whatweb_{scan.id}.json')
            
            command = [
                'whatweb',
                target,
                '-a', str(aggression),
                '--log-json', output_file
            ]
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='WHATWEB',
                level='INFO',
                message=f"Starting WhatWeb scan {scan.id}",
                metadata={'scan_id': scan.id, 'target': target}
            )
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_file, 'whatweb')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'whatweb',
                'target': target
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='WHATWEB',
                level='ERROR',
                message=f"Error starting WhatWeb scan: {str(e)}",
                metadata={'scan_id': scan.id, 'target': target}
            )
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # Dalfox (XSS Scanner)
    # ============================================
    
    def start_dalfox_scan(
        self,
        url: str,
        workspace_id: int,
        user_id: int,
        method: str = 'GET',
        data: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Escanea XSS con Dalfox.
        
        Args:
            url: URL objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            method: Método HTTP
            data: POST data
        """
        if not DomainValidator.validate_url(url):
            raise ValueError(f'Invalid URL: {url}')
        
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=url,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'dalfox',
                'method': method
            }
        )
        
        try:
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_file = str(workspace_output_dir / f'dalfox_{scan.id}.json')
            
            command = [
                'dalfox',
                'url', url,
                '-o', output_file,
                '--format', 'json'
            ]
            
            if method == 'POST' and data:
                command.extend(['--data', data])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='DALFOX',
                level='INFO',
                message=f"Starting Dalfox scan {scan.id}",
                metadata={'scan_id': scan.id, 'target': url}
            )
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_file, 'dalfox')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'dalfox',
                'target': url
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='DALFOX',
                level='ERROR',
                message=f"Error starting Dalfox scan: {str(e)}",
                metadata={'scan_id': scan.id, 'target': url if 'url' in locals() else 'unknown'}
            )
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # OBTENER RESULTADOS
    # ============================================
    
    def get_scan_results(self, scan_id: int) -> Dict[str, Any]:
        """
        Obtiene y parsea resultados del scan.
        
        Args:
            scan_id: ID del escaneo
        
        Returns:
            Dict con resultados parseados
        """
        scan = self.scan_repo.find_by_id(scan_id)
        
        if not scan:
            raise ValueError(f'Scan {scan_id} not found')
        
        if scan.status != 'completed':
            return {
                'scan_id': scan_id,
                'status': scan.status,
                'message': 'Scan not completed yet'
            }
        
        tool = scan.options.get('tool')
        
        try:
            if tool == 'nuclei':
                output_file = self.output_dir / f'nuclei_{scan_id}.jsonl'
                with open(output_file, 'r') as f:
                    results = self.nuclei_parser.parse_jsonl(f.read())
            
            elif tool == 'nikto':
                output_file = self.output_dir / f'nikto_{scan_id}.json'
                with open(output_file, 'r') as f:
                    results = self.nikto_parser.parse_json(f.read())
            
            elif tool == 'sqlmap':
                output_dir = self.output_dir / f'sqlmap_{scan_id}'
                log_file = output_dir / 'log'
                with open(log_file, 'r') as f:
                    results = self.sqlmap_parser.parse_output(f.read())
            
            elif tool == 'zap':
                output_file = self.output_dir / f'zap_{scan_id}.json'
                results = self.zap_parser.parse_json(str(output_file))
            
            elif tool == 'testssl':
                output_file = self.output_dir / f'testssl_{scan_id}.json'
                results = self.testssl_parser.parse_json(str(output_file))
            
            elif tool == 'whatweb':
                output_file = self.output_dir / f'whatweb_{scan_id}.json'
                with open(output_file, 'r') as f:
                    results = self.whatweb_parser.parse_json(f.read())
            
            else:
                results = {'error': f'Unknown tool: {tool}'}
            
            return {
                'scan_id': scan_id,
                'status': 'completed',
                'tool': tool,
                'results': results,
                'scan_info': {
                    'target': scan.target,
                    'started_at': scan.started_at.isoformat() if scan.started_at else None,
                    'completed_at': scan.completed_at.isoformat() if scan.completed_at else None
                }
            }
            
        except Exception as e:
            # Log error pero no fallar - el scan puede continuar
            scan = self.scan_repo.find_by_id(scan_id)
            if scan:
                log_to_workspace(
                    workspace_id=scan.workspace_id,
                    source='BACKEND',
                    level='WARNING',
                    message=f"Error parsing vuln scan results {scan_id}: {str(e)}",
                    metadata={'scan_id': scan_id}
                )
            return {
                'scan_id': scan_id,
                'error': f'Failed to parse results: {str(e)}'
            }
    
    # ============================================
    # HELPERS PRIVADOS
    # ============================================
    
    def _execute_scan(
        self,
        scan_id: int,
        command: list,
        output_file: str,
        tool: str
    ) -> None:
        """Ejecuta scan en thread separado."""
        from celery_app import get_flask_app
        
        app = get_flask_app()
        
        with app.app_context():
            try:
                from models import Scan
                scan = Scan.query.get(scan_id)
                if scan:
                    log_to_workspace(
                        workspace_id=scan.workspace_id,
                        source=tool.upper(),
                        level='INFO',
                        message=f"Executing {tool} scan {scan_id}",
                        metadata={'scan_id': scan_id, 'command': ' '.join(command)}
                    )
                
                # Timeouts según herramienta
                timeout_map = {
                    'nuclei': 3600,    # 1 hora
                    'nikto': 3600,     # 1 hora (aumentado de 30 min para sitios grandes)
                    'sqlmap': 3600,    # 1 hora
                    'zap': 7200,       # 2 horas
                    'testssl': 600,    # 10 minutos
                    'whatweb': 300,    # 5 minutos
                    'dalfox': 1800     # 30 minutos
                }
                timeout = timeout_map.get(tool, 1800)
                
                # Para herramientas que no reportan progreso, usar subprocess.Popen
                # y actualizar progreso basado en tiempo transcurrido
                import time
                import signal
                import os
                
                # Preparar entorno para ejecución
                env = CommandSanitizer.get_safe_env()
                
                # Para WhatWeb, agregar RUBYLIB para encontrar los módulos Ruby
                if tool == 'whatweb':
                    env['RUBYLIB'] = '/usr/lib/ruby/vendor_ruby:' + env.get('RUBYLIB', '')
                
                # Para ZAP, asegurar que Python encuentre zap_common
                if tool == 'zap':
                    # Obtener directorio donde está el script de ZAP
                    script_path = command[0] if command else None
                    if script_path and Path(script_path).exists():
                        script_dir = str(Path(script_path).parent)
                        # Agregar directorio del script al PYTHONPATH
                        pythonpath = env.get('PYTHONPATH', '')
                        if pythonpath:
                            env['PYTHONPATH'] = f'{script_dir}:{pythonpath}'
                        else:
                            env['PYTHONPATH'] = script_dir
                        # También agregar ~/.local/bin al PATH si no está
                        current_path = env.get('PATH', '')
                        home_bin = os.path.expanduser('~/.local/bin')
                        if home_bin not in current_path:
                            env['PATH'] = f'{home_bin}:{current_path}'
                
                process = subprocess.Popen(
                    command,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    env=env
                )
                
                # Guardar PID para poder cancelar
                scan = self.scan_repo.find_by_id(scan_id)
                if scan and scan.options:
                    scan.options['pid'] = process.pid
                    # Actualizar opciones con PID
                    from repositories import ScanRepository
                    ScanRepository().update_options(scan, scan.options)
                
                start_time = time.time()
                last_update = start_time
                
                # Actualizar progreso durante la ejecución
                while process.poll() is None:
                    elapsed = time.time() - start_time
                    
                    # Actualizar progreso cada 10 segundos
                    if time.time() - last_update >= 10:
                        # Calcular progreso basado en tiempo transcurrido
                        # Iniciar en 5% y avanzar hasta 85% basado en tiempo
                        progress = min(5 + int((elapsed / timeout) * 80), 85)
                        
                        elapsed_min = int(elapsed / 60)
                        elapsed_sec = int(elapsed % 60)
                        status_msg = f"Ejecutando {tool}... ({elapsed_min}m {elapsed_sec}s)"
                        
                        scan = self.scan_repo.find_by_id(scan_id)
                        if scan:
                            self.scan_repo.update_progress(scan, progress, status_msg)
                        last_update = time.time()
                    
                    # Verificar timeout
                    if elapsed > timeout:
                        process.terminate()
                        try:
                            process.wait(timeout=5)
                        except subprocess.TimeoutExpired:
                            process.kill()
                        raise subprocess.TimeoutExpired(command, timeout)
                    
                    time.sleep(2)  # Verificar cada 2 segundos
                
                # Obtener resultado
                stdout, stderr = process.communicate()
                result = type('Result', (), {
                    'returncode': process.returncode,
                    'stdout': stdout,
                    'stderr': stderr
                })()
                
                # Para herramientas que escriben a archivo (como Nikto, Nuclei), verificar el archivo
                # Para otras herramientas, guardar stdout si no se guardó
                if not Path(output_file).exists() and result.stdout:
                    with open(output_file, 'w') as f:
                        f.write(result.stdout)
                
                # Esperar un momento para que las herramientas que escriben directamente a archivo terminen de escribir
                # (especialmente importante para nikto y nuclei que usan -output/-o)
                if tool in ['nikto', 'nuclei']:
                    import time
                    time.sleep(1)  # Esperar 1 segundo para que termine de escribir
                
                # Verificar si el archivo de salida existe y tiene contenido válido
                output_path = Path(output_file)
                file_exists = output_path.exists()
                file_size = output_path.stat().st_size if file_exists else 0
                file_is_empty = file_exists and file_size == 0
                
                # Para herramientas que escriben directamente a archivo (nikto, nuclei),
                # verificar que el archivo tenga contenido válido
                file_has_valid_content = False
                if file_exists and file_size > 0:
                    try:
                        # Leer una muestra del archivo para verificar que tenga contenido válido
                        with open(output_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content_preview = f.read(1000)  # Leer primeros 1000 caracteres
                            # Verificar que no sea solo caracteres de control o espacios
                            if content_preview.strip() and len(content_preview.strip()) > 2:
                                file_has_valid_content = True
                    except Exception as e:
                        log_to_workspace(
                            workspace_id=scan.workspace_id if scan else None,
                            source=tool.upper(),
                            level='WARNING',
                            message=f"Error reading output file {output_file}: {str(e)}",
                            metadata={'scan_id': scan_id, 'error': str(e)}
                        )
                
                scan = self.scan_repo.find_by_id(scan_id)
                
                # Log stderr siempre para debugging (especialmente importante para Nikto y Nuclei)
                if result.stderr:
                    log_to_workspace(
                        workspace_id=scan.workspace_id if scan else None,
                        source=tool.upper(),
                        level='DEBUG',
                        message=f"{tool} scan {scan_id} stderr: {result.stderr[:1000]}",
                        metadata={'scan_id': scan_id, 'stderr': result.stderr[:500]}
                    )
                
                # Log stdout también para debugging
                if result.stdout:
                    log_to_workspace(
                        workspace_id=scan.workspace_id if scan else None,
                        source=tool.upper(),
                        level='DEBUG',
                        message=f"{tool} scan {scan_id} stdout: {result.stdout[:500]}",
                        metadata={'scan_id': scan_id}
                    )
                
                if result.returncode == 0:
                    # CASO ESPECIAL: Nuclei - archivo vacío es válido si no encontró vulnerabilidades
                    if tool == 'nuclei' and file_is_empty:
                        # Verificar en stderr si el scan completó sin errores
                        stderr_lower = (result.stderr or '').lower()
                        stdout_lower = (result.stdout or '').lower()
                        
                        # Si el mensaje indica "0 matches found" o "scan completed", es éxito
                        if ('0 matches found' in stderr_lower or 
                            'scan completed' in stderr_lower or
                            '"matched":"0"' in stdout_lower):
                            # Archivo vacío es válido para nuclei cuando no hay resultados
                            self.scan_repo.update_status(scan, 'completed')
                            self.scan_repo.update_progress(scan, 100, "Scan completed - No vulnerabilities found")
                            log_to_workspace(
                                workspace_id=scan.workspace_id if scan else None,
                                source=tool.upper(),
                                level='SUCCESS',
                                message=f"{tool} scan {scan_id} completed successfully. No vulnerabilities found (0 matches).",
                                metadata={'scan_id': scan_id, 'output_size': 0, 'matches': 0}
                            )
                        else:
                            # Archivo vacío pero no hay indicación de éxito
                            error_msg = f"Output file is empty. stderr: {result.stderr[:200] if result.stderr else 'No stderr'}"
                            self.scan_repo.update_status(scan, 'failed', error_msg)
                            log_to_workspace(
                                workspace_id=scan.workspace_id if scan else None,
                                source=tool.upper(),
                                level='ERROR',
                                message=f"{tool} scan {scan_id} completed but output file is empty: {error_msg}",
                                metadata={'scan_id': scan_id, 'error': error_msg, 'stderr': result.stderr}
                            )
                    
                    # CASO ESPECIAL: Nikto - verificar que el JSON esté completo
                    elif tool == 'nikto' and file_exists:
                        try:
                            with open(output_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                                # Verificar que sea un JSON válido (debe empezar con '[' o '{' y terminar con ']' o '}')
                                content_stripped = content.strip()
                                if (content_stripped.startswith('[') and content_stripped.endswith(']')) or \
                                   (content_stripped.startswith('{') and content_stripped.endswith('}')):
                                    # Intentar parsear JSON para verificar que sea válido
                                    import json
                                    json.loads(content)
                                    # JSON válido
                                    self.scan_repo.update_status(scan, 'completed')
                                    self.scan_repo.update_progress(scan, 100, result.stdout[:1000] if result.stdout else "Completed")
                                    log_to_workspace(
                                        workspace_id=scan.workspace_id if scan else None,
                                        source=tool.upper(),
                                        level='SUCCESS',
                                        message=f"{tool} scan {scan_id} completed successfully. Output size: {file_size} bytes",
                                        metadata={'scan_id': scan_id, 'output_size': file_size}
                                    )
                                else:
                                    # JSON incompleto o mal formado
                                    error_msg = f"JSON file is incomplete or malformed. Content: {content_stripped[:100]}"
                                    self.scan_repo.update_status(scan, 'failed', error_msg)
                                    log_to_workspace(
                                        workspace_id=scan.workspace_id if scan else None,
                                        source=tool.upper(),
                                        level='ERROR',
                                        message=f"{tool} scan {scan_id} completed but JSON is incomplete: {error_msg}",
                                        metadata={'scan_id': scan_id, 'error': error_msg, 'file_size': file_size, 'content_preview': content_stripped[:200]}
                                    )
                        except json.JSONDecodeError as e:
                            # JSON inválido
                            error_msg = f"JSON file is invalid: {str(e)}"
                            self.scan_repo.update_status(scan, 'failed', error_msg)
                            log_to_workspace(
                                workspace_id=scan.workspace_id if scan else None,
                                source=tool.upper(),
                                level='ERROR',
                                message=f"{tool} scan {scan_id} completed but JSON is invalid: {error_msg}",
                                metadata={'scan_id': scan_id, 'error': error_msg, 'file_size': file_size}
                            )
                        except Exception as e:
                            # Error al leer/validar archivo
                            error_msg = f"Error validating output file: {str(e)}"
                            self.scan_repo.update_status(scan, 'failed', error_msg)
                            log_to_workspace(
                                workspace_id=scan.workspace_id if scan else None,
                                source=tool.upper(),
                                level='ERROR',
                                message=f"{tool} scan {scan_id} error validating output: {error_msg}",
                                metadata={'scan_id': scan_id, 'error': error_msg}
                            )
                    
                    # Para otras herramientas, verificar contenido válido
                    elif file_is_empty or not file_has_valid_content:
                        # Intentar leer stderr para obtener más información
                        stderr_info = result.stderr[:500] if result.stderr else 'No stderr output'
                        stdout_info = result.stdout[:200] if result.stdout else 'No stdout output'
                        
                        error_msg = f"Output file is empty or invalid. File size: {file_size} bytes. stderr: {stderr_info}. stdout: {stdout_info}"
                        
                        self.scan_repo.update_status(scan, 'failed', error_msg)
                        log_to_workspace(
                            workspace_id=scan.workspace_id if scan else None,
                            source=tool.upper(),
                            level='ERROR',
                            message=f"{tool} scan {scan_id} completed but output file is empty or invalid: {error_msg}",
                            metadata={
                                'scan_id': scan_id, 
                                'error': error_msg, 
                                'stderr': result.stderr,
                                'stdout': result.stdout[:500],
                                'file_size': file_size,
                                'file_exists': file_exists
                            }
                        )
                    else:
                        self.scan_repo.update_status(scan, 'completed')
                        self.scan_repo.update_progress(scan, 100, result.stdout[:1000] if result.stdout else "Completed")
                        log_to_workspace(
                            workspace_id=scan.workspace_id if scan else None,
                            source=tool.upper(),
                            level='SUCCESS',
                            message=f"{tool} scan {scan_id} completed successfully. Output size: {file_size} bytes",
                            metadata={'scan_id': scan_id, 'output_size': file_size}
                        )
                else:
                    error_msg = result.stderr or result.stdout or "Unknown error"
                    self.scan_repo.update_status(scan, 'failed', error_msg)
                    log_to_workspace(
                        workspace_id=scan.workspace_id,
                        source=tool.upper(),
                        level='ERROR',
                        message=f"{tool} scan {scan_id} failed: {error_msg[:500]}",
                        metadata={'scan_id': scan_id, 'error': error_msg, 'returncode': result.returncode, 'stderr': result.stderr, 'stdout': result.stdout[:500]}
                    )
                    
            except subprocess.TimeoutExpired:
                scan = self.scan_repo.find_by_id(scan_id)
                self.scan_repo.update_status(scan, 'failed', f'Timeout ({timeout}s)')
                if scan:
                    log_to_workspace(
                        workspace_id=scan.workspace_id,
                        source=tool.upper(),
                        level='ERROR',
                        message=f"{tool} scan {scan_id} timeout after {timeout}s",
                        metadata={'scan_id': scan_id, 'timeout': timeout}
                    )
                
            except Exception as e:
                scan = self.scan_repo.find_by_id(scan_id)
                self.scan_repo.update_status(scan, 'failed', str(e))
                if scan:
                    log_to_workspace(
                        workspace_id=scan.workspace_id,
                        source=tool.upper(),
                        level='ERROR',
                        message=f"{tool} scan {scan_id} error: {str(e)}",
                        metadata={'scan_id': scan_id, 'error': str(e)}
                    )
    
    # ============================================
    # COMPREHENSIVE ASSESSMENT (Multiple tools)
    # ============================================
    
    def start_comprehensive_scan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        include_nikto: bool = True,
        include_nmap: bool = True,
        include_nuclei: bool = True
    ) -> Dict[str, Any]:
        """
        Inicia evaluación completa de vulnerabilidades con múltiples herramientas.
        
        Args:
            target: URL o host objetivo
            workspace_id: ID del workspace
            user_id: ID del usuario
            include_nikto: Incluir escaneo Nikto
            include_nmap: Incluir escaneo Nmap vuln
            include_nuclei: Incluir escaneo Nuclei
        
        Returns:
            Dict con información de los escaneos iniciados
        """
        CommandSanitizer.validate_target(target)
        
        scans_started = []
        
        try:
            # 1. Nikto scan
            if include_nikto:
                # Determinar protocolo y puerto
                has_protocol = target.startswith('http://') or target.startswith('https://')
                is_https = target.startswith('https://')
                port = 443 if is_https else 80
                
                nikto_result = self.start_nikto_scan(
                    target=target,
                    workspace_id=workspace_id,
                    user_id=user_id,
                    port=port,
                    ssl=is_https
                )
                scans_started.append({
                    'tool': 'nikto',
                    'scan_id': nikto_result['scan_id'],
                    'status': nikto_result['status']
                })
            
            # 2. Nmap vuln scan (usando ScanningService)
            if include_nmap:
                from services import ScanningService
                scanning_service = ScanningService()
                
                nmap_result = scanning_service.start_nmap_scan(
                    target=target,
                    scan_type='vuln',
                    workspace_id=workspace_id,
                    user_id=user_id
                )
                scans_started.append({
                    'tool': 'nmap',
                    'scan_id': nmap_result['scan_id'],
                    'status': nmap_result['status']
                })
            
            # 3. Nuclei scan
            if include_nuclei:
                nuclei_result = self.start_nuclei_scan(
                    target=target,
                    workspace_id=workspace_id,
                    user_id=user_id,
                    severity=['critical', 'high', 'medium']
                )
                scans_started.append({
                    'tool': 'nuclei',
                    'scan_id': nuclei_result['scan_id'],
                    'status': nuclei_result['status']
                })
            
            return {
                'message': 'Comprehensive vulnerability assessment started',
                'target': target,
                'scans': scans_started,
                'total_scans': len(scans_started),
                'status': 'running'
            }
            
        except Exception as e:
            log_to_workspace(
                workspace_id=workspace_id,
                source='BACKEND',
                level='ERROR',
                message=f"Error starting comprehensive scan: {str(e)}",
                metadata={'target': target}
            )
            raise ValueError(f'Failed to start comprehensive scan: {str(e)}')

    def start_wpscan(
        self,
        target: str,
        workspace_id: int,
        user_id: int,
        enumerate: Optional[str] = None,
        plugins_detection: str = 'passive',
        api_token: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Inicia scan con WPScan (WordPress Security Scanner).
        
        Args:
            target: URL objetivo (debe ser un sitio WordPress)
            workspace_id: ID del workspace
            user_id: ID del usuario
            enumerate: Enumerar (u=usuarios, p=plugins, t=themes, tt=timthumbs, cb=config-backups, d=db-exports, u1-10=usuarios específicos)
            plugins_detection: Detección de plugins ('passive', 'aggressive', 'mixed')
            api_token: API token de WPScan (opcional, para actualizar base de datos)
        """
        # Agregar protocolo si no lo tiene
        original_target = target
        if not target.startswith(('http://', 'https://')):
            target = f'https://{target}'
            logger.info(f"WPScan: Agregado protocolo HTTPS a target: {original_target} -> {target}")
        
        if not DomainValidator.validate_url(target):
            # Si HTTPS falla, intentar HTTP
            if target.startswith('https://'):
                target = target.replace('https://', 'http://')
                logger.info(f"WPScan: Cambiado a HTTP: {target}")
            if not DomainValidator.validate_url(target):
                logger.error(f"WPScan: URL inválida después de agregar protocolo: {target} (original: {original_target})")
                raise ValueError(f'Invalid URL: {original_target}. Intenté agregar protocolo pero sigue siendo inválido.')
        
        scan = self.scan_repo.create(
            scan_type='vulnerability',
            target=target,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'wpscan',
                'enumerate': enumerate,
                'plugins_detection': plugins_detection,
                'api_token': '[CONFIGURED]' if api_token else None
            }
        )
        
        try:
            workspace_output_dir = self._get_workspace_output_dir(scan.id)
            output_file = str(workspace_output_dir / f'wpscan_{scan.id}')
            
            command = [
                'wpscan',
                '--url', target,
                '--format', 'json',
                '--output', f'{output_file}.json',
                '--no-banner'
            ]
            
            # Enumeración
            if enumerate:
                command.extend(['--enumerate', enumerate])
            
            # Detección de plugins
            if plugins_detection == 'aggressive':
                command.append('--plugins-detection')
                command.append('aggressive')
            elif plugins_detection == 'mixed':
                command.append('--plugins-detection')
                command.append('mixed')
            # 'passive' es el default, no necesita flag
            
            # API token (para actualizar base de datos)
            if api_token:
                command.extend(['--api-token', api_token])
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            log_to_workspace(
                workspace_id=workspace_id,
                source='WPSCAN',
                level='INFO',
                message=f"Starting WPScan {scan.id}",
                metadata={'scan_id': scan.id, 'target': target, 'command': ' '.join(sanitized_cmd)}
            )
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, f'{output_file}.json', 'wpscan')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'wpscan',
                'target': target,
                'message': f'WPScan iniciado para {target}'
            }
            
        except Exception as e:
            logger.error(f"Error starting WPScan: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def preview_wpscan(
        self,
        target: str,
        workspace_id: int,
        enumerate: Optional[str] = None,
        plugins_detection: str = 'passive',
        api_token: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando WPScan."""
        # Agregar protocolo si no lo tiene
        original_target = target
        if not target.startswith(('http://', 'https://')):
            target = f'https://{target}'
            logger.info(f"WPScan Preview: Agregado protocolo HTTPS a target: {original_target} -> {target}")
        
        if not DomainValidator.validate_url(target):
            # Si HTTPS falla, intentar HTTP
            if target.startswith('https://'):
                target = target.replace('https://', 'http://')
                logger.info(f"WPScan Preview: Cambiado a HTTP: {target}")
            if not DomainValidator.validate_url(target):
                logger.error(f"WPScan Preview: URL inválida después de agregar protocolo: {target} (original: {original_target})")
                raise ValueError(f'Invalid URL: {original_target}. Intenté agregar protocolo pero sigue siendo inválido.')
        
        output_file = f'/workspaces/workspace_{workspace_id}/vuln_scans/wpscan_{{scan_id}}.json'
        command = [
            'wpscan',
            '--url', target,
            '--format', 'json',
            '--output', output_file,
            '--no-banner'
        ]
        
        # Enumeración
        if enumerate:
            command.extend(['--enumerate', enumerate])
        
        # Detección de plugins
        if plugins_detection == 'aggressive':
            command.append('--plugins-detection')
            command.append('aggressive')
        elif plugins_detection == 'mixed':
            command.append('--plugins-detection')
            command.append('mixed')
        
        # API token (no mostrar en preview por seguridad)
        if api_token:
            command.extend(['--api-token', '[CONFIGURED]'])
        
        command_str = ' '.join([str(c) for c in command])
        
        warnings = []
        if not shutil.which('wpscan'):
            warnings.append('Herramienta "wpscan" no encontrada en el PATH. Instalar: gem install wpscan o apt install wpscan')
        
        suggestions = []
        if not enumerate:
            suggestions.append('Considera usar --enumerate u,p,t para enumerar usuarios, plugins y themes')
        if plugins_detection == 'passive':
            suggestions.append('Para detección más exhaustiva, usa plugins_detection="aggressive"')
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'wpscan',
                'target': target,
                'enumerate': enumerate,
                'plugins_detection': plugins_detection,
                'api_token': '[CONFIGURED]' if api_token else None
            },
            'estimated_timeout': 1800,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': suggestions
        }

    def preview_nmap_vuln_scan(
        self,
        target: str,
        workspace_id: int,
        ports: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Preview del comando Nmap Vulnerability Scripts.
        
        Args:
            target: Host objetivo
            workspace_id: ID del workspace
            ports: Puertos a escanear (opcional)
        
        Returns:
            Dict con información del comando que se ejecutaría
        """
        # Usar ScanningService para el preview (mismo que start_nmap_vuln_scan)
        from services import ScanningService
        scanning_service = ScanningService()
        
        return scanning_service.preview_nmap_scan(
            target=target,
            scan_type='vuln',
            workspace_id=workspace_id,
            ports=ports
        )
    
    def preview_comprehensive_scan(
        self,
        target: str,
        workspace_id: int,
        include_nikto: bool = True,
        include_nmap: bool = True,
        include_nuclei: bool = True
    ) -> Dict[str, Any]:
        """
        Preview del comando Comprehensive Vulnerability Assessment.
        
        Muestra los comandos de todas las herramientas que se ejecutarán.
        
        Args:
            target: URL o host objetivo
            workspace_id: ID del workspace
            include_nikto: Incluir escaneo Nikto
            include_nmap: Incluir escaneo Nmap vuln
            include_nuclei: Incluir escaneo Nuclei
        
        Returns:
            Dict con información de todos los comandos que se ejecutarían
        """
        CommandSanitizer.validate_target(target)
        
        commands = []
        command_strings = []
        
        # Determinar protocolo y puerto para Nikto
        has_protocol = target.startswith('http://') or target.startswith('https://')
        is_https = target.startswith('https://')
        port = 443 if is_https else 80
        
        # 1. Nikto preview
        if include_nikto:
            nikto_preview = self.preview_nikto_scan(
                target=target,
                workspace_id=workspace_id,
                port=port,
                ssl=is_https
            )
            commands.append(nikto_preview['command'])
            command_strings.append(f"Nikto: {nikto_preview['command_string']}")
        
        # 2. Nmap vuln preview
        if include_nmap:
            from services import ScanningService
            scanning_service = ScanningService()
            nmap_preview = scanning_service.preview_nmap_scan(
                target=target,
                scan_type='vuln',
                workspace_id=workspace_id
            )
            commands.append(nmap_preview['command'])
            command_strings.append(f"Nmap Vuln: {nmap_preview['command_string']}")
        
        # 3. Nuclei preview
        if include_nuclei:
            nuclei_preview = self.preview_nuclei_scan(
                target=target,
                workspace_id=workspace_id,
                severity=['critical', 'high', 'medium']
            )
            commands.append(nuclei_preview['command'])
            command_strings.append(f"Nuclei: {nuclei_preview['command_string']}")
        
        # Combinar todos los comandos
        combined_command_string = ' && '.join(command_strings) if command_strings else 'No commands'
        
        return {
            'command': commands[0] if commands else [],
            'command_string': combined_command_string,
            'parameters': {
                'target': target,
                'include_nikto': include_nikto,
                'include_nmap': include_nmap,
                'include_nuclei': include_nuclei
            },
            'estimated_timeout': 3600,  # 1 hora para evaluación completa
            'output_file': f'/workspaces/workspace_{workspace_id}/vuln_scans/comprehensive_{{scan_id}}',
            'warnings': [
                'Esta evaluación ejecutará múltiples herramientas en secuencia.',
                'El tiempo total puede ser considerable.'
            ] if len(commands) > 1 else [],
            'suggestions': [
                'Considera ejecutar las herramientas por separado para mejor control.',
                'Revisa los resultados de cada herramienta antes de continuar.'
            ] if len(commands) > 1 else []
        }

    def preview_nuclei_scan(
        self,
        target: str,
        workspace_id: int,
        severity: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        templates: Optional[str] = None,
        rate_limit: int = 150
    ) -> Dict[str, Any]:
        """Preview del comando Nuclei."""
        # Si es un dominio sin protocolo, agregar https:// (Nuclei -u requiere URL)
        original_target = target
        is_url = DomainValidator.validate_url(target)
        is_domain = DomainValidator.is_valid_domain(target)
        
        if not is_url and is_domain:
            # Es un dominio válido pero sin protocolo, agregar https://
            target = f'https://{target}'
            logger.info(f"Nuclei Preview: Agregado protocolo HTTPS a dominio: {original_target} -> {target}")
            is_url = DomainValidator.validate_url(target)
        
        if not is_url and not is_domain:
            raise ValueError(f'Invalid URL or domain: {original_target}')
        
        output_file = f'/workspaces/workspace_{workspace_id}/vuln_scans/nuclei_{{scan_id}}.jsonl'
        command = [
            'nuclei',
            '-u', target,
            '-j',
            '-o', output_file,
            '-rl', str(rate_limit),
            '-stats',
            '-si', '10'
        ]
        
        if severity:
            command.extend(['-severity', ','.join(severity)])
        else:
            command.extend(['-severity', 'critical,high,medium,low'])
        
        if tags:
            command.extend(['-tags', ','.join(tags)])
        
        if templates:
            from pathlib import Path
            template_path = Path(templates)
            if template_path.exists():
                command.extend(['-t', str(template_path)])
            else:
                command.extend(['-t', templates])
        
        command_str = ' '.join([str(c) for c in command])
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'nuclei',
                'target': target,
                'severity': severity,
                'tags': tags,
                'templates': templates,
                'rate_limit': rate_limit
            },
            'estimated_timeout': 3600,
            'output_file': output_file,
            'warnings': [],
            'suggestions': []
        }
    
    def preview_nikto_scan(
        self,
        target: str,
        workspace_id: int,
        port: int = 80,
        ssl: bool = False,
        tuning: Optional[str] = None,
        maxtime: Optional[int] = None
    ) -> Dict[str, Any]:
        """Preview del comando Nikto."""
        is_url = DomainValidator.validate_url(target)
        is_domain = DomainValidator.is_valid_domain(target)
        
        if not is_url and not is_domain:
            raise ValueError(f'Invalid URL or domain: {target}')
        
        output_file = f'/workspaces/workspace_{workspace_id}/vuln_scans/nikto_{{scan_id}}.json'
        command = [
            'nikto',
            '-h', target,
            '-p', str(port),
            '-Format', 'json',
            '-output', output_file
        ]
        
        if ssl:
            command.append('-ssl')
        
        if tuning:
            command.extend(['-Tuning', tuning])
        
        if maxtime:
            command.extend(['-maxtime', str(maxtime)])
        
        command_str = ' '.join([str(c) for c in command])
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'nikto',
                'target': target,
                'port': port,
                'ssl': ssl,
                'tuning': tuning,
                'maxtime': maxtime
            },
            'estimated_timeout': 1800,
            'output_file': output_file,
            'warnings': [],
            'suggestions': []
        }

    def preview_sqlmap_scan(
        self,
        target: str,
        workspace_id: int,
        method: str = 'GET',
        data: Optional[str] = None,
        level: int = 1,
        risk: int = 1,
        techniques: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """Preview del comando SQLMap."""
        # Agregar protocolo si no lo tiene
        original_target = target
        if not target.startswith(('http://', 'https://')):
            target = f'https://{target}'
            logger.info(f"SQLMap Preview: Agregado protocolo HTTPS a target: {original_target} -> {target}")
        
        if not DomainValidator.validate_url(target):
            # Si HTTPS falla, intentar HTTP
            if target.startswith('https://'):
                target = target.replace('https://', 'http://')
                logger.info(f"SQLMap Preview: Cambiado a HTTP: {target}")
            if not DomainValidator.validate_url(target):
                logger.error(f"SQLMap Preview: URL inválida después de agregar protocolo: {target} (original: {original_target})")
                raise ValueError(f'Invalid URL: {original_target}. Intenté agregar protocolo pero sigue siendo inválido.')
        
        # Construir comando usando build_injection_test (igual que start_sqlmap_scan)
        output_dir = f'/workspaces/workspace_{workspace_id}/vuln_scans/sqlmap_{{scan_id}}'
        command = SafeSQLMap.build_injection_test(
            url=target,
            output_dir=output_dir,
            method=method,
            data=data,
            cookie=None,  # No se pasa cookie en preview
            risk=risk,
            level=level
        )
        
        # Agregar técnicas si se proporcionan
        if techniques:
            command.extend(['--technique', ','.join(techniques)])
        
        command_str = ' '.join([str(c) for c in command])
        
        warnings = []
        if level > 3 or risk > 3:
            warnings.append('Niveles altos pueden causar daño a la base de datos')
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'sqlmap',
                'target': target,
                'method': method,
                'data': data,
                'level': level,
                'risk': risk,
                'techniques': techniques
            },
            'estimated_timeout': 3600,
            'output_file': f'{output_dir}/',
            'warnings': warnings,
            'suggestions': []
        }
    
    def preview_zap_scan(
        self,
        target: str,
        workspace_id: int,
        scan_type: str = 'spider',
        context: Optional[str] = None
    ) -> Dict[str, Any]:
        """Preview del comando ZAP."""
        # Agregar protocolo si no lo tiene (igual que start_zap_scan)
        original_target = target
        if not target.startswith(('http://', 'https://')):
            # Intentar HTTPS primero
            target = f'https://{target}'
            logger.info(f"ZAP Preview: Agregado protocolo HTTPS a target: {original_target} -> {target}")
        
        if not DomainValidator.validate_url(target):
            # Si HTTPS falla, intentar HTTP
            if target.startswith('https://'):
                target = target.replace('https://', 'http://')
                logger.info(f"ZAP Preview: Cambiado a HTTP: {target}")
            if not DomainValidator.validate_url(target):
                logger.error(f"ZAP Preview: URL inválida después de agregar protocolo: {target} (original: {original_target})")
                raise ValueError(f'Invalid URL: {original_target}. Intenté agregar protocolo pero sigue siendo inválido.')
        
        output_file = f'/workspaces/workspace_{workspace_id}/vuln_scans/zap_{{scan_id}}.json'
        
        # Mapear scan_type del frontend (baseline, full, api) a los valores esperados
        # El preview usa zap-cli para mostrar el comando, pero el start usa scripts de ZAP
        # Por ahora, mostramos un comando genérico basado en el tipo
        if scan_type == 'baseline' or scan_type == 'spider':
            command = ['zap-baseline.py', '-t', target, '-J', output_file]
        elif scan_type == 'full' or scan_type == 'full-scan':
            command = ['zap-full-scan.py', '-t', target, '-J', output_file]
        elif scan_type == 'api' or scan_type == 'active-scan':
            command = ['zap-api-scan.py', '-t', target, '-f', 'openapi', '-J', output_file]
        else:
            # Default a baseline
            command = ['zap-baseline.py', '-t', target, '-J', output_file]
        
        if context:
            command.extend(['--context', context])
        
        command_str = ' '.join([str(c) for c in command])
        
        warnings = []
        warnings.append('ZAP requiere que el servicio esté corriendo en localhost:8080')
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'zap',
                'target': target,
                'scan_type': scan_type,
                'context': context
            },
            'estimated_timeout': 3600,
            'output_file': output_file,
            'warnings': warnings,
            'suggestions': []
        }
    
    def preview_testssl(
        self,
        target: str,
        workspace_id: int,
        severity: str = 'LOW'
    ) -> Dict[str, Any]:
        """Preview del comando testssl.sh."""
        is_url = DomainValidator.validate_url(target)
        is_domain = DomainValidator.is_valid_domain(target)
        
        if not is_url and not is_domain:
            raise ValueError(f'Invalid URL or domain: {target}')
        
        # Buscar testssl.sh en el PATH
        testssl_path = shutil.which('testssl.sh')
        if not testssl_path:
            # Intentar ubicaciones comunes
            common_paths = [
                '/usr/local/bin/testssl.sh',
                '/opt/testssl.sh/testssl.sh',
                os.path.expanduser('~/testssl.sh'),
                os.path.expanduser('~/.local/bin/testssl.sh')
            ]
            for path in common_paths:
                if os.path.exists(path) and os.access(path, os.X_OK):
                    testssl_path = path
                    break
        
        if not testssl_path:
            testssl_path = 'testssl.sh'  # Usar nombre por defecto para preview
        
        output_file = f'/workspaces/workspace_{workspace_id}/vuln_scans/testssl_{{scan_id}}.json'
        command = [
            testssl_path,
            '--jsonfile', output_file,
            '--htmlfile', output_file.replace('.json', '.html'),
            f'{target}:443'
        ]
        command_str = ' '.join([str(c) for c in command])
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'testssl',
                'target': target,
                'severity': severity
            },
            'estimated_timeout': 1800,
            'output_file': output_file,
            'warnings': [],
            'suggestions': []
        }
    
    def preview_whatweb(
        self,
        target: str,
        workspace_id: int,
        aggression: int = 1
    ) -> Dict[str, Any]:
        """Preview del comando WhatWeb."""
        is_url = DomainValidator.validate_url(target)
        is_domain = DomainValidator.is_valid_domain(target)
        
        if not is_url and not is_domain:
            raise ValueError(f'Invalid URL or domain: {target}')
        
        output_file = f'/workspaces/workspace_{workspace_id}/vuln_scans/whatweb_{{scan_id}}.json'
        command = [
            'whatweb',
            '--aggression', str(aggression),
            '--json', output_file,
            target
        ]
        command_str = ' '.join([str(c) for c in command])
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'whatweb',
                'target': target,
                'aggression': aggression
            },
            'estimated_timeout': 300,
            'output_file': output_file,
            'warnings': [],
            'suggestions': []
        }
    
    def preview_dalfox(
        self,
        target: str,
        workspace_id: int,
        blind: bool = False,
        worker: int = 100
    ) -> Dict[str, Any]:
        """Preview del comando Dalfox."""
        # Agregar protocolo si no lo tiene
        original_target = target
        if not target.startswith(('http://', 'https://')):
            target = f'https://{target}'
            logger.info(f"Dalfox Preview: Agregado protocolo HTTPS a target: {original_target} -> {target}")
        
        if not DomainValidator.validate_url(target):
            # Si HTTPS falla, intentar HTTP
            if target.startswith('https://'):
                target = target.replace('https://', 'http://')
                logger.info(f"Dalfox Preview: Cambiado a HTTP: {target}")
            if not DomainValidator.validate_url(target):
                logger.error(f"Dalfox Preview: URL inválida después de agregar protocolo: {target} (original: {original_target})")
                raise ValueError(f'Invalid URL: {original_target}. Intenté agregar protocolo pero sigue siendo inválido.')
        
        output_file = f'/workspaces/workspace_{workspace_id}/vuln_scans/dalfox_{{scan_id}}.json'
        command = [
            'dalfox',
            'url', target,
            '--output', output_file,
            '--format', 'json',
            '--worker', str(worker)
        ]
        
        if blind:
            command.append('--blind')
        
        command_str = ' '.join([str(c) for c in command])
        
        return {
            'command': command,
            'command_string': command_str,
            'parameters': {
                'tool': 'dalfox',
                'target': target,
                'blind': blind,
                'worker': worker
            },
            'estimated_timeout': 1200,
            'output_file': output_file,
            'warnings': [],
            'suggestions': []
        }
