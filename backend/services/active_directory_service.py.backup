"""
Active Directory Service
========================

Servicio completo para pentesting de Active Directory.

Herramientas integradas:
- Kerbrute (user enumeration & password spraying)
- Rubeus (Kerberos attacks)
- GetNPUsers.py (AS-REP Roasting)
- GetUserSPNs.py (Kerberoasting) - ya en exploitation_service
- ldapdomaindump (LDAP enumeration)
- adidnsdump (DNS enumeration)
- CrackMapExec AD modules
- BloodHound (ya en post_exploitation_service)
"""

import subprocess
import logging
import json
import threading
from typing import Dict, Any, List, Optional
from pathlib import Path
from datetime import datetime

from utils.validators import CommandSanitizer, IPValidator
from utils.parsers.ad_parser import (
    KerbruteParser, RubeusParser, GetNPUsersParser,
    LDAPDomainDumpParser, ADIDNSDumpParser, CrackMapExecADParser
)
from repositories import ScanRepository
from models import db

logger = logging.getLogger(__name__)


class ActiveDirectoryService:
    """Servicio completo para pentesting de AD."""
    
    def __init__(self, scan_repository: ScanRepository = None):
        """Inicializa el servicio."""
        self.scan_repo = scan_repository or ScanRepository()
        # output_dir se obtiene dinámicamente por workspace
        # Mantener fallback para compatibilidad (usar tmp del proyecto)
        from utils.workspace_filesystem import PROJECT_TMP_DIR
        self.output_dir = PROJECT_TMP_DIR / 'ad_scans'
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def _get_workspace_output_dir(self, scan_id: int) -> Path:
        """
        Obtiene directorio de output del workspace para un scan.
        
        Args:
            scan_id: ID del scan
        
        Returns:
            Path al directorio de output del workspace
        """
        from utils.workspace_filesystem import get_workspace_output_dir_from_scan
        return get_workspace_output_dir_from_scan(scan_id, 'ad_scans')
        
        # Parsers
        self.kerbrute_parser = KerbruteParser()
        self.rubeus_parser = RubeusParser()
        self.getnpusers_parser = GetNPUsersParser()
        self.ldapdump_parser = LDAPDomainDumpParser()
        self.adidns_parser = ADIDNSDumpParser()
        self.cme_ad_parser = CrackMapExecADParser()
    
    # ============================================
    # KERBRUTE (User Enumeration & Password Spraying)
    # ============================================
    
    def start_kerbrute_userenum(
        self,
        domain: str,
        dc_ip: str,
        userlist: str,
        workspace_id: int,
        user_id: int
    ) -> Dict[str, Any]:
        """
        Enumera usuarios válidos con Kerbrute.
        
        Args:
            domain: Dominio AD
            dc_ip: IP del DC
            userlist: Path a lista de usuarios
            workspace_id: ID del workspace
            user_id: ID del usuario
        """
        IPValidator.validate(dc_ip)
        
        scan = self.scan_repo.create(
            scan_type='active_directory',
            target=domain,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'kerbrute',
                'action': 'userenum',
                'dc_ip': dc_ip
            }
        )
        
        try:
            output_file = str(self.output_dir / f'kerbrute_userenum_{scan.id}.txt')
            
            command = [
                'kerbrute',
                'userenum',
                '-d', domain,
                '--dc', dc_ip,
                userlist,
                '-o', output_file
            ]
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            logger.info(f"Starting Kerbrute userenum {scan.id}")
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_file, 'kerbrute')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'kerbrute',
                'action': 'userenum',
                'domain': domain
            }
            
        except Exception as e:
            logger.error(f"Error starting Kerbrute: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    def start_kerbrute_passwordspray(
        self,
        domain: str,
        dc_ip: str,
        userlist: str,
        password: str,
        workspace_id: int,
        user_id: int
    ) -> Dict[str, Any]:
        """
        Password spraying con Kerbrute.
        
        Args:
            domain: Dominio AD
            dc_ip: IP del DC
            userlist: Path a lista de usuarios
            password: Password a probar
            workspace_id: ID del workspace
            user_id: ID del usuario
        """
        IPValidator.validate(dc_ip)
        
        scan = self.scan_repo.create(
            scan_type='active_directory',
            target=domain,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'kerbrute',
                'action': 'passwordspray',
                'dc_ip': dc_ip
            }
        )
        
        try:
            output_file = str(self.output_dir / f'kerbrute_spray_{scan.id}.txt')
            
            command = [
                'kerbrute',
                'passwordspray',
                '-d', domain,
                '--dc', dc_ip,
                userlist,
                password,
                '-o', output_file
            ]
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            logger.info(f"Starting Kerbrute password spray {scan.id}")
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_file, 'kerbrute')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'kerbrute',
                'action': 'passwordspray',
                'domain': domain
            }
            
        except Exception as e:
            logger.error(f"Error starting Kerbrute spray: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # GetNPUsers (AS-REP Roasting)
    # ============================================
    
    def start_getnpusers(
        self,
        domain: str,
        workspace_id: int,
        user_id: int,
        username: Optional[str] = None,
        password: Optional[str] = None,
        dc_ip: Optional[str] = None,
        usersfile: Optional[str] = None,
        no_pass: bool = True
    ) -> Dict[str, Any]:
        """
        AS-REP Roasting con GetNPUsers.py.
        
        Args:
            domain: Dominio AD
            workspace_id: ID del workspace
            user_id: ID del usuario
            username: Usuario (opcional si no-pass)
            password: Password (opcional si no-pass)
            dc_ip: IP del DC
            usersfile: Lista de usuarios a probar
            no_pass: Sin credenciales (anonymous)
        """
        scan = self.scan_repo.create(
            scan_type='active_directory',
            target=domain,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'getnpusers',
                'no_pass': no_pass
            }
        )
        
        try:
            output_file = str(self.output_dir / f'getnpusers_{scan.id}.txt')
            
            command = [
                'GetNPUsers.py',
                domain + '/',
                '-outputfile', output_file,
                '-format', 'hashcat'
            ]
            
            if no_pass:
                command.append('-no-pass')
            else:
                if username and password:
                    command[1] = f'{domain}/{username}:{password}'
            
            if dc_ip:
                command.extend(['-dc-ip', dc_ip])
            
            if usersfile:
                command.extend(['-usersfile', usersfile])
            else:
                command.append('-request')
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            logger.info(f"Starting GetNPUsers {scan.id}")
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_file, 'getnpusers')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'getnpusers',
                'domain': domain
            }
            
        except Exception as e:
            logger.error(f"Error starting GetNPUsers: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # LDAP Domain Dump
    # ============================================
    
    def start_ldapdomaindump(
        self,
        dc_ip: str,
        username: str,
        password: str,
        domain: str,
        workspace_id: int,
        user_id: int
    ) -> Dict[str, Any]:
        """
        Dump de información LDAP.
        
        Args:
            dc_ip: IP del DC
            username: Usuario
            password: Password
            domain: Dominio
            workspace_id: ID del workspace
            user_id: ID del usuario
        """
        IPValidator.validate(dc_ip)
        
        scan = self.scan_repo.create(
            scan_type='active_directory',
            target=dc_ip,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'ldapdomaindump',
                'domain': domain
            }
        )
        
        try:
            output_dir = str(self.output_dir / f'ldapdump_{scan.id}')
            Path(output_dir).mkdir(exist_ok=True)
            
            command = [
                'ldapdomaindump',
                '-u', f'{domain}\\{username}',
                '-p', password,
                dc_ip,
                '-o', output_dir
            ]
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            logger.info(f"Starting ldapdomaindump {scan.id}")
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_dir, 'ldapdomaindump')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'ldapdomaindump',
                'target': dc_ip
            }
            
        except Exception as e:
            logger.error(f"Error starting ldapdomaindump: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # ADIDNS Dump
    # ============================================
    
    def start_adidnsdump(
        self,
        dc_ip: str,
        username: str,
        password: str,
        domain: str,
        workspace_id: int,
        user_id: int
    ) -> Dict[str, Any]:
        """
        Dump de registros DNS de AD.
        
        Args:
            dc_ip: IP del DC
            username: Usuario
            password: Password
            domain: Dominio
            workspace_id: ID del workspace
            user_id: ID del usuario
        """
        IPValidator.validate(dc_ip)
        
        scan = self.scan_repo.create(
            scan_type='active_directory',
            target=dc_ip,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'adidnsdump',
                'domain': domain
            }
        )
        
        try:
            output_file = str(self.output_dir / f'adidnsdump_{scan.id}.csv')
            
            command = [
                'adidnsdump',
                '-u', f'{domain}\\{username}',
                '-p', password,
                dc_ip,
                '-r',
                '--dns-tcp'
            ]
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            logger.info(f"Starting adidnsdump {scan.id}")
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_file, 'adidnsdump')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'adidnsdump',
                'target': dc_ip
            }
            
        except Exception as e:
            logger.error(f"Error starting adidnsdump: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # CrackMapExec AD Enumeration
    # ============================================
    
    def start_cme_enum_users(
        self,
        dc_ip: str,
        username: str,
        password: str,
        domain: str,
        workspace_id: int,
        user_id: int
    ) -> Dict[str, Any]:
        """Enumera usuarios AD con CrackMapExec."""
        IPValidator.validate(dc_ip)
        
        scan = self.scan_repo.create(
            scan_type='active_directory',
            target=dc_ip,
            workspace_id=workspace_id,
            user_id=user_id,
            options={
                'tool': 'crackmapexec',
                'action': 'enum_users',
                'domain': domain
            }
        )
        
        try:
            output_file = str(self.output_dir / f'cme_users_{scan.id}.txt')
            
            command = [
                'crackmapexec', 'smb', dc_ip,
                '-u', username,
                '-p', password,
                '-d', domain,
                '--users',
                '--log', output_file
            ]
            
            sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
            
            logger.info(f"Starting CME enum users {scan.id}")
            
            thread = threading.Thread(
                target=self._execute_scan,
                args=(scan.id, sanitized_cmd, output_file, 'crackmapexec')
            )
            thread.daemon = True
            thread.start()
            
            self.scan_repo.update_status(scan, 'running')
            
            return {
                'scan_id': scan.id,
                'status': 'running',
                'tool': 'crackmapexec',
                'action': 'enum_users',
                'target': dc_ip
            }
            
        except Exception as e:
            logger.error(f"Error starting CME enum users: {e}")
            self.scan_repo.update_status(scan, 'failed', str(e))
            raise
    
    # ============================================
    # OBTENER RESULTADOS
    # ============================================
    
    def get_scan_results(self, scan_id: int) -> Dict[str, Any]:
        """Obtiene y parsea resultados."""
        scan = self.scan_repo.find_by_id(scan_id)
        
        if not scan:
            raise ValueError(f'Scan {scan_id} not found')
        
        if scan.status != 'completed':
            return {
                'scan_id': scan_id,
                'status': scan.status,
                'message': 'Scan not completed yet'
            }
        
        tool = scan.options.get('tool')
        action = scan.options.get('action', '')
        
        try:
            if tool == 'kerbrute':
                output_file = self.output_dir / f'kerbrute_{action}_{scan_id}.txt'
                with open(output_file, 'r') as f:
                    results = self.kerbrute_parser.parse_output(f.read())
            
            elif tool == 'getnpusers':
                output_file = self.output_dir / f'getnpusers_{scan_id}.txt'
                with open(output_file, 'r') as f:
                    results = self.getnpusers_parser.parse_output(f.read())
            
            elif tool == 'ldapdomaindump':
                output_dir = self.output_dir / f'ldapdump_{scan_id}'
                json_files = list(output_dir.glob('*.json'))
                if json_files:
                    results = self.ldapdump_parser.parse_json(str(json_files[0]))
                else:
                    results = {'message': 'Check HTML reports in output directory'}
            
            elif tool == 'adidnsdump':
                output_file = self.output_dir / f'adidnsdump_{scan_id}.csv'
                with open(output_file, 'r') as f:
                    results = self.adidns_parser.parse_output(f.read())
            
            elif tool == 'crackmapexec':
                if action == 'enum_users':
                    output_file = self.output_dir / f'cme_users_{scan_id}.txt'
                    with open(output_file, 'r') as f:
                        results = self.cme_ad_parser.parse_enum_users(f.read())
                elif action == 'enum_groups':
                    output_file = self.output_dir / f'cme_groups_{scan_id}.txt'
                    with open(output_file, 'r') as f:
                        results = self.cme_ad_parser.parse_enum_groups(f.read())
                else:
                    results = {'error': f'Unknown CME action: {action}'}
            
            else:
                results = {'error': f'Unknown tool: {tool}'}
            
            return {
                'scan_id': scan_id,
                'status': 'completed',
                'tool': tool,
                'action': action,
                'results': results,
                'scan_info': {
                    'target': scan.target,
                    'started_at': scan.started_at.isoformat() if scan.started_at else None,
                    'completed_at': scan.completed_at.isoformat() if scan.completed_at else None
                }
            }
            
        except Exception as e:
            logger.error(f"Error parsing AD scan results {scan_id}: {e}")
            return {
                'scan_id': scan_id,
                'error': f'Failed to parse results: {str(e)}'
            }
    
    # ============================================
    # HELPERS PRIVADOS
    # ============================================
    
    def _execute_scan(
        self,
        scan_id: int,
        command: list,
        output_file: str,
        tool: str
    ) -> None:
        """Ejecuta AD scan en thread separado."""
        try:
            logger.info(f"Executing {tool} {scan_id}: {' '.join(command)}")
            
            # Timeouts
            timeout_map = {
                'kerbrute': 600,         # 10 min
                'getnpusers': 600,       # 10 min
                'ldapdomaindump': 1800,  # 30 min
                'adidnsdump': 600,       # 10 min
                'crackmapexec': 1800     # 30 min
            }
            timeout = timeout_map.get(tool, 1800)
            
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                env=CommandSanitizer.get_safe_env()
            )
            
            # Guardar output
            if not Path(output_file).exists() and result.stdout:
                with open(output_file, 'w') as f:
                    f.write(result.stdout)
            
            scan = self.scan_repo.find_by_id(scan_id)
            
            if result.returncode == 0:
                self.scan_repo.update_status(scan, 'completed')
                self.scan_repo.update_progress(scan, 100, result.stdout[:1000])
                logger.info(f"{tool} {scan_id} completed")
            else:
                error_msg = result.stderr or "Unknown error"
                self.scan_repo.update_status(scan, 'failed', error_msg)
                logger.error(f"{tool} {scan_id} failed: {error_msg}")
                
        except subprocess.TimeoutExpired:
            scan = self.scan_repo.find_by_id(scan_id)
            self.scan_repo.update_status(scan, 'failed', f'Timeout ({timeout}s)')
            logger.error(f"{tool} {scan_id} timeout")
            
        except Exception as e:
            scan = self.scan_repo.find_by_id(scan_id)
            self.scan_repo.update_status(scan, 'failed', str(e))
            logger.error(f"{tool} {scan_id} error: {e}", exc_info=True)
