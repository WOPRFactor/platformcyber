"""
Nikto Parser
============

Parser para archivos JSON de Nikto.
Extrae vulnerabilidades web encontradas por Nikto.
"""

from pathlib import Path
from typing import List
from ..base_parser import BaseParser, ParsedFinding
from ...config import MAX_FILE_SIZE


class NiktoParser(BaseParser):
    """Parser para archivos JSON de Nikto."""
    
    def can_parse(self, file_path: Path) -> bool:
        """
        Verifica si es un archivo JSON de Nikto.
        
        Args:
            file_path: Ruta al archivo
            
        Returns:
            True si es JSON y contiene 'nikto' en el nombre
        """
        return (
            file_path.suffix.lower() == '.json' and 
            'nikto' in file_path.stem.lower()
        )
    
    def parse(self, file_path: Path) -> List[ParsedFinding]:
        """
        Parsea archivo JSON de Nikto.
        
        Args:
            file_path: Ruta al archivo JSON
            
        Returns:
            Lista de ParsedFinding con vulnerabilidades encontradas
        """
        findings = []
        
        # Validar tamaño del archivo
        if not self._validate_file_size(file_path, MAX_FILE_SIZE):
            self.logger.warning(f"File {file_path} exceeds max size, skipping")
            return findings
        
        try:
            data = self._safe_parse_json(file_path)
            if not data:
                return findings
            
            # Nikto puede tener múltiples scans (array) o uno solo (dict)
            scans = data if isinstance(data, list) else [data]
            
            for scan in scans:
                host = scan.get('host', 'unknown')
                port = scan.get('port', 80)
                ip = scan.get('ip', '')
                
                vulnerabilities = scan.get('vulnerabilities', [])
                
                for vuln in vulnerabilities:
                    finding = self._create_finding(vuln, host, port, ip)
                    findings.append(finding)
            
            self.logger.info(f"Parsed {len(findings)} findings from {file_path}")
            
        except Exception as e:
            self.logger.error(f"Error parsing Nikto JSON {file_path}: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
        
        return findings
    
    def _create_finding(
        self, 
        vuln: dict, 
        host: str, 
        port: int, 
        ip: str
    ) -> ParsedFinding:
        """
        Crea un ParsedFinding a partir de una vulnerabilidad de Nikto.
        
        Args:
            vuln: Diccionario con datos de la vulnerabilidad
            host: Hostname del objetivo
            port: Puerto del objetivo
            ip: IP del objetivo
            
        Returns:
            ParsedFinding con la información de la vulnerabilidad
        """
        msg = vuln.get('msg', 'Unknown vulnerability')
        osvdb = vuln.get('OSVDB', '')
        method = vuln.get('method', 'GET')
        url = vuln.get('url', '')
        
        # Severidad heurística basada en el mensaje
        severity = self._assess_severity(msg, vuln)
        
        # Construir target completo
        target = f"{host}:{port}{url}" if url else f"{host}:{port}"
        
        # Referencias OSVDB
        references = [f"OSVDB-{osvdb}"] if osvdb else []
        
        return ParsedFinding(
            title=f"Nikto: {msg[:80]}",  # Truncar títulos largos
            severity=severity,
            description=msg,
            category='web_vulnerability',
            affected_target=target,
            references=references,
            raw_data={
                'method': method,
                'url': url,
                'osvdb': osvdb,
                'host': host,
                'port': port,
                'ip': ip
            }
        )
    
    def _assess_severity(self, msg: str, vuln: dict) -> str:
        """
        Asigna severidad basada en palabras clave en el mensaje.
        
        Nikto no tiene campo de severidad nativo, por lo que usamos
        heurística basada en palabras clave.
        
        Args:
            msg: Mensaje de la vulnerabilidad
            vuln: Diccionario completo de la vulnerabilidad
            
        Returns:
            Severidad: critical, high, medium, low
        """
        msg_lower = msg.lower()
        
        # Critical
        critical_keywords = [
            'sql injection', 'rce', 'remote code execution', 
            'arbitrary code', 'shell upload'
        ]
        if any(kw in msg_lower for kw in critical_keywords):
            return 'critical'
        
        # High
        high_keywords = [
            'xss', 'cross-site scripting', 'csrf', 'command injection',
            'file inclusion', 'lfi', 'rfi', 'authentication bypass',
            'default credentials'
        ]
        if any(kw in msg_lower for kw in high_keywords):
            return 'high'
        
        # Medium
        medium_keywords = [
            'information disclosure', 'directory listing', 'backup file',
            'sensitive', 'phpinfo', 'configuration file'
        ]
        if any(kw in msg_lower for kw in medium_keywords):
            return 'medium'
        
        # Low por default
        return 'low'
