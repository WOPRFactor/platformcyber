"""
Exploitation Tasks
==================

Tareas asíncronas para operaciones de explotación.
"""

import logging
import subprocess
from datetime import datetime
from celery import Task
from celery_app import celery
from utils.validators import CommandSanitizer
from repositories import ScanRepository

logger = logging.getLogger(__name__)


class ExploitTask(Task):
    """Base class para tareas de explotación."""
    autoretry_for = (Exception,)
    retry_kwargs = {'max_retries': 2}  # Menos retries para exploits
    retry_backoff = True


@celery.task(
    bind=True,
    base=ExploitTask,
    name='tasks.exploitation.sqlmap_scan',
    time_limit=3600,  # 1 hora
    soft_time_limit=3500
)
def sqlmap_scan_task(self, scan_id: int, url: str, options: dict):
    """
    Ejecuta SQLMap en background.
    
    Args:
        scan_id: ID del scan
        url: URL objetivo
        options: Opciones de SQLMap
    """
    scan_repo = ScanRepository()
    
    try:
        scan = scan_repo.find_by_id(scan_id)
        scan_repo.update_status(scan, 'running')
        
        self.update_state(
            state='PROGRESS',
            meta={'scan_id': scan_id, 'progress': 0, 'status': 'Starting SQLMap...'}
        )
        
        command = ['sqlmap', '-u', url, '--batch']
        
        if options.get('dbs'):
            command.append('--dbs')
        
        if options.get('tables') and options.get('database'):
            command.extend(['-D', options['database'], '--tables'])
        
        if options.get('dump') and options.get('database') and options.get('table'):
            command.extend([
                '-D', options['database'],
                '-T', options['table'],
                '--dump'
            ])
        
        from utils.workspace_filesystem import PROJECT_TMP_DIR
        scans_dir = PROJECT_TMP_DIR / 'scans'
        scans_dir.mkdir(parents=True, exist_ok=True)
        output_file = str(scans_dir / f'sqlmap_{scan_id}.txt')
        
        sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
        
        logger.info(f"Executing SQLMap task {scan_id}")
        
        result = subprocess.run(
            sanitized_cmd,
            capture_output=True,
            text=True,
            timeout=3500,
            env=CommandSanitizer.get_safe_env()
        )
        
        # Guardar output
        with open(output_file, 'w') as f:
            f.write(result.stdout)
        
        scan_repo.update_status(scan, 'completed')
        scan_repo.update_progress(scan, 100, 'SQLMap completed')
        
        return {
            'scan_id': scan_id,
            'status': 'completed',
            'output_file': output_file,
            'vulnerable': 'sqlmap identified' in result.stdout.lower(),
            'completed_at': datetime.utcnow().isoformat()
        }
            
    except Exception as e:
        logger.error(f"SQLMap task {scan_id} failed: {e}", exc_info=True)
        scan = scan_repo.find_by_id(scan_id)
        scan_repo.update_status(scan, 'failed', str(e))
        raise


@celery.task(
    bind=True,
    base=ExploitTask,
    name='tasks.exploitation.zap_scan',
    time_limit=2400,  # 40 minutos
    soft_time_limit=2300
)
def zap_scan_task(self, scan_id: int, target: str, options: dict):
    """
    Ejecuta OWASP ZAP scan en background.
    
    Args:
        scan_id: ID del scan
        target: Target URL
        options: Opciones de ZAP
    """
    scan_repo = ScanRepository()
    
    try:
        scan = scan_repo.find_by_id(scan_id)
        scan_repo.update_status(scan, 'running')
        
        self.update_state(
            state='PROGRESS',
            meta={'scan_id': scan_id, 'progress': 0, 'status': 'Starting ZAP scan...'}
        )
        
        # ZAP command (usando zap-cli o zap baseline)
        command = ['zap-baseline.py', '-t', target]
        
        if options.get('ajax_spider'):
            command.append('-j')
        
        from utils.workspace_filesystem import PROJECT_TMP_DIR
        scans_dir = PROJECT_TMP_DIR / 'scans'
        scans_dir.mkdir(parents=True, exist_ok=True)
        output_file = str(scans_dir / f'zap_{scan_id}.html')
        command.extend(['-r', output_file])
        
        sanitized_cmd = CommandSanitizer.sanitize_command(command[0], command[1:])
        
        logger.info(f"Executing ZAP task {scan_id}")
        
        result = subprocess.run(
            sanitized_cmd,
            capture_output=True,
            text=True,
            timeout=2300,
            env=CommandSanitizer.get_safe_env()
        )
        
        scan_repo.update_status(scan, 'completed')
        scan_repo.update_progress(scan, 100, 'ZAP scan completed')
        
        return {
            'scan_id': scan_id,
            'status': 'completed',
            'output_file': output_file,
            'completed_at': datetime.utcnow().isoformat()
        }
            
    except Exception as e:
        logger.error(f"ZAP task {scan_id} failed: {e}", exc_info=True)
        scan = scan_repo.find_by_id(scan_id)
        scan_repo.update_status(scan, 'failed', str(e))
        raise



