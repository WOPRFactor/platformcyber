"""
Exploitation Results Parser
============================

Parsers para herramientas de explotación.
"""

import json
import re
from typing import Dict, List, Any, Optional


class HydraParser:
    """Parser para resultados de Hydra."""
    
    @staticmethod
    def parse_output(output: str) -> Dict[str, Any]:
        """
        Parsea salida de Hydra.
        
        Formato esperado:
        [22][ssh] host: 192.168.1.1   login: admin   password: admin123
        """
        credentials = []
        
        # Regex para extraer credenciales
        pattern = r'\[(\d+)\]\[(\w+)\]\s+host:\s+([\d\.]+)\s+login:\s+(\S+)\s+password:\s+(\S+)'
        
        for match in re.finditer(pattern, output):
            credentials.append({
                'port': match.group(1),
                'service': match.group(2),
                'host': match.group(3),
                'username': match.group(4),
                'password': match.group(5)
            })
        
        # Extraer estadísticas
        attempts = 0
        valid_passwords = len(credentials)
        
        attempts_match = re.search(r'(\d+)\s+valid password', output)
        if attempts_match:
            valid_passwords = int(attempts_match.group(1))
        
        return {
            'tool': 'hydra',
            'success': len(credentials) > 0,
            'credentials_found': len(credentials),
            'credentials': credentials,
            'summary': f'Found {len(credentials)} valid credentials'
        }


class CrackMapExecParser:
    """Parser para resultados de CrackMapExec."""
    
    @staticmethod
    def parse_output(output: str) -> Dict[str, Any]:
        """
        Parsea salida de CrackMapExec.
        
        Formato esperado:
        SMB         192.168.1.1    445    DC01    [+] DOMAIN\\user:password (Pwn3d!)
        """
        results = {
            'hosts': [],
            'credentials': [],
            'shares': [],
            'pwned_hosts': []
        }
        
        for line in output.split('\n'):
            if not line.strip():
                continue
            
            # Host discovery
            host_match = re.match(
                r'(\w+)\s+([\d\.]+)\s+(\d+)\s+(\S+)\s+\[([\+\-\*])\]',
                line
            )
            if host_match:
                protocol = host_match.group(1)
                ip = host_match.group(2)
                port = host_match.group(3)
                hostname = host_match.group(4)
                status = host_match.group(5)
                
                results['hosts'].append({
                    'protocol': protocol,
                    'ip': ip,
                    'port': port,
                    'hostname': hostname,
                    'status': 'success' if status == '+' else 'failed'
                })
            
            # Credenciales válidas
            if '[+]' in line and ('\\' in line or '@' in line):
                cred_match = re.search(r'\[(\w+)\\\]?(\S+):(\S+)', line)
                if cred_match:
                    results['credentials'].append({
                        'domain': cred_match.group(1),
                        'username': cred_match.group(2),
                        'password': cred_match.group(3),
                        'pwned': 'Pwn3d!' in line
                    })
                    
                    if 'Pwn3d!' in line:
                        ip_match = re.search(r'([\d\.]+)', line)
                        if ip_match:
                            results['pwned_hosts'].append(ip_match.group(1))
            
            # Shares
            if 'READ' in line or 'WRITE' in line:
                share_match = re.search(r'(\S+)\s+(READ|WRITE)', line)
                if share_match:
                    results['shares'].append({
                        'name': share_match.group(1),
                        'permission': share_match.group(2)
                    })
        
        return {
            'tool': 'crackmapexec',
            'total_hosts': len(results['hosts']),
            'credentials_found': len(results['credentials']),
            'pwned_hosts': len(results['pwned_hosts']),
            'shares_found': len(results['shares']),
            'results': results
        }


class ImpacketParser:
    """Parser para herramientas de Impacket."""
    
    @staticmethod
    def parse_psexec(output: str) -> Dict[str, Any]:
        """Parsea salida de psexec.py."""
        success = False
        shell_obtained = False
        error = None
        
        if 'Impacket' in output and 'psexec' in output.lower():
            success = True
        
        if 'C:\\Windows\\system32>' in output or 'C:\\>' in output:
            shell_obtained = True
        
        if 'error' in output.lower() or 'failed' in output.lower():
            error_match = re.search(r'error[:\s]+(.+)', output, re.IGNORECASE)
            if error_match:
                error = error_match.group(1).strip()
        
        return {
            'tool': 'psexec',
            'success': success,
            'shell_obtained': shell_obtained,
            'error': error,
            'output': output[:500]  # Primeros 500 chars
        }
    
    @staticmethod
    def parse_secretsdump(output: str) -> Dict[str, Any]:
        """Parsea salida de secretsdump.py."""
        hashes = {
            'sam': [],
            'lsa': [],
            'ntds': []
        }
        
        kerberos_keys = []
        
        # Extraer hashes SAM
        for line in output.split('\n'):
            if ':::' in line and not line.startswith('['):
                parts = line.split(':')
                if len(parts) >= 4:
                    hashes['sam'].append({
                        'username': parts[0].strip(),
                        'rid': parts[1],
                        'lm_hash': parts[2],
                        'ntlm_hash': parts[3]
                    })
            
            # Kerberos keys
            if 'aes256' in line.lower() or 'aes128' in line.lower():
                kerberos_keys.append(line.strip())
        
        return {
            'tool': 'secretsdump',
            'sam_hashes': len(hashes['sam']),
            'kerberos_keys': len(kerberos_keys),
            'hashes': hashes,
            'keys': kerberos_keys[:10]  # Primeras 10
        }
    
    @staticmethod
    def parse_getuserspns(output: str) -> Dict[str, Any]:
        """Parsea salida de GetUserSPNs.py (Kerberoasting)."""
        spns = []
        tickets = []
        
        for line in output.split('\n'):
            if 'ServicePrincipalName' in line:
                spn_match = re.search(r'ServicePrincipalName\s+:\s+(.+)', line)
                if spn_match:
                    spns.append(spn_match.group(1).strip())
            
            if '$krb5tgs$' in line:
                tickets.append(line.strip())
        
        return {
            'tool': 'getuserspns',
            'spns_found': len(spns),
            'tickets_obtained': len(tickets),
            'spns': spns,
            'tickets': tickets
        }


class MetasploitParser:
    """Parser para resultados de Metasploit."""
    
    @staticmethod
    def parse_console_output(output: str) -> Dict[str, Any]:
        """Parsea salida de consola de Metasploit."""
        sessions = []
        exploits_run = []
        
        # Extraer sesiones
        session_matches = re.findall(
            r'\[\*\]\s+Session\s+(\d+)\s+opened\s+\(([\d\.]+):(\d+)\s+->\s+([\d\.]+):(\d+)\)',
            output
        )
        
        for match in session_matches:
            sessions.append({
                'session_id': match[0],
                'local_ip': match[1],
                'local_port': match[2],
                'remote_ip': match[3],
                'remote_port': match[4]
            })
        
        # Extraer exploits ejecutados
        exploit_matches = re.findall(
            r'\[\*\]\s+Exploit\s+running\s+as\s+background\s+job\s+(\d+)',
            output
        )
        
        for job_id in exploit_matches:
            exploits_run.append({'job_id': job_id})
        
        return {
            'tool': 'metasploit',
            'sessions_opened': len(sessions),
            'exploits_run': len(exploits_run),
            'sessions': sessions,
            'exploits': exploits_run
        }


class EvilWinRMParser:
    """Parser para Evil-WinRM."""
    
    @staticmethod
    def parse_output(output: str) -> Dict[str, Any]:
        """Parsea salida de Evil-WinRM."""
        connected = False
        shell_obtained = False
        user = None
        domain = None
        
        if 'Evil-WinRM' in output:
            connected = True
        
        if '*Evil-WinRM* PS' in output:
            shell_obtained = True
        
        # Extraer usuario y dominio
        user_match = re.search(r'User:\s+(\S+)', output)
        if user_match:
            user = user_match.group(1)
        
        domain_match = re.search(r'Domain:\s+(\S+)', output)
        if domain_match:
            domain = domain_match.group(1)
        
        return {
            'tool': 'evil-winrm',
            'connected': connected,
            'shell_obtained': shell_obtained,
            'user': user,
            'domain': domain
        }

