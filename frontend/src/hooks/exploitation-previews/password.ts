/**
 * Password Attack Previews
 * ========================
 * 
 * Handlers de preview para ataques de contraseÃ±as.
 */

import { toast } from 'sonner'
import { commandPreviewAPI } from '../../lib/api/command-preview'
import { PreviewState, PreviewHandlers, ExecuteCallback } from './types'

export const createPasswordPreviewHandlers = (
  state: PreviewState,
  handlers: PreviewHandlers,
  workspaceId: number
) => {
  const handleJohnWithPreview = async (params: {
    hashFile: string
    wordlist?: string
    format?: string
    rules: boolean
    onExecute: ExecuteCallback
  }) => {
    try {
      const preview = await commandPreviewAPI.previewJohn({
        workspace_id: workspaceId,
        hash_file: params.hashFile,
        wordlist: params.wordlist,
        format: params.format,
        rules: params.rules
      })
      handlers.setPreviewData(preview)
      handlers.setPreviewToolName('John the Ripper')
      handlers.setPreviewExecuteFn(() => params.onExecute({
        hash_file: params.hashFile,
        wordlist: params.wordlist,
        format: params.format,
        rules: params.rules
      }))
      handlers.setShowPreview(true)
    } catch (error: any) {
      console.error('Error obteniendo preview de John:', error)
      toast.error('Error al obtener preview del comando')
    }
  }

  const handleHashcatWithPreview = async (params: {
    hashFile: string
    mode: number
    wordlist: string
    rulesFile?: string
    onExecute: ExecuteCallback
  }) => {
    try {
      const preview = await commandPreviewAPI.previewHashcat({
        workspace_id: workspaceId,
        hash_file: params.hashFile,
        hash_type: params.mode.toString(),
        wordlist: params.wordlist,
        rules_file: params.rulesFile
      })
      handlers.setPreviewData(preview)
      handlers.setPreviewToolName('Hashcat')
      handlers.setPreviewExecuteFn(() => params.onExecute({
        hash_file: params.hashFile,
        mode: params.mode,
        wordlist: params.wordlist,
        rules_file: params.rulesFile
      }))
      handlers.setShowPreview(true)
    } catch (error: any) {
      console.error('Error obteniendo preview de Hashcat:', error)
      toast.error('Error al obtener preview del comando')
    }
  }

  const handleKerbruteWithPreview = async (params: {
    domain: string
    mode: string
    usersFile?: string
    passwordsFile?: string
    password?: string
    dcIp?: string
    originalPassword?: string
    onExecute: ExecuteCallback
  }) => {
    try {
      const preview = await commandPreviewAPI.previewKerbrute({
        workspace_id: workspaceId,
        target: params.domain,
        userlist: params.usersFile,
        passwordlist: params.passwordsFile,
        password: params.password || params.originalPassword,
        domain: params.domain,
        dc_ip: params.dcIp
      })
      handlers.setPreviewData(preview)
      handlers.setPreviewToolName('Kerbrute')
      handlers.setPreviewExecuteFn(() => params.onExecute({
        domain: params.domain,
        mode: params.mode,
        users_file: params.usersFile,
        passwords_file: params.passwordsFile,
        password: params.password || params.originalPassword,
        dc_ip: params.dcIp
      }))
      handlers.setShowPreview(true)
    } catch (error: any) {
      console.error('Error obteniendo preview de Kerbrute:', error)
      toast.error('Error al obtener preview del comando')
    }
  }

  return {
    handleJohnWithPreview,
    handleHashcatWithPreview,
    handleKerbruteWithPreview
  }
}


